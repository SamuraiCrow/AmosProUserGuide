<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 5.2.7.2 (Linux)"/>
  <meta name="created" content="2017-10-03T07:45:59.867185938"/>
  <meta name="changed" content="2017-10-04T06:01:07.644013395"/>
</head>
<body>
<h1></h1>
<p>Object Control</p>
<p>07.01</p>
<p>Hardware Sprites</p>
<p>07.02</p>
<p>Blitter Objects</p>
<p>07.03</p>
<p>Updating Objects</p>
<p>07.04</p>
<p>Detecting Collisions</p>
<p>07.05</p>
<p>IFF Animation</p>
<p>07.06</p>
<p>AMAL</p>
<p>07.07</p>
<p>Icons and Blocks</p>
<h1 style="page-break-before:always; "></h1>
<p>Hardware Sprites</p>
<p>Section 7 of this User Guide concentrates on the moving image. You will learn how to create, edit and </p>
<p>control moving objects and backgrounds, how to make them react to one another and how to create </p>
<p>professional animations.</p>
<p>AMOS Professional offers a choice of two moving-object systems, each with its own characteristics </p>
<p>and benefits. Objects stored as part of the current screen are featured in the next Chapter. These blitter </p>
<p>objects (Bobs) are easy to use, very fast and incredibly flexible. Unfortunately, they consume a lot of </p>
<p>memory and tend to slow down on 32 or 64-colour displays.</p>
<p>By contrast, this Chapter deals with those graphical objects that exist independently from the screen, </p>
<p>known as Sprites. You will discover how AMOS Professional shatters the limitations imposed by the </p>
<p>Amiga on the number, size and colours of Sprites, and how to fully exploit their potential.</p>
<p><b>Normal hardware Sprites</b></p>
<p>Sprites are directly generated by the Amiga's hardware. Because they are completely independent </p>
<p>from the screen, they can be moved at very high speeds over any type of screen, including the 4096-</p>
<p>colour screens achieved in HAM mode. This makes hardware Sprites ideal for use in arcade games.</p>
<p>The Amiga offers up to eight hardware Sprites for instant display over any position on screen. They </p>
<p>are supposed to be exactly 16 units wide, up to 270 scan lines high and feature three colours, with </p>
<p>colour   zero   “transparent”,   allowing   the   background   screen   to   show   through.   The   computer's </p>
<p>hardware can also combine pairs of Sprites, increasing the range of colours to 15, but halving the </p>
<p>number of available Sprites to just four.</p>
<p>A choice between eight 3-colour  and four  15-colour  Sprites on screen is very limited, and quite </p>
<p>unacceptable to the AMOS Professional programmer, so the old Rule Book has been torn up and </p>
<p>rewritten for your benefit.</p>
<p><b>AMOS Professional computed Sprites</b></p>
<p>The   AMOS   Professional   system   takes   the   original   hardware   Sprites   and   combines   them   in   a </p>
<p>revolutionary way. The new “computed Sprites” are extremely powerful, they are perfect for the </p>
<p>games programmer and they offer the following advantages:</p>
<p>•</p>
<p>56 computed Sprites are allowed on screen at once.</p>
<p>•</p>
<p>Each Sprite can feature up to 15 colours.</p>
<p>•</p>
<p>Each Sprite may be up to 64 units wide.</p>
<p>•</p>
<p>Each Sprite may be up to 270 lines high.</p>
<p>In   order   to   take   full   advantage   of   computed   Sprites   in   practice,   you   will   need   some   working </p>
<p>knowledge of the theory behind them.</p>
<p>AMOS Professional computed Sprites rely on the fact that each original Amiga hardware Sprite is up </p>
<p>to 270 units high. So if your required image is smaller than this, most of the Sprite area is effectively </p>
<p>wasted. Look at the diagram below, which shows a single hardware Sprite positioned at the centre of </p>
<p>a typical screen.</p>
<p>07.01.01</p>
<p>S</p>
<p>P</p>
<p>R</p>
<p>I</p>
<p>T</p>
<p>E</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Hardware Sprites</p>
<p><b>A 16 x 16 hardware sprite</b></p>
<p>If this hardware Sprite is split into segments, and each segment is assigned to a separate image, the </p>
<p>same   memory   area   of   this   single   Sprite   can   be   used   to   display   up   to   16   simultaneous   images. </p>
<p>Fortunately, the Amiga's hardware allows each of these segments to be repositioned anywhere on the </p>
<p>current line, as illustrated by the next diagram.</p>
<p><b>Computed sprites</b></p>
<p>Because there are up to eight 3-colour or four 15-colour Sprites available for AMOS Professional to </p>
<p>commandeer and use, you are given access to dozens of objects on the screen at the same time. </p>
<p>However, there is still the size restriction to be overcome.</p>
<p>By  displaying  two  or   more  16-pixel  Sprites   side  by  side,   larger   objects  can  be  created,   up  to   a </p>
<p>maximum width of 64 pixels for 15-colour and 128 pixels for 3-colour Sprites. Even if these width </p>
<p>limits  are  exceeded,   your   programs   will  still  run,   although   it  is   highly  likely   that   your   SPRITE </p>
<p>command will be completely ignored!</p>
<p>When you use a mixture of 3-colour and 15-colour Sprites on the same screen, it is much safer to  </p>
<p>assume that the lower width limit totalling 64 pixels applies. Alternatively, the maximum total line </p>
<p>widths of Sprites may be calculated as follows:</p>
<p>total width = (Width of all 15-colour Sprites)*2 + (Width of all 3-colour Sprites)</p>
<p>07.01.02</p>
<p>S</p>
<p>P</p>
<p>R</p>
<p>I</p>
<p>T</p>
<p>E</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Hardware Sprites</p>
<p>By  assuming   that   the   total   width   must  <b>always</b>  be  less   than   128  pixels,   you   will   not   cause   any </p>
<p>disasters.</p>
<p><b>Hardware Sprites versus computed Sprites</b></p>
<p>The greatest problem when using computed Sprites is that you never know precisely which hardware </p>
<p>Sprite is going to be assigned to any particular object! Each computed Sprite can be instructed from a </p>
<p>mixture of hardware Sprites, and the mixture changes every time the object is moved on the screen.</p>
<p>This can lead to major problems, especially if you need to animate objects that must stay visible in a </p>
<p>wide range of Sprite combinations. In these circumstances it is useful to assign a specific group of </p>
<p>hardware Sprites to a single object, and the SPRITE command allows you to allocate such Sprites </p>
<p>directly by using an identification number between 0 and 7. For Example, the next line allocates </p>
<p>hardware Sprite 2 to image number 1, and positions it at coordinates 200,100:</p>
<p>Sprite 2,200,100,1</p>
<p>After a Sprite has been grabbed in this way, it will be completely removed from the computed Sprite </p>
<p>system, so there will be an inevitable reduction in the number of computed Sprites that can be </p>
<p>displayed on screen.</p>
<p>If the required image is wider than 16 pixels, AMOS Professional will automatically assign additional </p>
<p>hardware Sprites to this object. These Sprites will be allocated in consecutive order, starting from your </p>
<p>original Sprite number.</p>
<p>Look again at the last example line above. Suppose that image number 1 contains a 30 by 20 picture in </p>
<p>three colours. The SPRITE command will automatically grab Sprite number 3 as well as number 2, so </p>
<p>any future attempt to display Sprite number 3 would fail, because it is already in use. You would then </p>
<p>be restricted to assigning hardware Sprites 0,1,4,5,6 and 7 only, and greatly reducing the number of </p>
<p>possible computed Sprites.</p>
<p>It is also important to understand that each 15-colour Sprite is actually displayed by using a pair of 3-</p>
<p>colour Sprites. The Amiga's hardware allows you to combine matched pairs of Sprites in the following </p>
<p>groups only:</p>
<p>0 and 1, 2 and 3, 4 and 5, 6 and 7.</p>
<p>So it is vital to assign 15-colour images to <b>even</b> Sprite numbers, or AMOS Professional will be forced </p>
<p>to display your object using the next pair of Sprite numbers, which is a complete waste of a Sprite.</p>
<p>There is a trouble-shooting section at the end of this Chapter, which should answer the most common </p>
<p>problems   experienced   with   Sprites.   Meanwhile,   please   load   this   ready-made   program,   which </p>
<p>demonstrates the advantages of using computed Sprites over Bobs:</p>
<p>Load “AMOSPro Tutorials:Tutorials/Sprites_v_Bobs.AMOS”</p>
<p>07.01.03</p>
<p>S</p>
<p>P</p>
<p>R</p>
<p>I</p>
<p>T</p>
<p>E</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Hardware Sprites</p>
<p><b>The Sprite command</b></p>
<p><b>SPRITE</b></p>
<p><i>instruction: display a Sprite on the screen</i></p>
<p><b>Sprite Sprite</b> number</p>
<p><b>Sprite Sprite</b> number,<i>hx,hy,image number</i></p>
<p>The   SPRITE   command   assigns   an   image   to   a   Sprite,   and   displays   it   at   the   selected   hardware </p>
<p>coordinates.</p>
<p>The Sprite number can range from 0 to 63. Normally, Sprite number zero is not available because it is </p>
<p>already allocated to the mouse pointer. To ensure that you have the maximum number of Sprites at </p>
<p>your   disposal,   remove   the   mouse   pointer   from   the   screen   with   HIDE   ON.   Sprite   identification </p>
<p>numbers   from   0   to   7   refer   to   the   eight   hardware   Sprites   whose   limitations   have   already   been </p>
<p>explained. You will probably want to make use of the AMOS Professional computed Sprites in your </p>
<p>programs instead, and these are assigned the numbers from 8 to 63.</p>
<p>The hardware coordinates hx and hy set the position at which the Sprite will be displayed. Since </p>
<p>Sprites are totally independent from the current screen, normal screen coordinates cannot be used for </p>
<p>this purpose. Instead, all Sprites are positioned by special hardware coordinates as used by the mouse </p>
<p>pointer and the SCREEN DISPLAY command. Hardware coordinates can be converted from normal </p>
<p>screen coordinates by the X HARD and Y HARD functions, which are explained later.</p>
<p>The position of the Sprite is measured from a single spot related to that Sprite, known as the “hot  </p>
<p>spot”. This is usually taken to be the top left-hand corner of the Sprite, but it can be placed anywhere </p>
<p>you like using the HOT SPOT command. Hot spots are explained in detail near the end of this </p>
<p>Chapter.</p>
<p>When the Sprite has been allocated an identification number and given its display coordinates, you </p>
<p>must select an image for the Sprite to display. Images are created using the Object Editor (there is a </p>
<p>guided tour of this process in Chapter 13.2) and deposited in the Object Bank, which is normally </p>
<p>memory bank 1. Each image in this bank is assigned its own number, starting from one. To select an </p>
<p>image for a Sprite to display, simply give the appropriate image number. Sprite images may be </p>
<p>installed into your programs using the LOAD command, like this:</p>
<p>Load “Sprites.Abk”</p>
<p>Once images have been installed in this way they will be saved along with your AMOS Professional </p>
<p>programs automatically.</p>
<p>The image number and coordinate parameters can be omitted after a SPRITE command, but the </p>
<p>appropriate commas must be included.</p>
<p>07.01.04</p>
<p>S</p>
<p>P</p>
<p>R</p>
<p>I</p>
<p>T</p>
<p>E</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Hardware Sprites</p>
<p>For example:</p>
<p>Load “AMOSPro Tutorial:Objects/Sprites.Abk”</p>
<p>Flash Off : Get Sprite Palette</p>
<p>Curs Off : Cls 0</p>
<p>Sprite 8,200,100,1</p>
<p>Wait Key</p>
<p>Sprite 8,,150,1</p>
<p>Wait Key</p>
<p>Sprite 8,250,,1</p>
<p>Wait Key</p>
<p>Sprite 8,,,2</p>
<p><b>DEL SPRITE</b></p>
<p><i>instruction: delete an image from the Object Bank</i></p>
<p><b>Del Sprite</b> number</p>
<p><b>Del Sprite</b> first <b>To</b> last</p>
<p>The DEL SPRITE command permanently deletes one or more Sprite images from the Object Bank. To </p>
<p>erase a single image, simply give the image number to be deleted, like this:</p>
<p>Del Sprite 2</p>
<p>Whenever an image is deleted, all the subsequent images in the Bank are moved up one place in the  </p>
<p>numerical order. For instance, if the Bank originally contained four images, the above example would </p>
<p>remove image number 2 from memory, leaving a gap between images 1 and 3. This gap would be </p>
<p>filled immediately, as the old image numbers 3and 4 were shunted up one place, to become the new </p>
<p>image numbers 2 and 3.</p>
<p>If more than one image is to be removed from the Bank, you can set the range from the first image to </p>
<p>the last after a DEL SPRITE command. The following example would delete Sprite images 4,5,6 and 7:</p>
<p>Del Sprite 4 To 7</p>
<p>After the last image has been deleted from the Object Bank, the entire Bank is erased automatically.</p>
<p><b>INS SPRITE</b></p>
<p><i>instruction: insert a blank Sprite image into the Object bank</i></p>
<p><b>Ins Sprite</b> number</p>
<p><b>Ins Sprite</b> first <b>To</b> last</p>
<p>INS SPRITE inserts a blank image at the numbered position in the current Object Bank. All of the </p>
<p>images after this numbered position will then be moved down one place in the numerical order. The </p>
<p>second version of this command allows you to create several spaces in a single operation, by giving </p>
<p>the range of new gaps between the first and last image numbers that you specify.</p>
<p>07.01.05</p>
<p>S</p>
<p>P</p>
<p>R</p>
<p>I</p>
<p>T</p>
<p>E</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Hardware Sprites</p>
<p>Any of these new image spaces are completely empty, and so cannot be allocated to a Sprite Or </p>
<p>displayed directly on screen while they are still blank. An actual image must first be grabbed into the  </p>
<p>Object Bank, using a GET SPRITE or GET BOB command. If this is not done, the appropriate error </p>
<p>message will be given as soon as you try to access the empty image.</p>
<p>Both DEL SPRITE and INS SPRITE are provided to be used with the GET BOB and GET SPRITE  </p>
<p>commands. They allow you to modify and adjust your Sprite images from inside AMOS Professional </p>
<p>programs, with complete freedom.</p>
<p><b>The Sprite Palette</b></p>
<p>Although Sprites are independent of the screen, the colours that they use are definitely not! So before </p>
<p>displaying a Sprite image it is essential to grab the correct colours. All colours are taken from the </p>
<p>standard 32 colour registers provided by the Amiga's hardware, but the precise registers to be used </p>
<p>depend on the type of Sprite.</p>
<p><b>15-colour Sprites</b>. These use colour registers 16 to 31, which may not be needed by 16-colour screens, </p>
<p>but are vital when 32-colour and 64-colour modes are in use, ensuring that these Sprite images are </p>
<p>totally consistent with the screen background.</p>
<p>If you employ background screen graphics created with a commercial drawing package such as </p>
<p>Deluxe Paint, you must ensure that your Sprite images use exactly the same colour values as the </p>
<p>screen image. This presents no problem to AMOS Professional, and is achieved as follows.</p>
<p>Load the colour palette from an IFF file of the screen image directly into the AMOS Professional </p>
<p>Object Editor, using the [Grabber] option to select any part of the picture. Please see Chapter 13.2 for </p>
<p>full details. The correct colour values are copied directly to the Sprite Bank, and will be saved along </p>
<p>with your images automatically.</p>
<p>It is also possible to display 32-colour image files on a 16-colour screen. Because the Bob and Sprite </p>
<p>palettes are completely separate, colours 0 to 15 can be reserved for Bobs and colours 16 to 31 for </p>
<p>Sprites.</p>
<p><b>3-colour Sprites</b>. Things are a little more complex when using these, because each pair of Sprites uses </p>
<p>its own set of colour registers, as follows:</p>
<p><b>Hardware Sprites</b></p>
<p><b>Transparent</b></p>
<p><b>Colour registers</b></p>
<p>0 and 1</p>
<p>16</p>
<p>17,18,19</p>
<p>2 and 3</p>
<p>20</p>
<p>21,22,23</p>
<p>4 and 5</p>
<p>24</p>
<p>25,26,27</p>
<p>6 and 7</p>
<p>28</p>
<p>29,30,31</p>
<p>Note that for each pair of Sprites there is one register that is assumed to be transparent, and three </p>
<p>colour registers.</p>
<p>07.01.06</p>
<p>S</p>
<p>P</p>
<p>R</p>
<p>I</p>
<p>T</p>
<p>E</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Hardware Sprites</p>
<p>As has been explained, the hardware sprites used to create computed sprites will vary during the </p>
<p>course of your program, so it is vital that the three colours used by each pair of hardware sprites are </p>
<p>exactly the same. A procedure is provided to accomplish this, and it may be found along with a host </p>
<p>of other useful procedures, in Appendix C.</p>
<p><b>GET SPRITE PALETTE</b></p>
<p><i>instruction: grab sprite colours into screen</i></p>
<p><b>Get Sprite Palette</b></p>
<p><b>Get Sprite Palette</b> <i>mask</i></p>
<p>This command copies the colour values used by your Sprite and Bob images and loads them into the </p>
<p>current   screen.   It   is   an   intelligent   instruction,   so   if   16-colour   screens   are   in   use,   values   are </p>
<p>automatically copied into colour registers 16 to 31. This means that you can use the same images for </p>
<p>either Bobs or Sprites with no risk of colour clashes! Here is an example:</p>
<p>Load “AMOSPro Tutorial:Objects/Sprites.Abk”</p>
<p>Curs Off : Flash Off : Cls 0</p>
<p>Get Sprite Palette</p>
<p>Rem Set computed Sprite at hardware coords 128,50 using image 1</p>
<p>Sprite 8,128,50,1</p>
<p>Wait Key</p>
<p>The optional mask parameter allows the colour selection to be limited. Each colour is represented by a </p>
<p>single digit in a 32-digit bit mask. If the appropriate digit is set to 1, the colour is copied from the </p>
<p>Object Bank. Any colours to be omitted (masked) should have their digit set to 0. The following  </p>
<p>example copies colours 0 to 3 from the Object Bank into the screen:</p>
<p>Get Sprite Palette %0000000000001111</p>
<p>Because the mask is entered as a normal number, either hexadecimal or decimal modes can also be </p>
<p>used:</p>
<p>Get Sprite Palette $FFFF0000</p>
<p>Please   note   that   the   GET   BOB   PALETTE   and   GET   OBJECT   PALETTE   instructions   perform   an </p>
<p>identical task to the GET SPRITE PALETTE command.</p>
<p><b>GET SPRITE</b></p>
<p><i>instruction: grab screen image into the Object Bank</i></p>
<p><b>Get Sprite</b> image number,x1,y1 <b>To</b> x2,y2</p>
<p><b>Get Sprite</b> <i>screen number</i>,image number,x1,y1 <b>To</b> x2,y2</p>
<p>Use this command to grab images directly from the screen and transform them into Sprites. Simply </p>
<p>define the new image number, then give the coordinates, from top left-hand to bottom right-hand </p>
<p>corner, of the rectangular area to be loaded into the Sprite Bank. The image will be grabbed from the </p>
<p>current screen unless an optional screen number is specified.</p>
<p>Provided   that   the   given   coordinates   lie   inside   of   existing   screen   borders,   there   are   no </p>
<p>limitations to the area that can be grabbed in this way.</p>
<p>07.01.07</p>
<p>S</p>
<p>P</p>
<p>R</p>
<p>I</p>
<p>T</p>
<p>E</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Hardware Sprites</p>
<p>If there is no existing Sprite with the selected number, it will be created automatically. Similarly, the </p>
<p>Sprite Bank will be reserved by AMOS Professional, if it is not already defined.</p>
<p>It   should   be   noted   that   the   GET   BOB   instruction   is   identical   to   GET   SPRITE,   making   them </p>
<p>interchangeable.</p>
<p><b>SET SPRITE BUFFER</b></p>
<p><i>instruction: set maximum height of Sprites</i></p>
<p><b>Set Sprite Buffer</b> number</p>
<p>This command allocates extra memory for hardware and computed Sprites to work within. Although </p>
<p>each hardware Sprite can be up to 270 lines in height, AMOS Professional reserves sufficient memory </p>
<p>for 128 lines, as the default allocation.</p>
<p>If you are using computed Sprites, it is more practical to extend the SET SPRITE BUFFER number to a </p>
<p>larger value. This is economical on memory, since each line only consumes 96 bytes. Thus a maximum </p>
<p>height value of 256 would require about 12k of extra memory.</p>
<p>Be warned that this command erases all current Sprite assignments, as well as re-setting the mouse </p>
<p>pointer, so it must be used at the beginning of your programs! For example, the following line would </p>
<p>be placed at the start of your listing:</p>
<p>Set Sprite Buffer 256</p>
<p><b>Sprite Commands</b></p>
<p><b>SPRITE UPDATE</b></p>
<p><i>instruction: control Sprite movements</i></p>
<p><b>Sprite Update</b></p>
<p><b>Sprite Update Off</b></p>
<p><b>Sprite Update On</b></p>
<p>The SPRITE UPDATE family of commands provide total control of Sprite movements. Normally, </p>
<p>when a Sprite is moved its position is updated automatically during the next vertical blank period. </p>
<p>Please see WAIT VBL if this needs explaining. However, when many Sprites are moved with the </p>
<p>SPRITE command, updates will happen before all of the Sprites have been successfully repositioned, </p>
<p>which can result in jerky patterns of movement. In these circumstances, the automatic updating </p>
<p>system can be turned off with a SPRITE UPDATE OFF command.</p>
<p>When the Sprites have been moved successfully, a call to SPRITE UPDATE will reposition any Sprites </p>
<p>that have been moved since the last update. Alternatively, SPRITE UPDATE ON returns to the default </p>
<p>status of automatic updating.</p>
<p><b>SPRITE OFF</b></p>
<p><i>instruction: remove Sprites from screen</i></p>
<p><b>Sprite Off</b></p>
<p><b>Sprite Off</b> <i>number</i></p>
<p>07.01.08</p>
<p>S</p>
<p>P</p>
<p>R</p>
<p>I</p>
<p>T</p>
<p>E</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Hardware Sprites</p>
<p>The SPRITE OFF command removes all sprites from your display, and all current Sprite movements </p>
<p>are aborted. To re-start them, the movement pattern must be initialised again. (Please see the AMAL </p>
<p>facilities explained in Chapter 7.6). If an optional Sprite number is given, only that Sprite will be de-</p>
<p>activated and removed from the screen.</p>
<p>Please note that Sprites are de-activated every time the AMOS Professional editor is called up. Sprites </p>
<p>are automatically returned to their original positions the next time Direct Mode is entered.</p>
<p><b>X SPRITE</b></p>
<p><i>function: return x-coordinate of a Sprite</i></p>
<p>x=<b>X Sprite</b>(number)</p>
<p>This function returns the current x-coordinate of the Sprite whose number is given in brackets. The  </p>
<p>Sprite number can range from 0 to 63, and positions are given in hardware coordinates. Use X SPRITE </p>
<p>to check if a Sprite has passed off the edge of the screen.</p>
<p><b>Y SPRITE</b></p>
<p><i>function: return y-coordinate of a Sprite</i></p>
<p>y=<b>Y Sprite</b>(number)</p>
<p>This gives the vertical position of the specified Sprite, measured in hardware coordinates.</p>
<p><b>I SPRITE</b></p>
<p><i>function: return current image number of a Sprite</i></p>
<p>image=<b>I Sprite</b>(number)</p>
<p>This function returns the current image number being used by the specified Sprite. If the Sprite is not </p>
<p>displayed, a value of zero will be returned.</p>
<p><b>Conversion Functions</b></p>
<p><b>X SCREEN</b></p>
<p><i>function: convert hardware x-coordinate to screen x-coordinate</i></p>
<p>x=<b>X Screen</b>(xcoordinate)</p>
<p>x=<b>X Screen</b>(<i>screen number</i>,xcoordinate)</p>
<p><b>Y SCREEN</b></p>
<p><i>function: convert hardware y-coordinate to screen y-coordinate</i></p>
<p>y=<b>Y Screen</b>(ycoordinate)</p>
<p>y=<b>Y Screen</b>(<i>screen number</i>,ycoordinate)</p>
<p>These functions transform a hardware coordinate into a screen coordinate, relative to the current </p>
<p>screen. If the hardware coordinates lie outside of the screen, both functions will return relative offsets  </p>
<p>from   the   screen   boundaries.   An   optional   screen   number   may   be   included,   in   which   case   the </p>
<p>coordinates will be returned relative to that screen.</p>
<p>07.01.09</p>
<p>S</p>
<p>P</p>
<p>R</p>
<p>I</p>
<p>T</p>
<p>E</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Hardware Sprites</p>
<p><b>X HARD</b></p>
<p><i>function: convert screen x-coordinate into hardware x-coordinate</i></p>
<p>x=<b>X Hard</b>(xcoordinate)</p>
<p>x=<b>X Hard</b>(<i>screen number</i>,xcoordinate)</p>
<p><b>Y HARD</b></p>
<p><i>function: convert screen y-coordinate into hardware y-coordinate</i></p>
<p>y=<b>Y Hard</b>(ycoordinate)</p>
<p>y=<b>Y Hard</b>(<i>screen number</i>,ycoordinate)</p>
<p>These functions convert screen coordinates into hardware coordinates, relative to the current screen. </p>
<p>As with XSCREEN and Y SCREEN, an optional screen number can be given, and coordinates will be </p>
<p>returned relative to that screen.</p>
<p>With all four of the above functions, sensible values can only be returned when the relevant screen </p>
<p>has been fully initialised. Both the SCREEN OPEN and SCREEN DISPLAY commands only come into </p>
<p>effect   from   the   next   vertical   blank,   and   the   following   examples   demonstrate   that   the   correct </p>
<p>coordinate values (in this case 128,50) are only returned after a WAIT VBL command.</p>
<p>Screen Open 0,320,255,16,Lowres</p>
<p>Print X Hard(0,0); Y Hard(0,0)</p>
<p>Now try the correct version:</p>
<p>Screen Open 0,320,255,16,Lowres</p>
<p>Wait Vbl</p>
<p>Print X Hard(0,0); Y Hard(0,0)</p>
<p>The default screen is initially located at hardware coordinates (128,50), and if you find the whole </p>
<p>business   of   hardware   coordinates   and   screen   coordinates   tiresome,   you   can   bypass   the   entire </p>
<p>conversion system.</p>
<p>By setting the HOT SPOT of your Sprite images to (-128,-50), the reference point for all position </p>
<p>calculations is removed to the far corner of the display. Once an image has been prepared in this way,  </p>
<p>it can be assigned to a Sprite and moved around using normal screen coordinates. For example:</p>
<p>Hot Spot 1,-128,-50: Rem Set up hot spot</p>
<p>Sprite 8,160,100,1 : Rem Sprite 8 to screen coords 160,100</p>
<p><b>The Hot Spot</b></p>
<p>Whenever an image is drawn on screen using the SPRITE or BOB command, it is positioned using an </p>
<p>invisible reference point known as the “hot spot”. This reference point is then used for all coordinate </p>
<p>calculations.</p>
<p>07.01.10</p>
<p>S</p>
<p>P</p>
<p>R</p>
<p>I</p>
<p>T</p>
<p>E</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Hardware Sprites</p>
<p><b>HOT SPOT</b></p>
<p><i>instruction: set reference point for all coordinate calculations</i></p>
<p><b>Hot Spot</b> image number,x,y</p>
<p><b>Hot Spot</b> image number,pre-set value</p>
<p>The HOT SPOT command sets the hot spot of an image stored in the current Object Bank. The hot </p>
<p>spot   x,y-offset   is   measured   from   the   top   left-hand   corner   of   the   image,   and   is   added   to   those </p>
<p>coordinates before use, as illustrated in the following diagram:</p>
<p>It is perfectly legal to position the hot spot outside of the current screen display. This can be used for  </p>
<p>automatic conversion of all screen coordinates, as explained above, or to set up a games sequence </p>
<p>with Sprites appearing from off-screen.</p>
<p>There is another version of this instruction, allowing automatic positioning of the hot spot to any one </p>
<p>of nine pre-set positions. These positions are shown in the following diagram, with the central point </p>
<p>of the Object image represented by the value $11. The value for a pre-set hot spot at the top right-</p>
<p>hand corner of the image is $20, for the bottom left-hand corner $02, and so on.</p>
<p><b>The Sprite Doctor</b></p>
<p>The final part of this Chapter contains some instant diagnoses and remedies for common Sprite </p>
<p>illnesses!</p>
<p><b>Problem:</b> I can't display hardware Sprite zero. It does not want to appear.</p>
<p><b>Remedy:</b> Hardware Sprite zero is already allocated to the mouse pointer.</p>
<p>Use HIDE ON to remove the mouse pointer from the screen, and try again.</p>
<p>07.01.11</p>
<p>S</p>
<p>P</p>
<p>R</p>
<p>I</p>
<p>T</p>
<p>E</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Hardware Sprites</p>
<p><b>Problem:</b>  Whenever the distance between my computed Sprites exceeds about half the screen, the </p>
<p>lower ones vanish.</p>
<p><b>Remedy:</b> Although hardware Sprites can be a maximum of 270 units high, the default setting is 128. </p>
<p>Increase the height using SET SPRITE BUFFER by placing the following line at the start of your </p>
<p>program:</p>
<p>Set Sprite Buffer 256</p>
<p><b>Problem:</b> How do I display 15-colour Sprites on a 32 or 64-colour screen?</p>
<p><b>Remedy:</b> Create your images in 32-colour mode, and draw your Sprites using colour numbers 16 to </p>
<p>31. When these images are loaded into your program, the Sprites will be displayed correctly.</p>
<p><b>Problem:</b> When I try to move Sprites with AMAL, some of the objects disappear at random.</p>
<p><b>Remedy:</b> The total width of your Sprites exceeds the maximum of 64. You should read the User Guide </p>
<p>more thoroughly! Replace some of your larger Sprites with Bobs to free up as many component </p>
<p>hardware Sprites as possible. Alternatively, reduce the total number of Sprites on the screen and try </p>
<p>using a small number of fast objects instead of a large number of slower ones.</p>
<p><b>Problem:</b> When I move the screen with SCREEN OFFSET and SCREEN DISPLAY, my Sprites go most </p>
<p>peculiar.</p>
<p><b>Remedy:</b>  There is a hardware  confrontation  between the Sprite  system  and the Display system, </p>
<p>probably because AMOS Professional is stretching your Amiga to its absolute limits! Reduce the load </p>
<p>on the system as follows. At the start of your program, just after the SET SPRITE BUFFER command, </p>
<p>define hardware Sprites 6 and 7 using the SPRITE command. Now assign these Sprites to negative </p>
<p>coordinates, and position them off the screen. It is now impossible to use them for computed Sprites, </p>
<p>and if they are never displayed on the screen during your scrolling operations, your problem is </p>
<p>solved.</p>
<p>07.01.12</p>
<p>S</p>
<p>P</p>
<p>R</p>
<p>I</p>
<p>T</p>
<p>E</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Blitter Objects</p>
<p>In this Chapter you will learn how to take full advantage of the Amiga's “Blitter” chip, which can </p>
<p>copy large sections of a screen almost instantaneously.</p>
<p>At its fastest, the Blitter can move a million screen points per second, which is the equivalent of a </p>
<p>dozen graphic screens. AMOS Professional exploits this facility for the incredible speed achieved in </p>
<p>commands like SCREEN COPY, but the Blitter is capable of far more than simple graphics.</p>
<p>Professional animations are readily available, using special “Blitter Objects” known as “Bobs”. Bobs </p>
<p>can be displayed at any point on the screen and freely moved over the entire screen area, without </p>
<p>disturbing any existing graphics. They may be guided, tested for collisions and even animated with </p>
<p>AMAL, exactly like Sprites.</p>
<p>The main advantage of Bobs over Sprites is that they are far easier to use. There is no limit to the size </p>
<p>or number of Bobs, and they are stored as part of the current screen, so all positions are measured in </p>
<p>simple screen coordinates. As has been explained in the previous Chapter, Sprites only work in </p>
<p>certain combinations, but Bobs may be displayed with no restrictions at all, at any position, and in </p>
<p>vast numbers. The only limit is the amount of available memory! The other main advantage over </p>
<p>Sprites is that Bobs can have up to 64 colours.</p>
<p>Naturally, all this power carries a price tag, and although Bobs are more flexible than Sprites, they are </p>
<p>also slightly slower and consume additional memory. So the ideal solution is to use both Sprites and </p>
<p>Bobs to their full advantage in the same program. They make a superb team, just like your Amiga,  </p>
<p>AMOS Professional and you!</p>
<p><b>Displaying a Bob</b></p>
<p>Images to be used as Bobs are stored in memory Bank 1, and are each referred to by a simple number,  </p>
<p>which ranges from 1 up to the maximum number of objects in the bank. Load up some images now, </p>
<p>like this:</p>
<p>Load “AMOSPro Tutorial:Objects/Bobs.abk”</p>
<p>To find how many objects are in memory bank 1, use the LENGTH function for an instant read- out. </p>
<p>Type this next line from Direct Mode:</p>
<p>Print Length(1)</p>
<p>This Object Bank is also used for any Sprite images, so the same objects can be displayed as Bobs or  </p>
<p>Sprites with great ease. To create a Bob, the image of an object is taken from the bank, and allocated </p>
<p>for display as follows.</p>
<p><b>BOB</b></p>
<p><i>instruction: display a Bob on screen</i></p>
<p><b>Bob</b> number,image</p>
<p><b>Bob</b> number,x,y,image</p>
<p>Each Bob must be given an identification number from 0 to 63. As a default, only 64 Bobs may be </p>
<p>displayed on screen at once, but this limit can be increased if necessary.</p>
<p>07.02.01</p>
<p>B</p>
<p>O</p>
<p>B</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Blitter Objects</p>
<p>Unlike Sprites, which use complex hardware coordinates, Bobs are displayed using standard screen </p>
<p>coordinates, measured from the top left-hand corner of the current screen. Set the position of your </p>
<p>new Bob by giving it screen coordinates relative to the hot spot of your chosen image number. Hot </p>
<p>spots are explained at the end of the last Chapter.</p>
<p>If the coordinates lie outside of the existing screen area, the Bob will not be displayed. So objects can </p>
<p>be initialised off screen, ready to be moved into place during the course of your program.</p>
<p>Once a Bob has been positioned on screen, the coordinate values become optional. The values of any </p>
<p>coordinate parameters that are omitted will be remembered from the last time they were set. In </p>
<p>Chapter 7.6 it is explained how this technique is valuable for animating Bobs with AMAL, because it </p>
<p>allows objects to be moved effortlessly, without disturbing any existing animation sequences. It is </p>
<p>vital to include all commas in their normal positions if coordinate values are omitted, or a syntax </p>
<p>error will be reported. For example:</p>
<p>Bob 1,160,100,1 : Rem Position Bob 1 at 160,100 using image1</p>
<p>Bob 1,,150,1 : Rem Move Bob 1 down 50 pixels</p>
<p>Bob 1,110,,1 : Rem Move Bob 1 50 pixels left</p>
<p>Bob 1,,,2 : Rem Display new image 2 at Bob 1 current position</p>
<p>Before   examining   the   next   instant   demonstration   program,   here   is   a   step-by-step   technique   for </p>
<p>correctly displaying a Bob.</p>
<p>•</p>
<p>First,   some   images   must   be   made   available   for   Bobs   to   use,   with   a   call   to   LOAD   the </p>
<p>appropriate filename. Once images have been loaded, they are saved as part of your Basic </p>
<p>program automatically.</p>
<p>•</p>
<p>If you intend to load a picture for use as a background screen, now is the time to do it. Use a </p>
<p>line such as:</p>
<p>Load Iff “Picture.IFF”</p>
<p>Alternatively, the default screen can be prepared by removing the flashing cursor from the display </p>
<p>and filling the display with a large block of colour, usually black. For example:</p>
<p>Curs Off: Flash Off : Cls 0</p>
<p>•</p>
<p>Now the correct image colours should be grabbed from the Object Bank. Note that if Bobs are </p>
<p>to be displayed against an existing background screen, you will need to ensure that the images </p>
<p>use exactly the same colour values as your picture, otherwise serious colour clashes will be </p>
<p>generated. GET BOB PALETTE can be called if you are using Bobs on their own, or call GET </p>
<p>SPRITE PALETTE for use with either Sprites or Bobs.</p>
<p>•</p>
<p>The automatic AMOS Professional “double buffering” system should now be engaged, with a </p>
<p>simple DOUBLE BUFFER command. The theory and practice of this is explained later, but in </p>
<p>essence,   double   buffering   creates   an   invisible   copy   of   the   current   screen   where   drawing</p>
<p>07.02.02</p>
<p>B</p>
<p>O</p>
<p>B</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Blitter Objects</p>
<p>operations take place, resulting in beautifully smooth movement effects.</p>
<p>•</p>
<p>Finally, your Bobs are assigned their individual starting positions. This could be a simple series </p>
<p>of BOB commands, or a complex pattern of off-screen starting points for each level of an </p>
<p>arcade game.</p>
<p><b>General Bob Commands</b></p>
<p><b>BOB OFF</b></p>
<p><i>instruction: remove a Bob from display</i></p>
<p><b>Bob Off</b></p>
<p><b>Bob Off</b> number</p>
<p>Use this command to remove all Bobs from the screen simultaneously. If a Bob number is specified, </p>
<p>only that Bob will be extinguished. For example:</p>
<p>Bob Off 1: Rem Remove Bob1 only</p>
<p>Bob Off : Rem Remove all Bobs from screen</p>
<p>The BOB OFF instruction also turns off any animation or collision routines associated with these Bobs.</p>
<p><b>X BOB</b></p>
<p><i>function: get x-coordinate of a Bob</i></p>
<p>x-coordinate=<b>X Bob</b>(number)</p>
<p><b>Y BOB</b></p>
<p><i>function: get y-coordinate of a Bob</i></p>
<p>y-coordinate=<b>Y Bob</b>(number)</p>
<p>It is not difficult to keep track of Bobs under normal circumstances, but if Bobs are moved with </p>
<p>AMAL, their coordinates can vary unpredictably. In which case, the X BOB and Y BOB functions may  </p>
<p>be used to get a snapshot of their current position, by returning the screen coordinates of your </p>
<p>selected Bob. Specify the number of the chosen Bob on screen, and the appropriate coordinate will be </p>
<p>returned, as measured from the top left-hand corner of thescreen to the hot spot of the current image. </p>
<p>For example:</p>
<p>Load “AMOSPro_Tutorial:Objects/Bobs.abk”</p>
<p>Curs Off : Cls 0: Rem Set up screen</p>
<p>Flash Off : Get Bob Palette : Rem Grab Bob colours from image bank</p>
<p>Double Buffer : Rem Engage double buffering</p>
<p>Autoback 1: Rem Engage fast drawing mode</p>
<p>Do</p>
<p>Rem Move Bob1 with mouse</p>
<p>Rem Convert hardware coords to screen coords</p>
<p>Bob 1,X Screen(X Mouse),Y Screen(Y Mouse),1</p>
<p>Rem Print new location on screen</p>
<p>Locate 0,0 : Print X Bob(1);“ ”;Y Bob(1);“ ”;</p>
<p>Loop</p>
<p>07.02.03</p>
<p>B</p>
<p>O</p>
<p>B</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Blitter Objects</p>
<p>AMOS Professional provides many alternative methods of moving Bobs, and each Bob can display a </p>
<p>sequence of different images to create animation. When animating Bobs with AMAL, it is possible to </p>
<p>loose track of the precise image currently displayed, so the next function has been supplied to rectify </p>
<p>this.</p>
<p><b>I BOB</b></p>
<p><i>function: get image number used by a Bob</i></p>
<p>image=<b>I Bob</b>(number)</p>
<p>I BOB returns the number of the image currently assigned to the specified Bob number. If the Bob  </p>
<p>number you want to examine does not exist, an illegal function error will be given, so it is vital to  </p>
<p>define the Bob correctly before calling I BOB. Here is an example:</p>
<p>Load “AMOSPro Tutorial:Objects/Bobs.abk”</p>
<p>Flash Off : Get Bob Palette : Double Buffer : Autoback 0</p>
<p>Bob 1,160,100,1: Rem Display Bob 1 at centre of screen</p>
<p>Do</p>
<p>For IMAGE=1 To Length(1) : Rem Create simple animation</p>
<p>Rem Move Bob 1 with the mouse</p>
<p>Bob 1,X Screen(X Mouse),Y Screen(Y Mouse),IMAGE</p>
<p>For W=0 To 3 : Wait Vbl : Next W</p>
<p>Rem Display image number on screen</p>
<p>Locate 0,0 : Print “Image ”;I Bob(1);“ ”;</p>
<p>Next IMAGE</p>
<p>Loop</p>
<p><b>GET BOB PALETTE</b></p>
<p><i>instruction: load image colours into current screen</i></p>
<p><b>Get Bob</b> Palette</p>
<p><b>Get Bob</b> Palette mask</p>
<p>This command loads the whole colour palette used for your Bobs into the current screen. A mask can </p>
<p>be added if you like, which will load a selection of these colours only. Each individual colour is </p>
<p>represented by one “bit” of the mask being set to a zero (off) or a one (on). Colours run from right to </p>
<p>left, so that colour zero is represented by the bit at the right-hand end of the mask, colour 1 is second  </p>
<p>from the right, and so on. Supposing there are 16 colours in your Bob palette, you would copy the first </p>
<p>four colours like this:</p>
<p> Get Bob Palette %0000000000001111</p>
<p><b>Unmasking Bobs</b></p>
<p><b>NO MASK</b></p>
<p><i>instruction: remove colour zero mask from Bob</i></p>
<p><b>No Mask</b> number</p>
<p>07.02.04</p>
<p>B</p>
<p>O</p>
<p>B</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Blitter Objects</p>
<p>A “mask” means that the background colour (colour zero) around a Bob is made transparent, so t hat </p>
<p>the screen graphics show through. The mask is also used by certain collision detection routines. A </p>
<p>mask is automatically set up for every Bob, and the NO MASK command takes away this mask, so </p>
<p>that the entire Bob image is drawn on the screen, including its original background colour and any  </p>
<p>other graphics in colour zero. To remove a mask, simply use this command followed by the number </p>
<p>of the Bob image you are interested in.</p>
<p>Never remove a mask from a Bob while it is being displayed on screen, or its image will be scrambled! </p>
<p>Remember to always use the BOB OFF command first.</p>
<p><b>Bob Priority</b></p>
<p>It is important to understand that every Bob automatically possesses a priority of importance, and </p>
<p>that this priority is based on the Bob's number. So a Bob carries a priority value from 0 to 63, and </p>
<p>AMOS Professional uses this value to decide in which order Bobs are displayed and which Bobs barge </p>
<p>their way in front of others when moving around the screen.</p>
<p>The general rule is that a Bob with a higher priority number is displayed in front of one with a lower  </p>
<p>priority number. For example, Bob 5 would cut in front of Bob 4, but be obscured if Bob 6 crossed its </p>
<p>path. So it is clear that this priority system should always be remembered when you number your </p>
<p>Bobs.</p>
<p>AMOS Professional allows changes in the priority system to suit your needs, this first system offers </p>
<p>an alternative based not on Bob numbers, but on the position of Bobs on the screen.</p>
<p><b>PRIORITY ON</b></p>
<p><i>instruction: set Bob priority to highest y-coordinate</i></p>
<p><b>Priority On</b></p>
<p><b>PRIORITY OFF</b></p>
<p><i>instruction: set Bob priority to default status</i></p>
<p><b>Priority Off</b></p>
<p>When PRIORITY ON is used, Bobs with the highest y-coordinates take priority on the screen. It is </p>
<p>usually best to set hot spots at the bottom of Bobs to exploit this priority, and some superb perspective </p>
<p>effects can be created. All that is needed to re-set the original Bob number priorities is to use the  </p>
<p>PRIORITY OFF command.</p>
<p><b>PRIORITY REVERSE ON</b></p>
<p><i>instruction: toggle on Reverse Priority of Bobs</i></p>
<p><b>Priority Reverse On</b></p>
<p><b>PRIORITY REVERSE OFF</b></p>
<p><i>instruction: toggle off Reverse Priority of Bobs</i></p>
<p><b>Priority Reverse Off</b></p>
<p>07.02.05</p>
<p>B</p>
<p>O</p>
<p>B</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Blitter Objects</p>
<p>The   PRIORITY  REVERSE   ON   command   changes   around   the   entire   priority   table   based   on   Bob </p>
<p>numbers. Not only does it give a lower Bob number priority over a higher Bob number, when used  </p>
<p>with PRIORITY ON it also gives priority to a Bob with the lowest y-coordinate. As you would expect, </p>
<p>PRIORITY REVERSE OFF sets the priority system back to normal.</p>
<p><b>Bobs and screens</b></p>
<p>AMOS Professional offers a full range of commands to allow Bobs and screens to interact.</p>
<p><b>LIMIT BOB</b></p>
<p><i>instruction: limit Bob to part of screen</i></p>
<p><b>Limit Bob</b> x1,y1 <b>To</b> x2,y2</p>
<p><b>Limit Bob</b> <i>number</i>,x1,y1 To x2,y2</p>
<p><b>Limit Bob</b></p>
<p>This command keeps all Bobs restricted to moving inside an invisible rectangular area of the screen, </p>
<p>whose coordinates are set by the usual top left to bottom right-hand corner coordinates. If LIMIT BOB </p>
<p>is followed with a Bob number, then only that Bob becomes restricted by the boundaries of the </p>
<p>rectangle.</p>
<p>Note that the width of the rectangle must always be wider than the width of the Bob, and that the x </p>
<p>-coordinates are always rounded up to the nearest 16-pixel boundary. To keep Bob number 1 trapped </p>
<p>inside an area, you would use something like this:</p>
<p>Limit Bob 1,10,0 To 320,100</p>
<p>Remember that a Bob must be called up with the BOB command before LIMIT BOB is used, otherwise  </p>
<p>the limitation will have no effect. To restore a Bob's freedom to move around the whole screen, use </p>
<p>the command without any coordinates, like this:</p>
<p>Limit Bob</p>
<p><b>DOUBLE BUFFER</b></p>
<p><i>instruction: activate Double Buffering system</i></p>
<p><b>Double Buffer</b></p>
<p>Throughout this Chapter, extensive reference is made to the technique known as “double buffering”. </p>
<p>The DOUBLE BUFFER command creates an invisible copy of the current screen and stores it as a </p>
<p>“logical screen”. All graphics operations, including Bob movements, are now performed directly on </p>
<p>this logical screen, without disturbing your existing display at all. This is because the existing display </p>
<p>on your television screen is taken straight from the original screen area, now called the “physical </p>
<p>screen”.</p>
<p>Once the image has been re-drawn, the logical screen and physical screen are swapped over. The old </p>
<p>logical screen is flicked onto the display, and the old physical screen is hidden away to become the </p>
<p>new logical screen. The entire process now cycles continuously, producing a solid, smooth display, </p>
<p>even when dozens of Bobs are moving on the same screen.</p>
<p>07.02.06</p>
<p>B</p>
<p>O</p>
<p>B</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Blitter Objects</p>
<p>Any complexities of this technique are completely automatic, so once DOUBLE BUFFER has been </p>
<p>engaged, you can relax.</p>
<p>Since hardware Sprites are overlaid directly onto your television display, double buffering will hive </p>
<p>no effect at all on any existing Sprite animations.</p>
<p>The double buffering system works equally well in all of the Amiga's graphics modes, and can also be </p>
<p>used in conjunction with dual playfields. You should be aware that double buffering requires two </p>
<p>separate areas of memory, one for the logical and one for the physical screen. So it will double the </p>
<p>amount of memory required, for example an extra 32k will be needed for a standard 16-colour screen. </p>
<p>This   means   that   if  you  try  and  DOUBLE  BUFFER  too   many   screens,   available  memory  will   be </p>
<p>exhausted.</p>
<p>In practice, double buffering is invaluable, and the additional memory required is well spent. It can be </p>
<p>exploited for advanced three-dimensional routines, and is especially useful for scrolling screen effects, </p>
<p>because the new areas of display are copied straight into the invisible background without corrupting </p>
<p>the current display.</p>
<p>As an optional extra, AMOS Professional provides total control over the entire DOUBLE BUFFER </p>
<p>system, and a full explanation may be found in the next Chapter. For a rapid insight into the effect of </p>
<p>not using DOUBLE BUFFER, make sure you run the HELP_26 demonstration program.</p>
<p>That demonstration produces a horrible flickering effect. Whenever a Bob moves around the screen, </p>
<p>the graphics beneath it are replaced at their original position. Unfortunately, since Bobs are updated </p>
<p>at the same time as the screen images, this sort of flickering effect is generated. By including a </p>
<p>DOUBLE BUFFER command, screens are switched  <b>after</b>  the drawing process is complete, and as </p>
<p>explained above, the process is completely automatic.</p>
<p><b>GET BOB</b></p>
<p><i>instruction: grab an image from part of screen</i></p>
<p><b>Get Bob</b> image,x1,x2 <b>To</b> x2,y2</p>
<p><b>Get Bob</b> <i>screen number</i>,image,x1,y1 <b>To</b> x2,y2</p>
<p>This command grabs a selected part from the current screen and copies it straight into the Object  </p>
<p>Bank. After giving the image number to be created, set the area to be grabbed from the top left-hand </p>
<p>corner to the bottom right-hand coordinates. If your chosen image number already exists, the existing </p>
<p>image will be replaced by the new picture, otherwise the new picture will be added to the bank.</p>
<p>An optional screen number may be given immediately after the GET BOB command, allowing an </p>
<p>image to be grabbed from a specific screen. Here is an example:</p>
<p>Curs Off : Cls 0 : Double Buffer : Flash Off</p>
<p>Text 50,10, “AMOS Professional Basic!”</p>
<p>Get Bob 1,50,0 To 250,20</p>
<p>For B=0 To 180</p>
<p>Bob 1,50,B,1</p>
<p>Wait Vbl</p>
<p>Next B</p>
<p>07.02.07</p>
<p>B</p>
<p>O</p>
<p>B</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Blitter Objects</p>
<p>GET BOB is an extremely useful command, allowing any section of a screen to be loaded into a Bob, </p>
<p>and then manipulated with the AMAL system. You can even write your own object editor from start </p>
<p>to finish! It is also possible to create and modify Bob images from AMOS Professional Basic. This  </p>
<p>allows, you to produce stand-alone program listings that will run without the need for external image </p>
<p>files. Try the next example:</p>
<p>Double Buffer : Flash Off : Curs Off</p>
<p>Rem Draw an expanding circle and grab it as a Bob</p>
<p>For C=1 To 15</p>
<p>Ink 5 :Circle 16,16,C: Paint 16,16</p>
<p>Get Bob C,0,0 To 32,32</p>
<p>Cls 0,0,0 To 32,32</p>
<p>Next C</p>
<p>Rem Animate new Bob image</p>
<p>Do</p>
<p>Add IMAGE,1</p>
<p>If IMAGE&gt;15 Then IMAGE=1</p>
<p>For W=0 To 4: Wait Vbl : Next W: Rem Slow down animation</p>
<p>Rem Assign next image in sequence to Bob 1</p>
<p>Bob 1,X Screen(X Mouse),Y Screen(Y Mouse),IMAGE</p>
<p>Loop</p>
<p><b>PUT BOB</b></p>
<p><i>instruction: put a fixed copy of a Bob on screen</i></p>
<p><b>Put Bob</b> number</p>
<p>The PUT BOB command takes the Bob whose number is given and fixes a permanent copy of its  </p>
<p>image on the screen, at the current position. This is achieved by preventing the background area </p>
<p>beneath the Bob from being re-drawn. Note that after the image has been copied, the original Bob can </p>
<p>be animated and moved with no ill effects.</p>
<p>In actual fact, PUT BOB is included as a support for STOS programmers, who wish to make their old </p>
<p>Atari   STOS   programs   compatible   with   AMOS   Professional.   Because   it   only   works   with   single </p>
<p>buffered screens, it is not particularly useful, and PASTE BOB is recommended as the preferred </p>
<p>command. Please see below.</p>
<p><b>PASTE BOB</b></p>
<p><i>instruction: draw an image from Object Bank</i></p>
<p><b>Paste Bob</b> x,y,image</p>
<p>PASTE BOB takes an image held in the Object Bank, and draws it straight onto the current screen. </p>
<p>Unlike the PUT BOB command, the image is drawn immediately, so there is no need to add the WAIT </p>
<p>VBL commands before proceeding.</p>
<p>It is important to note that the coordinates for the given image number are measured from the top </p>
<p>left-hand corner of the image, and take no account of the current hot spot setting!</p>
<p>07.02.08</p>
<p>B</p>
<p>O</p>
<p>B</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Blitter Objects</p>
<p>PASTE BOB is just like any other graphics instruction, so it does not need a double buffered screen. It  </p>
<p>can be used to generate a range of extremely fast graphical operations, and it is also useful for  </p>
<p>mapping complex displays in scrolling arcade games. Here is an example:</p>
<p>Flash Off : Curs Off : Cls 0</p>
<p>Rem The following Palette values go on one line</p>
<p>Palette 0,$100,$200,$300,$400,$500.$600,$700,$800,</p>
<p>$900,$A00,$B00,$000,$D00,$E00,$F00</p>
<p>Rem Create some coloured circles for images</p>
<p>For C=1 To 15</p>
<p>Ink C : Circle 16,16,15 : Paint 16,16</p>
<p>Get Bob C,0,0 To 32,32</p>
<p>Next C</p>
<p>Do</p>
<p>Rem Choose a random circle and choose its position</p>
<p>N=Rnd(14)+1 : X=Rnd(320) : Y=Rnd(200)</p>
<p>Rem Paste image on screen at new coordinates</p>
<p>Paste Bob X,Y,N</p>
<p>Loop</p>
<p><b>Bob Bank Commands</b></p>
<p><b>DEL BOB</b></p>
<p><i>instruction: delete an image from the Object Bank</i></p>
<p><b>Del Bob</b> number</p>
<p><b>Del Bob</b> first <b>To</b> last</p>
<p>The DEL BOB command permanently deletes one or more Bob images from the Object Bank. To erase </p>
<p>a single image, simply give the image number to be deleted, like this:</p>
<p>Del Bob 2</p>
<p>Whenever an image is deleted, all the subsequent images in the Bank are moved up one place in the  </p>
<p>numerical order. For instance, if the Bank originally contained four images, the above example would </p>
<p>remove image number 2 from memory, leaving a gap between images 1 and 3. This gap would be </p>
<p>filled immediately, as the old image numbers 3 and 4 were shunted up one place, to become the new </p>
<p>image numbers 2 and 3.</p>
<p>If more than one image is to be removed from the Bank, you can set the range from the first image to </p>
<p>the last after a DEL BOB command. The following example would delete Bob images 4,5,6 and 7:</p>
<p>Del Bob 4 To 7</p>
<p>After the last image has been deleted from the Object Bank, the entire Bank is erased automatically.</p>
<p>07.02.09</p>
<p>B</p>
<p>O</p>
<p>B</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Blitter Objects</p>
<p><b>INS BOB</b></p>
<p><i>instruction: insert a blank Bob image into the Object bank</i></p>
<p><b>Ins Bob</b> number</p>
<p><b>Ins Bob</b> first <b>To</b> last</p>
<p>INS BOB inserts a <b>blank</b> image at the numbered position in the current Object Bank. All of the images </p>
<p>after this numbered position will then be moved down one place in the numerical order. The second </p>
<p>version of this command allows you to create several spaces in a single operation, by giving the range </p>
<p>of new gaps between the first and last image numbers that you specify.</p>
<p>Any   of  these   new   image   spaces   are  completely   empty,   and  so   cannot   be  allocated   to   a  Bob   or </p>
<p>displayed directly on screen while they are still blank. An actual image must first be grabbed into the  </p>
<p>Object Bank, using a GET SPRITE or GET BOB command. If this is not done, the appropriate error </p>
<p>message will be given as soon as you try to access the empty image.</p>
<p>Both DEL BOB and INS BOB are provided to be used with the GET BOB and GET SPRITE commands. </p>
<p>They allow you to modify and adjust your Bob images from inside AMOS Professional programs, </p>
<p>with complete freedom. They may be used to create numerous special effects such as interactive </p>
<p>screen animations and animated brushes, as used in Deluxe Paint.</p>
<p><b>Flipping Bob Images</b></p>
<p>AMOS   Professional   is   designed   to   meet   every   programming   need   when   it   comes   to   animating </p>
<p>images. You will often need to animate mechanical objects and cartoon characters as realistically as </p>
<p>possible, so every movement sequence must be created from a number of images, and each image in  </p>
<p>the sequence must be carefully drawn using the Object Editor, ready for smooth animation with </p>
<p>AMAL.</p>
<p>Unfortunately, perfectly animated sequences need a great many images, which take up a great deal of </p>
<p>memory.  To move the animated character in several directions makes the problem much worse, </p>
<p>because each direction needs a separate sequence of images.</p>
<p>AMOS Professional cuts such waste of memory to a minimum. This is achieved by allowing you to </p>
<p>display the same image in different orientations, so that a character can be mirrored and turned </p>
<p>upside down, simply by flipping its image.</p>
<p><b>HREV</b></p>
<p><i>function: flip an image horizontally</i></p>
<p>new number=<b>Hrev</b>(image number)</p>
<p>This function reverses an image from left to right, creating a mirror image. Use HREV by specifying </p>
<p>the   existing   image   number   (in   brackets)   to   be   flipped   horizontally,   in   order   to   create   a   new </p>
<p>identification number for the reversed image. This new image number can be freely used with any of </p>
<p>the standard Bob commands.</p>
<p>07.02.10</p>
<p>B</p>
<p>O</p>
<p>B</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Blitter Objects</p>
<p>Here is an example:</p>
<p>Load “AMOSPro_Tutorial:Objects/Bobs.abk” : Rem Load Bob images from disc</p>
<p>Curs Off.: Cls 0 : Rem Set up screen</p>
<p>Flash Off : Get Bob Palette : Rem Grab Bob colours from image bank</p>
<p>Double Buffer : Rem Engage Double Buffering</p>
<p>For X=360 To -60 Step -4: Rem Move Bob across screen</p>
<p>Bob 1,X,100,2 : Rem Display Bob at a new position</p>
<p>Wait Vbl : Rem Wait for next vertical blank period</p>
<p>Next X</p>
<p>For X=-60 To 400 Step 4: Rem Flip image and move from left to right</p>
<p>Bob 1,X,100,Hrev(2) : Rem Display Bob at new position</p>
<p>Wait Vbl : Rem Wait 50th of second for Vbl</p>
<p>Next X</p>
<p>There is a hexadecimal version of this function, and the value returned by the HREV function is in the </p>
<p>following format:</p>
<p>$800+n</p>
<p>Where $8000 is a “flag” telling AMOS Professional to reverse the Bob whenever it is displayed on </p>
<p>screen, and where n is the number of your image. This technique can be used to flip images directly </p>
<p>from an AMAL animation sequence.</p>
<p>Supposing your original sequence was created with this:</p>
<p>“Anim 0,(1,2)(2,2)(3,2)(4,2)”</p>
<p>To reverse these images, either of the following two lines could be used:</p>
<p>“Anim 0,($8000+1,2)($8000+2,2)($8000+3,2)($8000+4,2)”</p>
<p>“Anim 0,($8001,2)($8002,2)($8003,2)($8004,2)”</p>
<p>When an image is reversed like this, the location of the hot spot is reversed horizontally too. So if the  </p>
<p>hot spot was originally in the top left-hand corner, the hot spot of the HREV image will be in the top </p>
<p>right-hand corner: Depending on the image involved, this can have a great effect on the way your </p>
<p>image is displayed on screen. Be careful to position your hot spots sensibly, or avoid any risks by  </p>
<p>setting them centrally, using the appropriate HOT SPOT command.</p>
<p><b>VREV</b></p>
<p><i>function: flip an image vertically</i></p>
<p>new number=<b>Vrev</b>(image number)</p>
<p>VREV is identical to HREV, except that it takes the specified image and turns it upside down before </p>
<p>displaying it on the screen. This is best used for animated objects that move vertically, although comic </p>
<p>effects can be achieved with cartoon characters.</p>
<p>07.02.11</p>
<p>B</p>
<p>O</p>
<p>B</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Blitter Objects</p>
<p>As with HREV, there is an equivalent hexadecimal version of the VREV function, which can be used </p>
<p>with AMAL animation strings. The format is:</p>
<p>$4000+n</p>
<p>Where $4000 acts as the reversal flag, and n is the image number. Here are two typical AMAL string </p>
<p>of reversed animation:</p>
<p>“Anim 0,($4000+1,2)($4000+2,2)($4000+3,2)($4000+4,2)”</p>
<p>“Anim 0,($4001,2)($4002,2)($4003,2)($4004,2)”</p>
<p><b>REV</b></p>
<p><i>function: double-flip an image vertically and horizontally</i></p>
<p>new number=<b>Rev</b>(image number)</p>
<p>REV combines HREV and VREV into a single function. It takes the image whose number is held in </p>
<p>brackets, reverses it from left to right and then performs another reversal from top to bottom. For  </p>
<p>example:</p>
<p>Load “AMOSPro Tutorial:Objects/Bobs.abk”</p>
<p>Curs Off : Cls 0</p>
<p>Flash Off : Get Bob Palette</p>
<p>Double Buffer</p>
<p>For Y=200 To -40 Step -1</p>
<p>Bob 1,Y*2,Y,1</p>
<p>Wait Vbl</p>
<p>Next Y</p>
<p>For Y=-40 To 200</p>
<p>Bob 1,Y*2,Y,Rev(1)</p>
<p>Wait Vbl</p>
<p>Next Y</p>
<p>Don't forget to try the HELP programs for a demonstration. If your own attempts at flipping Bob </p>
<p>images cause any problems, you may wish to consult the Bob Doctor, below.</p>
<p><b>The Bob Doctor</b></p>
<p>Here are some free consultations which answer common problems encountered when flipping Bobs.</p>
<p><b>Problem:</b> When I use flipped Bobs on screen with their original images, my display slows down to a </p>
<p>crawl.</p>
<p><b>Remedy:</b> Do not display the same image in different orientations on screen at the same time. AMOS </p>
<p>Professional flips images during the updating process, just before Bobs are re-drawn on screen. Once </p>
<p>reversed, images stay in this new state until displayed in a different direction. Whenever AMOS </p>
<p>Professional flips a reversed image, it first needs to restore the image to its original state. This takes a </p>
<p>great deal of processor time, and slows down your display.</p>
<p>07.02.12</p>
<p>B</p>
<p>O</p>
<p>B</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Blitter Objects</p>
<p><b>Problem:</b> Can I reverse an image for later use, without displaying it on screen?</p>
<p><b>Remedy:</b> Yes. PASTE BOB works perfectly with flipped images, and can be used directly with HREV, </p>
<p>VREV and REV. If you want to reverse an image quickly, without displaying a Bob, try something like </p>
<p>this:</p>
<p>Paste Bob 500,500,Vrev(1)</p>
<p>Since the coordinates lie outside of the current screen area, the image is not displayed, but it is still </p>
<p>flipped by the PASTE BOB command.</p>
<p><b>Problem:</b> I want to flip my Sprites as well as my Bobs?</p>
<p><b>Remedy:</b> The flip functions do not work with Sprites directly, but there is no problem in displaying a </p>
<p>flipped Bob image as a Sprite. This line would be completely ignored:</p>
<p>Sprite 8,300,100,Hrev(5)</p>
<p>But the following routine will solve your problem:</p>
<p>Load “AMOSPro_Tutorial:Objects/Sprites.abk”</p>
<p>Curs Off : Cls 0 : Flash Off : Get Sprite Palette</p>
<p>Paste Bob 50,50,Vrev(5)</p>
<p>Sprite 8,300,100,5</p>
<p>Wait Vbl</p>
<p><b>Problem:</b> Can I check for a collision between two copies of the same image, for example, between an </p>
<p>original image and its own mirror-image?</p>
<p><b>Remedy:</b> Yes, but it is not recommended. If the image's hot spot has been centred the results should </p>
<p>be acceptable, but if the hot spot is asymmetrical you will generate unpredictable problems.</p>
<p>07.02.13</p>
<p>B</p>
<p>O</p>
<p>B</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Updating objects</p>
<p>This Chapter explains the theory behind the AMOS Professional system for updating and drawing </p>
<p>moving objects. As well as a comprehensive range of commands, a completely automatic system is </p>
<p>provided for your use.</p>
<p><b>Moving multiple objects</b></p>
<p>As a default condition, AMOS Professional manages the position of each and every object on the </p>
<p>screen automatically. The moment that the coordinates of these objects change, they are re- drawn </p>
<p>almost instantly. When it comes to programming complex arcade games, that “almost instantly” can </p>
<p>cause problems!</p>
<p>The next two ready-made programs demonstrate a typical problem, first with Sprites and then with </p>
<p>Bobs. If you examine them, you will see that the objects are moving at slightly irregular times, because </p>
<p>even though AMOS Professional is updating their positions at regular intervals, it is not keeping pace </p>
<p>with the FOR ... NEXT loop.</p>
<p>To avoid wobbly Sprites and Bobs, all objects must be re-drawn at the same instant in your program, </p>
<p>and AMOS Professional provides three commands for this purpose. SPRITE UPDATE, is to be used </p>
<p>for updating Sprites, BOB UPDATE displays Blitter Objects and the UPDATE command re-draws </p>
<p>both Sprites and Bobs in the same operation.</p>
<p>Before calling any of these commands, the automatic updating system must be disengaged using the </p>
<p>relevant command, SPRITE UPDATE OFF, BOB UPDATE OFF or UPDATE OFF, as appropriate. Here </p>
<p>are two working examples to type in yourself:</p>
<p>Load “AMOSPro_Tutorial:Objects/Sprites.Abk”</p>
<p>Curs Off : Flash Off : Cls 0</p>
<p>Set Sprite Buffer 256</p>
<p>Hide On</p>
<p>Get Sprite Palette</p>
<p>Sprite Update Off</p>
<p>For X=X Hard(0) To X Hard(330)</p>
<p>For S=0 To 8</p>
<p>Sprite S+8,X,S*25+50,2</p>
<p>Next S</p>
<p>Sprite Update : Wait Vbl</p>
<p>Next X</p>
<p>Load “AMOSPro Tutorial:Objects/Bobs.Abk”</p>
<p>Curs Off : Flash Off : Cls 0</p>
<p>Double Buffer</p>
<p>Get Bob Palette</p>
<p>Bob Update Off</p>
<p>For X=0 To 330</p>
<p>For B=0 To 1</p>
<p>Bob B,X,B*90,2</p>
<p>Next B</p>
<p>Bob Update</p>
<p>Wait Vbl</p>
<p>Next X</p>
<p>07.03.01</p>
<p>U</p>
<p>P</p>
<p>D</p>
<p>A</p>
<p>T</p>
<p>I</p>
<p>N</p>
<p>G</p>
<h1 style="page-break-before:always; "></h1>
<p>Updating objects</p>
<p><b>Displaying objects over a changing background</b></p>
<p>When objects need to be displayed against a rapidly changing background picture, other problems </p>
<p>can occur. The most important thing to understand is that although they can hold the same images, </p>
<p>Sprites   and   Bobs   are   completely   different   from   one   another.   The   following   tables   set   out   these </p>
<p>differences.</p>
<p><b>Sprites</b></p>
<p>•</p>
<p>exist independently in the Amiga's memory</p>
<p>•</p>
<p>are created by the Amiga's DMA hardware</p>
<p>•</p>
<p>are stored independently from the screen, in a separate memory area</p>
<p>•</p>
<p>use hardware coordinates</p>
<p><b>Bobs</b></p>
<p>•</p>
<p>do not exist independently, their appearance on screen is all there is!</p>
<p>•</p>
<p>are created by software using the Blitter chip</p>
<p>•</p>
<p>are stored as part of the current display</p>
<p>•</p>
<p>use screen coordinates</p>
<p>This has far reaching implications for your programming, and is the crucial reason for the entire  </p>
<p>DOUBLE BUFFER system. It is the complete independence of Sprites that make them so useful.</p>
<p>AMOS Professional allows you to use Bobs with animated screens, and the next section explains how </p>
<p>screens are updated to permit this.</p>
<p><b>The update process</b></p>
<p>This explanation of the Bob movement system is very detailed. If you are not interested in the theory, </p>
<p>then the BOB CLEAR and BOB DRAW commands are explained later in this Chapter, and will be </p>
<p>enough to allow you to proceed.</p>
<p>The updating of single buffered screens will now be examined. Supposing you want to display a </p>
<p>single Blitter Object on the screen. The following steps need to be undertaken:</p>
<p>•</p>
<p>Draw up the display screen as usual.</p>
<p>•</p>
<p>Discover   the   start   position   where   the   Bob   is   going   to   be   displayed,   and   establish   the </p>
<p>background area underneath the Bob.</p>
<p>•</p>
<p>Copy this background area to a safe location in memory.</p>
<p>•</p>
<p>Display the Bob over the original graphics in the target area, using the appropriate image from </p>
<p>the Object Bank.</p>
<p>•</p>
<p>Discover the next position where the Bob is going to move.</p>
<p>•</p>
<p>Clear the Bob from its current position, by displaying the safely copied background image at </p>
<p>its original screen location.</p>
<p>•</p>
<p>Examine each Bob in turn to see if it has moved since the previous update. If so, make a copy </p>
<p>of the original screen image at the new coordinates.</p>
<p>•</p>
<p>Finally, update by re-drawing the Bob at its new screen position.</p>
<p>07.03.02</p>
<p>U</p>
<p>P</p>
<p>D</p>
<p>A</p>
<p>T</p>
<p>I</p>
<p>N</p>
<p>G</p>
<h1 style="page-break-before:always; "></h1>
<p>Updating Objects</p>
<p>If you are using double buffered screens, a separate copy of the background area is created for each of </p>
<p>the two screens. At the end of a display routine, the logical and physical screens are swapped around </p>
<p>by the system, to ensure that these two screens are perfectly synchronised. All the time that the </p>
<p>contents of an animated screen stay completely still, there can be no problems with updating a static </p>
<p>image. Unfortunately, as soon as the contents of a screen changes, the saved sections of the previous  </p>
<p>picture will be copied straight onto the updated screen, and corrupt the picture. This can only be </p>
<p>solved if all of the standard drawing commands are synchronised with both the physical and logical </p>
<p>screens, and AMOS Professional achieves this by means of the powerful AUTOBACK system.</p>
<p>AUTOBACK is extremely intelligent and completely automatic, but it can only synchronise graphics </p>
<p>and text commands. If you wish to manipulate the screen directly with SCREEN COPY or SCROLL, </p>
<p>you must handle the process yourself. In other words, you will have to keep the logical and physical </p>
<p>screens in step with one another and perform exactly the same operations in both screens.</p>
<p>This routine demonstrates the danger of flicking between these screens when different items are held </p>
<p>in the two components of double buffering:</p>
<p>Double Buffer</p>
<p>Autoback 0</p>
<p>Do</p>
<p>Paper 4 : Print “Hello from the first screen”</p>
<p>Screen Swap : Wait Vbl</p>
<p>Paper 6 : Print “Greetings from screen two”</p>
<p>Screen Swap : Wait Vbl</p>
<p>Loop</p>
<p><b>The updating commands</b></p>
<p>Under normal circumstances, AMOS Professional displays all Bobs at once. So if any Bob coordinates </p>
<p>are changed, that Bob can be expected to appear at its new position immediately.</p>
<p>Unfortunately, the Amiga's hardware is only capable of re-drawing a limited number of objects on </p>
<p>screen in any single display cycle. This means that if you try and move several Bobs at once, it is </p>
<p>almost inevitable that some of those objects will be re-positioned at slightly different times. This </p>
<p>phenomenon   generates   unpleasant   jerky   movements.   Thankfully,  AMOS   Professional   provides   a </p>
<p>simple solution to this problem.</p>
<p><b>BOB UPDATE</b></p>
<p><i>instruction: move many Bobs simultaneously</i></p>
<p><b>Bob Update</b></p>
<p><b>Bob Update Off</b></p>
<p><b>Bob Update On</b></p>
<p>BOB UPDATE performs all Bob movements in a single, mighty burst, so all objects are moved at the </p>
<p>same instant in your program. The resulting movement effects are now incredibly smooth, even with </p>
<p>dozens of objects on screen at once. BOB UPDATE is extremely easy to use, as the following technique </p>
<p>explains.</p>
<p>07.03.03</p>
<p>U</p>
<p>P</p>
<p>D</p>
<p>A</p>
<p>T</p>
<p>I</p>
<p>N</p>
<p>G</p>
<h1 style="page-break-before:always; "></h1>
<p>Updating objects</p>
<p>•</p>
<p>First, turn off the automatic system with BOB UPDATE OFF</p>
<p>•</p>
<p>Execute your main loop as normal.</p>
<p>•</p>
<p>Now call a BOB UPDATE command at the point when objects are to be drawn on screen. This </p>
<p>command automatically flips the results onto the display, using the internal equivalent of a </p>
<p>SCREEN SWAP.</p>
<p>•</p>
<p>Finally, wait for the updates to be completed, by using WAIT VBL.</p>
<p>BOB UPDATE is now used as the standard technique in the vast majority of AMOS arcade games.</p>
<p>If you need to restore the re-drawing system to its default status, BOB UPDATE ON sets the situation  </p>
<p>back to normal. One word of warning though, if you are already swapping the screens manually with </p>
<p>SCREEN SWAP, use BOB UPDATE carefully, because it will switch between the logical and physical </p>
<p>screens immediately after your Bobs have been updated. The simplest remedy for any problems this </p>
<p>may cause is to use BOB CLEAR and BOB DRAW instead. These are explained later.</p>
<p><b>SPRITE UPDATE</b></p>
<p><i>instruction: move all Sprites at once</i></p>
<p><b>Sprite Update</b></p>
<p><b>Sprite Update Off</b></p>
<p><b>Sprite Update On</b></p>
<p>You may want to remind yourself of this family of commands, which are explained in Chapter 7.1. </p>
<p>They parallel the BOB UPDATE commands, and are used in the same way.</p>
<p>You are recommended to add a WAIT VBL instruction after each SPRITE UPDATE, to make sure that </p>
<p>Sprite movements are perfectly synchronised with the existing screen display.</p>
<p><b>UPDATE</b></p>
<p><i>instruction: move all objects at once</i></p>
<p><b>Update</b></p>
<p><b>Update Off</b></p>
<p><b>Update On</b></p>
<p>The UPDATE commands are a combination of the BOB UPDATE and SPRITE UPDATE families, and </p>
<p>they are used to re-draw all objects on the screen in a single operation.</p>
<p>UPDATE OFF turns off the automatic re-drawing system, so that any Bob or Sprite commands will </p>
<p>appear to be completely ignored. In actual fact, they are still going on invisibly, in the background.</p>
<p>UPDATE displays any objects which have moved since the last update. You are recommended to add </p>
<p>a WAIT VBL instruction to ensure a smooth effect.</p>
<p>UPDATE ON returns the updating system back to the original automatic setting.</p>
<p>07.03.04</p>
<p>U</p>
<p>P</p>
<p>D</p>
<p>A</p>
<p>T</p>
<p>I</p>
<p>N</p>
<p>G</p>
<h1 style="page-break-before:always; "></h1>
<p>Updating Objects</p>
<p><b>BOB CLEAR</b></p>
<p><i>instruction: clear all Bobs from the screen</i></p>
<p><b>Bob Clear</b></p>
<p><b>BOB DRAW</b></p>
<p><i>instruction: re-draw all Bobs on screen</i></p>
<p><b>Bob Draw</b></p>
<p>This pair of commands is used to synchronise Bob updates with complex screen movements, and </p>
<p>generate superbly smooth scrolling screen effects. The technique is achieved by the following steps.</p>
<p>•</p>
<p>Remove all Bobs from the logical screen display with BOB CLEAR. Background areas are </p>
<p>copied from their invisible hiding places in memory, and the display is returned to its original </p>
<p>condition.</p>
<p>•</p>
<p>Each Bob is now examined in turn, and checked to see if it has been repositioned. If so, the </p>
<p>area beneath the new coordinates are copied invisibly, as they will be needed to return the </p>
<p>screen back to normal, when the Bob is next moved. You can now perform your drawing </p>
<p>operations as required, and move your Bobs to any point on the screen.</p>
<p>•</p>
<p>Now use BOB DRAW to re-draw any Bobs that have moved at their new screen coordinates, </p>
<p>using the appropriate image from the Object Bank.</p>
<p>Note that BOB CLEAR and BOB DRAW will only work on the current logical screen, so if DOUBLE </p>
<p>BUFFER has been activated, a SCREEN SWAP command will be needed to call the relevant display, as </p>
<p>follows:</p>
<p>Screen Swap : Wait Vbl</p>
<p>Also remember to turn off the automatic updating system completely before use. Here is the correct </p>
<p>procedure.</p>
<p>•</p>
<p>Turn off the AUTOBACK system to stop the synchronisation between your graphics and Bobs, </p>
<p>like this:</p>
<p>Autoback 0</p>
<p>•</p>
<p>Now that all graphical operations have been forced to work with the logical screen, turn off the </p>
<p>standard updating system, with BOB UPDATE OFF.</p>
<p>•</p>
<p>Next add a BOB CLEAR command at the start of your main loop. You can now draw your </p>
<p>graphics on screen, and move your objects as required.</p>
<p>•</p>
<p>Finally, re-draw your objects at their new positions using BOB DRAW.</p>
<p>07.03.05</p>
<p>U</p>
<p>P</p>
<p>D</p>
<p>A</p>
<p>T</p>
<p>I</p>
<p>N</p>
<p>G</p>
<h1 style="page-break-before:always; "></h1>
<p>Updating objects</p>
<p>If you are using double buffering, you must make sure that there is a genuine connection between the </p>
<p>logical and physical screens. To achieve smooth graphics, there must be a sensible progression from </p>
<p>screen to screen, otherwise flickering distortions will be displayed.</p>
<p>When scrolling the playing area of a computer game, it is often possible to ensure that screens are </p>
<p>already  in   step,   so   BOB  CLEAR  and   BOB  DRAW   can   be  used   without   any   problems.   In   other </p>
<p>situations, you may need to make radical changes from screen to screen, so ensure that these are </p>
<p>made both copies of the current screen.</p>
<p><b>The Autoback command</b></p>
<p>The standard Bob routines only work if the logical and physical screens are in perfect harmony. The </p>
<p>instant that text or graphics are drawn, or the SCREEN COPY command is used, the two screens fall </p>
<p>out of step with one another, ruining any smooth effects. In the case of SCREEN COPY, you must take </p>
<p>control over the system with the BOB DRAW and BOB CLEAR commands, but when using standard </p>
<p>graphics commands, the situation is much easier.</p>
<p>AMOS Professional includes a powerful feature that automatically synchronises all text and graphics </p>
<p>operations with all Bob updates. This means that once DOUBLE BUFFER is activated, graphics and </p>
<p>text can be displayed as normal. This is the principle of the AUTOBACK system.</p>
<p><b>AUTOBACK</b></p>
<p><i>instruction: set mode for graphics operations on double buffered screen</i></p>
<p><b>Autoback</b> mode</p>
<p>There are three AUTOBACK modes, and you can toggle between them by setting the mode values as </p>
<p>follows:</p>
<p>Autoback 0</p>
<p>Manual mode. This mode deactivates the AUTOBACK system completely, so that graphics are drawn </p>
<p>directly on the logical screen, for maximum speed. It is recommended for use with the BOB DRAW </p>
<p>and BOB CLEAR commands.</p>
<p><b>AUTOBACK 0</b>  is  useful  when  large amounts of graphics  are drawn  on screens  being switched </p>
<p>manually with SCREEN SWAP, because it is much faster than the standard system. But remember </p>
<p>that you must take responsibility for synchronising between the logical and physical screens.</p>
<p>Autoback 1</p>
<p><b>Semi-automatic.</b> In mode 1, AUTOBACK performs all graphical operations on both the logical and </p>
<p>physical   screens.  Although   Bob   updates   are   not   taken   into   account,   this   is   an   ideal   mode   for </p>
<p>displaying hi-score tables and control panels. So as long as your Bobs are kept clear of any new  </p>
<p>graphics, this mode is perfect.</p>
<p>Autoback 2</p>
<p>07.03.06</p>
<p>U</p>
<p>P</p>
<p>D</p>
<p>A</p>
<p>T</p>
<p>I</p>
<p>N</p>
<p>G</p>
<h1 style="page-break-before:always; "></h1>
<p>Updating Objects</p>
<p><b>Fully-automatic.</b> This setting re-activates the normal AUTOBACK system. Under mode 2, whenever </p>
<p>graphics are drawn on screen, they will be synchronised with any active Bobs automatically. All </p>
<p>worries are taken care of by the system.</p>
<p><b>Bob drawing modes</b></p>
<p>Once Bobs have been set up, you are allowed to change the way that they react with other screen  </p>
<p>graphics.</p>
<p><b>SET BOB</b></p>
<p><i>instruction: set drawing mode for Bobs</i></p>
<p><b>Set Bob</b> number,background,planes,mask</p>
<p>SET BOB is used to change the drawing mode used to display a particular Blitter Object. It is best </p>
<p>used <b>before</b> displaying a Bob on the screen. This command has several parameters, of which the first </p>
<p>is simply the number of the Bob to be affected.</p>
<p>The second parameter is a number that sets the mode of the background, in other words, the way that </p>
<p>graphics   underneath   the   Bob  are   to   be  re-drawn.   There   are  three   alternative   background   mode </p>
<p>settings. A value of <b>zero</b> automatically replaces the screen background beneath the Bob, after it moves </p>
<p>away. This is the standard drawing system, and gives a smooth animation effect when the Bob is </p>
<p>moved across the screen.</p>
<p>If   the   background   is   a  <b>positive</b>  number,   then   the   original   background   graphics   are   completely </p>
<p>forgotten when the Bob moves away, and the area beneath the Bob is replaced by a solid block of  </p>
<p>colour. The colour is calculated with this formula:</p>
<p>Colour = Background-1</p>
<p>So the following line sets the mode of Bob 1, and draws a block of graphics in colour 9 (calculated as </p>
<p>10-1) whenever the Bob is moved. Notice how commas must be included if other parameter values are </p>
<p>omitted.</p>
<p>Set Bob 1,10,,</p>
<p>Since this operation is much faster than the standard system, it is recommended for bursts of extra  </p>
<p>speed. It can be used for moving Bobs across areas such as clear blue sky, and is also extremely </p>
<p>effective when operated with the various rainbow effects.</p>
<p>The final alternative background setting is to use a negative value. This turns off the re-drawing </p>
<p>process, allowing you to fill the old background areas with any colours or patterns you like, using the </p>
<p>standard AMOS Professional graphics commands.</p>
<p>After the two parameters that set the Bob number, and the background mode, SET BOB requires a </p>
<p>parameter to establish which of the screen planes is to be used for the Bob. The planes setting is a bit-</p>
<p>map, consisting of a binary number where each digit represents one plane of the screen, and each </p>
<p>plane represents one bit of the final colour to be displayed on screen. The numbering system works </p>
<p>like this:</p>
<p>Plane:</p>
<p>543210</p>
<p>Digit:</p>
<p>%111111</p>
<p>07.03.07</p>
<p>U</p>
<p>P</p>
<p>D</p>
<p>A</p>
<p>T</p>
<p>I</p>
<p>N</p>
<p>G</p>
<h1 style="page-break-before:always; "></h1>
<p>Updating objects</p>
<p>By changing these planes, selected colours can be omitted from the Bob when it is drawn on screen. </p>
<p>For example:</p>
<p>Set Bob 1,0,$000111 : Rem Display bits drawn in colours 0 to 7</p>
<p>Set Bob 1,0,$111111 : Rem Display all bit-planes</p>
<p>The last SET BOB parameter is another bit pattern, that selects one of 255 possible Miler modes used </p>
<p>to draw Bobs on screen. This can set a mask, so that colour zero is transparent, and a full description </p>
<p>of the available modes is given at the beginning of Chapter 6.2, in the SCREEN COPY section. In fact,  </p>
<p>the mask parameter is usually set to one of two values:</p>
<p>%11100010 if no mask is to be used.</p>
<p>%11001010 if the Bob is to be used with a mask, in other words, if colour zero is to be transparent.</p>
<p>So the following line would set Bob 1 moving across the original screen colours, with a mask set:</p>
<p>Set Bob 1,0,%111111, %11001010</p>
<p>Advanced users may find the following information useful:</p>
<p><b>Blitter Source</b></p>
<p><b>Purpose</b></p>
<p>A</p>
<p>Blitter Mask</p>
<p>B</p>
<p>Blitter Object</p>
<p>C</p>
<p>Destination Screen</p>
<p>07.03.08</p>
<p>U</p>
<p>P</p>
<p>D</p>
<p>A</p>
<p>T</p>
<p>I</p>
<p>N</p>
<p>G</p>
<h1 style="page-break-before:always; "></h1>
<p>Detecting Collisions</p>
<p>In this Chapter, you will learn how to turn moving objects into truly interactive game components, by </p>
<p>giving them friendly or hostile personalities. These personalities depend on what happens when two </p>
<p>or more objects collide, and all of the classic computer games demand continual monitoring for </p>
<p>collision between moving objects. Collision detection must be instant, accurate and totally reliable, </p>
<p>otherwise games will lack excitement and playability.</p>
<p>AMOS Professional provides a comprehensive range of functions that allow perfect monitoring for </p>
<p>collisions between objects on screen: Bobs, Hardware Sprites, Computed Sprites or any combination </p>
<p>of these different types. The detection routines are sensitive to the actual shape of your objects, so all </p>
<p>results are incredibly accurate. There is not a single “classic” computer game that you cannot match in </p>
<p>terms of speed and sensitivity when it comes to detecting collisions. Here is a synopsis of the options </p>
<p>available.</p>
<p><b>Collision detection options</b></p>
<p>AMOS Professional permits effortless checking for a collision between any group of screen objects, by </p>
<p>means of four powerful functions. Each function uses the same principle, which takes a single source </p>
<p>object and then searches for collisions between that object and one or more targets. If the test is </p>
<p>successful and a collision is detected, a value of -1 is returned, meaning True. On the other hand, if </p>
<p>there is no collision, a value of 0 is given, meaning False.</p>
<p>As a default, the collision functions will test all relevant active objects for collision with the single </p>
<p>object that you are interested in, but if you want to restrict your test to a selection of active objects, </p>
<p>each function can be qualified with an optional setting for the range of targets. This range is set by </p>
<p>specifying the number of the first object in the range to the number of the last target object you are  </p>
<p>interested in.</p>
<p>Here is a list of the four available collision tests:</p>
<p>BOB COL monitors for collisions between Bobs.</p>
<p>SPRITE COL monitors for collisions between Sprites.</p>
<p>SPRITEBOB COL checks a single Sprite for collisions with Bobs.</p>
<p>BOBSPRITE COL tests a single Bob for collisions with Sprites.</p>
<p>After a collision has been detected by one of those tests, you can make an immediate check for the </p>
<p>other objects involved, using a collision function named COL, which is used like this:</p>
<p>collision=Col(number)</p>
<p>where the number relates to one of the objects being checked.</p>
<p>Most of these options are also available in the built-in AMAL animation system, to which Chapter 7.6 </p>
<p>is devoted.</p>
<p><b>Types of collisions</b></p>
<p>There are three general categories of collision which can occur in a computer gam:</p>
<p>•</p>
<p><b>One-to-one.</b> This is the simplest case where there are only two objects on the screen, such as a </p>
<p>bat and a ball.</p>
<p>•</p>
<p><b>One-to-many.</b>  Normally  the  player   will  have  control  of  one  object  which  is  suffering  the </p>
<p>unwanted attentions of a whole host of hostile harassers.</p>
<p>•</p>
<p><b>Many-to-many.</b>  In more complex arcade games, each hostile object must be </p>
<p>checked for collision with an entire armoury of user-controlled objects.</p>
<p>07.04.01</p>
<p>C</p>
<p>O</p>
<p>L</p>
<p>L</p>
<p>I</p>
<p>S</p>
<p>I</p>
<p>O</p>
<p>N</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Detecting Collisions</p>
<p>Before a detailed explanation of the collision functions, it is worth examining AMOS Professional in </p>
<p>action with a ready-made program. This will demonstrate how collisions are handled.</p>
<p>Please load the following tutorial:</p>
<p>Load “AMOSPro Tutorial:Tutorials/Collision_Detection.AMOS”</p>
<p>Now run the program and select Example 1. This shows how a simple bat and ball are made to </p>
<p>interact, and to simplify things, the bat has been fixed in position! The collision detection in this </p>
<p>example relies on the following line:</p>
<p>If Bob Col(1) Then Boom</p>
<p>Notice how the explosion effect is triggered the instant that the bat overlaps the ball, even by the </p>
<p>smallest margin. Example 2 really sets the ball rolling!</p>
<p>The same instruction can also be used to detect collisions between a single source and any number of </p>
<p>target objects, with the BOB COL function checking all of the Bobs automatically in Example 3.</p>
<p>To refine the system, and check for collisions with a smaller range of objects, simply add the first and </p>
<p>last numbers of that range to the BOBSPRITE COL command, in the demonstration program. For </p>
<p>example, changing the relevant line as follows will test for one red and one green ball only:</p>
<p>If Bobsprite 001(1,2 To 4) Then Bell 10</p>
<p><b>Masks</b></p>
<p>Invisible  “masks”  are created around  images  for  two  main  reasons.  Firstly they ensure  that  the </p>
<p>background colour (zero) is transparent, so a masked Bob will merge with the current screen display. </p>
<p>The second reason for masking an image is to provide AMOS Professional with a mechanism for </p>
<p>detecting collisions. The collision detection functions will only work if a mask has first been created  </p>
<p>around the required images.</p>
<p>Masks are automatically defined around an image when that image is assigned to a Blitter Object, in </p>
<p>other words, when the BOB command is used. But it is important to remember that Sprites have no </p>
<p>masks unless you specifically attach them. So if you intend to make use of collision detection, it is  </p>
<p>vital to ensure that all your objects are wearing their masks.</p>
<p><b>MAKE MASK</b></p>
<p><i>instruction: mask an image for collision detection</i></p>
<p><b>Make Mask</b></p>
<p><b>Make Mask</b> number</p>
<p>This command creates a mask around every one of the images in the Object Bank, and may take a  </p>
<p>little time, depending on the number of objects involved. If an optional number is given, then a mask </p>
<p>is created for that specified image only.</p>
<p>07.04.02</p>
<p>C</p>
<p>O</p>
<p>L</p>
<p>L</p>
<p>I</p>
<p>S</p>
<p>I</p>
<p>O</p>
<p>N</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Detecting Collisions</p>
<p><b>The collision functions</b></p>
<p><b>BOB COL</b></p>
<p><i>function: detect for collision between Blitter Objects</i></p>
<p>c=<b>Bob Col</b>(number)</p>
<p>c=<b>Bob Col</b>(number, <i>first <b>To</b> last</i>)</p>
<p>The BOB COL function checks the screen for collisions between Blitter Objects. It is invaluable in the </p>
<p>type of arcade games that rely on hitting or avoiding moving objects. To test for a collision with BOB  </p>
<p>COL, simply specify the number of the Bob you are interested in (in brackets) and a value of -1 (true) </p>
<p>will be returned if a collision occurs. Otherwise zero (false) is generated.</p>
<p>Note that the AMOS Professional collision system uses “masks”, and so it is sensitive to the physical </p>
<p>shape of your objects. This means that when different objects have extremely varied appearances, the </p>
<p>collision will only be detected when the objects happen to overlap on screen.</p>
<p>Normally, BOB COL will check for collisions between the specified Bob and any other Blitter Object, </p>
<p>but   you   can   also   monitor   the   movements   of   a   particular   range   of   Bobs   using   this  As   optional </p>
<p>parameters, after the specified Bob number, you may set the range of Bobs to be checked for collision </p>
<p>from the first to the last in your Bob list.</p>
<p>BOB COL is very similar to the BC function used by the AMAL animation system. AMAL is detailed </p>
<p>at the end of this section, in Chapter 7.6. For a rapid status test of an individual Bob, after a collision  </p>
<p>detection routine, the COL function can be used to determine precisely which pair of objects have </p>
<p>collided amongst a whole range of similar objects. The COL function is explained later.</p>
<p><b>SPRITE COL</b></p>
<p><i>function: test for collision between Sprites</i></p>
<p>c=<b>Sprite Col</b>(number)</p>
<p>c=<b>Sprite Col</b>(number,<i>start <b>To</b> finish</i>)</p>
<p>SPRITE COL provides an easy method of checking to see if two or more Sprites have collided on </p>
<p>screen. If the test is successful, SPRITE COL returns a value of -1 (true), and if not 0 (false) is returned  </p>
<p>instead. As you would expect, the brackets contain the number of any active Sprite on screen. This can </p>
<p>be a standard Amiga hardware Sprite, or an AMOS Professional computed Sprite, but the image it </p>
<p>displays <b>must</b> carry a mask. As a default, masks are created for Bobs only, so you must deliberately </p>
<p>create a mask for each Sprite image at the start of your program, using MAKE MASK.</p>
<p>If you want to check for a selected group of Sprites, include the optional first to last parameters to set  </p>
<p>the range of the Sprite numbers you are interested in.</p>
<p>Note that any mixture of hardware Sprites and computed Sprites can be tested in the same SPRITE </p>
<p>COL instruction. Also that the equivalent AMAL function is SC.</p>
<p>07.04.03</p>
<p>C</p>
<p>O</p>
<p>L</p>
<p>L</p>
<p>I</p>
<p>S</p>
<p>I</p>
<p>O</p>
<p>N</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Detecting Collisions</p>
<p><b>SPRITEBOB COL</b></p>
<p><i>function: test for collision between one Sprite and range of Bobs</i></p>
<p>c=<b>Spritebob Col</b>(number)</p>
<p>c=<b>Spritebob Col</b>(number,<i>start <b>To</b> finish</i>)</p>
<p>As its name suggests, this function checks for a collision between the Sprite whose number you </p>
<p>specify, and one or more Blitter Objects. If the Sprite collides with a Bob, a value of -1 (true) is </p>
<p>returned, otherwise 0 (false) is given.</p>
<p>This function will test for collisions with all Bobs on screen, but the checking process can be restricted </p>
<p>with the optional setting of the range of Bobs to be monitored, from the first Bob number to the last in </p>
<p>the range. If you need to test for collisions between several Sprites and Bobs, the command should be </p>
<p>enclosed in a loop, like this:</p>
<p>For FIRSTSPRITE=1 To LASTSPRITE</p>
<p>If Spritebob Col(FIRSTSPRITE,FIRSTBOB To LASTBOB) Then Boom</p>
<p>Next FIRSTSPRITE</p>
<p>Remember that all specified Sprites must be assigned to a <b>masked</b> image, before collision detection </p>
<p>can work. You are also warned that this function will only work with  <b>low resolution</b>  screens, and </p>
<p>attempts to use it in high resolution will lead to unpredictable results. This is because your Sprites </p>
<p>and Bobs are likely to have different sized screen points.</p>
<p><b>BOBSPRITE COL</b></p>
<p><i>function: test for collision between one Bob and range of Sprites</i></p>
<p>c=<b>Bobsprite Col</b>(number)</p>
<p>c=<b>Bobsprite Col</b>(number,<i>first <b>To</b> last</i>)</p>
<p>This function checks for a collision between the single Bob whose number you specify, and all active </p>
<p>Sprites on screen. The result will be -1 (true) is a collision is detected, or 0 (false) if the object remains  </p>
<p>untouched. To narrow the range of Sprites to be monitored, simply include the first to the last number  </p>
<p>in that range. As with SPRITEBOB COL, this function should only be used in low resolution.</p>
<p><b>COL</b></p>
<p><i>function: test status of an object after collision detection</i></p>
<p>status=<b>Col</b>(number)</p>
<p>One obvious problem with all of the previous detection functions is that they only report on whether  </p>
<p>an individual object has been hit. To discover information about any other objects involved in a </p>
<p>collision, the COL function is used. This means that each object can be tested on its own, to see if it  </p>
<p>has collided with the source object.</p>
<p>Give   the   number   of   the   object   you   wish   to   test,   either   a   Bob   or   a   Sprite,   depending   on   the </p>
<p>circumstances, and its status will be reported with a value of -1 (true) if it has collided, or 0 (false) if it  </p>
<p>remains untouched.</p>
<p>07.04.04</p>
<p>C</p>
<p>O</p>
<p>L</p>
<p>L</p>
<p>I</p>
<p>S</p>
<p>I</p>
<p>O</p>
<p>N</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Detecting Collisions</p>
<p>Supposing you are testing Bob 1 for a collision between Bobs 2,3 and 4. The initial test could look like </p>
<p>this:</p>
<p>C=Bob Col(1,2 To 4)</p>
<p>Alter the collision has been detected, you can check on the other objects using the COL I unction, as </p>
<p>follows:</p>
<p>For B=2 To 4</p>
<p>If Col(B) Then Print “You have hit Bob number ”;B</p>
<p>Next B</p>
<p>A faster version of this function allows instant monitoring for the second object in the collision, like  </p>
<p>this:</p>
<p>object=Col(-1)</p>
<p>This returns the number of the object which has collided with your target, or a zero if no collision has </p>
<p>happened. So the alternative version to the last example is:</p>
<p>C=Bob Col(1,2 To 4)</p>
<p>Print “You have hit Bob number ”;Col(-1)</p>
<p>The AMAL equivalent of this function is C, and both are perfect for detecting collisions between </p>
<p>individual “hostiles” and “friendlies”. You simply check for a collision between each object with a </p>
<p>BOB COL or SPRITE COL, then grab the number of the collision object with the COL function.</p>
<p><b>SET HARDCOL</b></p>
<p><i>instruction: set hardware register for hardware Sprite collision detection</i></p>
<p>Set <b>Hardcol</b> bitmap1 ,bitmap2</p>
<p>This   command   is   available   to   experienced  Amiga   programmers,   and   it   permits   Sprite   collision </p>
<p>detection using the computer's hardware. SET HARDCOL cannot be used with computed Sprites, so </p>
<p>only Sprites zero to 7 may be monitored for collision.</p>
<p>The CLXCON register is set for hardware Sprite collision detection using two parameters. Bitmap1 is </p>
<p>an   enabler,   that   sets   bits   12,13,14   and   15   of   the   CLXON   register,   and   bitmap2   determines   the </p>
<p>comparison   itself,   setting   bits   zero   to   5.   Please   refer   to   your   hardware   manual   for   a   technical </p>
<p>explanation of this register.</p>
<p><b>HARDCOL</b></p>
<p><i>function: return collision status after a Set Hardcol instruction</i></p>
<p>c=<b>Hardcol</b></p>
<p>Once the hardware register has been set with a SET HARDCOL command, the HARDCOL function </p>
<p>can be used to read the system register CLXDAT, returning zero (False) if there is no collision, or -1 </p>
<p>(True) if a collision is detected. The COL function can then be used to return the identification number </p>
<p>of the colliding Sprite.</p>
<p>07.04.05</p>
<p>C</p>
<p>O</p>
<p>L</p>
<p>L</p>
<p>I</p>
<p>S</p>
<p>I</p>
<p>O</p>
<p>N</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Detecting Collisions</p>
<p><b>Collisions with rectangular blocks</b></p>
<p>The last part of this Chapter explains how rapid checks can be made to see if an Object has entered a  </p>
<p>rectangular area of the screen. These screen “zones” can be used for collision detection in computer  </p>
<p>games, as well as for setting up buttons, control panels and dialogue boxes.</p>
<p><b>RESERVE ZONE</b></p>
<p><i>instruction: RESERVE memory for a detection zone</i></p>
<p><b>Reserve Zone</b></p>
<p><b>Reserve Zone </b>number</p>
<p>The RESERVE ZONE instruction must be used to allocate enough memory for the exact number of </p>
<p>zones required, before a SET ZONE command is given. There is no limit to the number that can be </p>
<p>specified, apart from the amount of available memory.</p>
<p>To erase all current zone definitions and restore the allocated memory to the main program, simply </p>
<p>give the RESERVE ZONE command without any number parameter.</p>
<p><b>SET ZONE</b></p>
<p><i>instruction: set a screen zone for testing</i></p>
<p><b>Set Zone</b> number,x1,y1 <b>To</b> x2,y2</p>
<p>After memory has been allocated with the RESERVE ZONE command, SET ZONE is used to define a </p>
<p>rectangular area of the screen which can be tested by the various ZONE functions. The command is </p>
<p>followed by the number of the new zone, followed by its coordinates from top left to bottom right-</p>
<p>hand corner.</p>
<p><b>ZONE</b></p>
<p><i>function: return the zone number under specified screen coordinates</i></p>
<p>number=<b>Zone</b>(x,y)</p>
<p>number=<b>Zone</b>(<i>screen number</i>,x,y)</p>
<p>The ZONE function is used to give the number of the screen zone at the specified screen coordinates </p>
<p>x,y. These coordinates are normally relative to the current screen, but an optional screen number can </p>
<p>be included before the coordinates.</p>
<p>After the ZONE function has been called, the number of the <b>first</b> zone at these coordinates will be </p>
<p>returned, or a value of zero (False) will be given if no zone is detected.</p>
<p>This function can be used with the X BOB and Y BOB functions to detect whether or not a Bob has </p>
<p>entered a specific screen zone, as follows:</p>
<p>N=Zone(X Bob(n),Y Bob(n))</p>
<p>07.04.06</p>
<p>C</p>
<p>O</p>
<p>L</p>
<p>L</p>
<p>I</p>
<p>S</p>
<p>I</p>
<p>O</p>
<p>N</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Detecting Collisions</p>
<p><b>HZONE</b></p>
<p><i>function: return the zone number under the specified hardware coordinates</i></p>
<p>number=<b>Hzone</b>(x,y)</p>
<p>number=<b>Hzone</b>(<i>screen number</i>,x,y)</p>
<p>The HZONE function is identical to ZONE, except for the fact that the position on screen is measured </p>
<p>in  <b>hardware</b>  coordinates.  This  means  that  this  function  can  be  used to  detect  the presence  of  a </p>
<p>hardware Sprite in one of the screen zones, in this format:</p>
<p>N=Hzone(X Sprite(n),Y Sprite(n))</p>
<p><b>MOUSE ZONE</b></p>
<p><i>function: test if mouse pointer has entered a zone</i></p>
<p>number=<b>Mouse Zone</b></p>
<p>This is a short reminder that the MOUSE ZONE function is used to check whether the mouse pointer </p>
<p>has entered a zone, as outlined in Chapter 5.8.</p>
<p><b>RESET ZONE</b></p>
<p><i>instruction: erase screen zone</i></p>
<p><b>Reset Zone</b></p>
<p><b>Reset Zone <i></b>number</i></p>
<p>This command is used to nullify a zone created by the SET ZONE instruction. On its own, RESET </p>
<p>ZONE permanently de-activates all zone settings, but if it is qualified by a zone number, only that </p>
<p>zone will be erased. The RESET ZONE instruction does not return the memory allocated by RESERVE </p>
<p>ZONE to the main program.</p>
<p>07.04.07</p>
<p>C</p>
<p>O</p>
<p>L</p>
<p>L</p>
<p>I</p>
<p>S</p>
<p>I</p>
<p>O</p>
<p>N</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p><b>Page left blank intentionally.</b></p>
<p>07.04.08</p>
<h1 style="page-break-before:always; "></h1>
<p>IFF Animation</p>
<p>This Chapter explains how AMOS Professional is capable of taking data saved in Interchangeable File </p>
<p>Format (IFF), and transforming it into superb animations. Old hands and less experienced AMOS </p>
<p>users alike will discover a new potential for exploiting programming kills.</p>
<p>IFF graphics have already been discussed as sources for screen pictures and Bob images, and you </p>
<p>should be familiar with the LOAD IFF and SAVE IFF commands in the relevant Screens and Bobs </p>
<p>Chapters. Here is a brief reminder:</p>
<p><b>LOAD IFF</b></p>
<p><i>instruction: load an IFF screen from a disc</i></p>
<p><b>Load IFF</b> “filename”</p>
<p><b>Load IFF</b> “filename”,any <i>screen number</i></p>
<p>Flash Off</p>
<p>Load Iff “AMOSPro Examples:Logo.Iff”</p>
<p><b>SAVE IFF</b></p>
<p><i>instruction: save an IFF screen</i></p>
<p><b>Save Iff</b> “filename”</p>
<p><b>Save Iff</b> “filename”, <i>compression flag</i></p>
<p>Save Iff “My Programs:Iff/Picture_Name.Iff” : Rem Compressed</p>
<p>Save Iff “My_Programs:Iff/Picture_Name.Iff”,0 : Rem Uncompressed</p>
<p>Remember   that   the   saved   IFF   data   includes   any   pre-sets   such   as   SCREEN   DISPLAY,   SCREEN </p>
<p>OFFSET, SCREEN HIDE and SCREEN SHOW.</p>
<p><b>Optimising IFF animation</b></p>
<p>It is perfectly possible to create high definition “true video” animation on your Amiga with AMOS  </p>
<p>Professional. Unfortunately, you are normally restricted by available memory. Smooth animations </p>
<p>need to display at least 24 “frames” (separate still pictures) every second, and every 16-colour, full-</p>
<p>screen picture requires about 32k of storage space. This means that you would need to invest in a lot </p>
<p>of expensive memory storage to run a few seconds of animation, or the memory of an unexpanded </p>
<p>Amiga would be exhausted within two seconds! One solution is to use tiny images, reduce the </p>
<p>number of colours and compact these images using the SPACK command, but the AMOS Professional </p>
<p>programmer deserves better than that.</p>
<p>Adapting the “delta-encoding” technique from the latest video research, AMOS Professional is able to </p>
<p>optimise IFF data, concentrating on those parts of the image that actually appear to “move”, and </p>
<p>disregarding the much larger area of the screen that remains more or less the same. So instead of </p>
<p>needing to store a long sequence of complete images, only the differences between one image and the </p>
<p>next are recorded. This only requires a fraction of the conventional storage space and as a bonus it  </p>
<p>means that data can be unpacked extremely quickly.</p>
<p>07.05.01</p>
<p>I</p>
<p>F</p>
<p>F</p>
<p> </p>
<p>A</p>
<p>N</p>
<p>I</p>
<p>M</p>
<h1 style="page-break-before:always; "></h1>
<p>IFF Animation</p>
<p><b>An overview of IFF animation</b></p>
<p>AMOS   Professional   IFF   animation   files   are   divided   into   a   number   of   separate   components,   the </p>
<p>“frames” of your animation sequence. A frame may be either a normal screen or one image in the </p>
<p>sequence, but it is important to understand that the first frame sets up the background reference </p>
<p>image for the entire animation, and this first frame is a standard IFF picture. All of the following </p>
<p>frames are  then  stored using the delta-encoding system,  to be saved  as  a  list  of  the  differences </p>
<p>between the new image and the current display.</p>
<p>AMOS Professional offers several alternative methods of exploiting your animations, which may be </p>
<p>displayed as an entire sequential video in a single operation, or played in any combination of frames, </p>
<p>providing the sequence runs forwards. Maximum use is made of the double buffering system, to </p>
<p>ensure smooth screen displays, although you are free to ignore this feature and summon up some </p>
<p>flickering screen effects.</p>
<p>IFF   animation   can   be   used   directly   with   most   other   AMOS   Professional   graphics   commands, </p>
<p>including SCREEN COPY and SCROLL, and you can experiment with any area that is not being  </p>
<p>currently animated. Obviously, if you try to draw over the area of the animation, the display will  </p>
<p>become corrupted. It should also be noted that IFF animation is <b>not</b> compatible with the standard Bob </p>
<p>routines. When using Bobs, it is safe to hide the IFF animation on an invisible background screen and </p>
<p>copy the results to the main display. Please see Chapter 7.3 for an explanation of updating objects. Of </p>
<p>course, the easiest solution is to bypass the problem entirely and use sprites instead of Bobs!</p>
<p>It is important to remember that IFF animations can only be played <b>forwards</b>. Never attempt to run </p>
<p>your frames in reverse order. A special function is provided for skipping over any frames you want to </p>
<p>miss out.</p>
<p>You should be aware that even with delta-encoding, large, colourful and lengthy animations will still </p>
<p>consume huge amounts of memory, but AMOS Professional can release this memory ready for re-use, </p>
<p>as you are about to discover.</p>
<p><b>Creating an IFF animation</b></p>
<p>Many hours can be spent in the creative art of designing home-grown IFF pictures, and adapting </p>
<p>them for animation sequences. On the other hand, you can cheat! If a video digitiser is beyond your </p>
<p>budget there are plenty of public domain images to be found, but the most flexible method is to use </p>
<p>commercial packages like Deluxe Paint. III or IV. AMOS Professional uses “compressed” (Mode 5) </p>
<p>animations, which should be selected from the menu of a commercially available drawing package. </p>
<p>Deluxe Paint uses this mode as a default, allowing you to draw your frames one by one on the screen,  </p>
<p>and then generate the necessary ANIM files automatically. Deluxe Paint users can produce animations </p>
<p>using the following procedure:</p>
<p>•</p>
<p>Draw the background picture for Frame 1 of the animation sequence, which can be as complex </p>
<p>as you wish, as it will only be stored once in the animation file.</p>
<p>•</p>
<p>Select [Add Frame] from the [Frames] option on the main [Anim] menu. A new frame will be</p>
<p>07.05.02</p>
<p>I</p>
<p>F</p>
<p>F</p>
<p> </p>
<p>A</p>
<p>N</p>
<p>I</p>
<p>M</p>
<h1 style="page-break-before:always; "></h1>
<p>IFF Animation</p>
<p>created, containing an exact copy of your background picture. There will now be two </p>
<p>numbers on screen indicating the number of the frame being currently edited, and </p>
<p>the total number of frames in your  animation sequence. Because the background </p>
<p>picture for your animations is two led as frame number one, the editing process will </p>
<p>start with frame number two.</p>
<p>•</p>
<p>Modify your picture using Any of the Deluxe Paint drawing commands, and when you are </p>
<p>satisfied simply move on to the next frame by triggering [Add Frame] again.</p>
<p>•</p>
<p>Repeat this process of modifying the last frame and then adding the next frame, for as long as </p>
<p>required.   You   can   check   the   progress   of   your   animated   sequence   by   going   to   the </p>
<p>[Anim/Control] menu and clicking on [Play]. Press any key to exit from the animation.</p>
<p>•</p>
<p>Finally, save your animation sequence onto disc with the [Save] option from the [Anim] menu. </p>
<p>This animation can now be loaded directly into AMOS Professional Basic, and animated with </p>
<p>the first command listed below.</p>
<p><b>Playing an IFF animation</b></p>
<p><b>IFF ANIM</b></p>
<p><i>instruction: play an animation file</i></p>
<p><b>Iff Anim</b> “filename” <b>To</b> screen number</p>
<p><b>Iff Anim</b> “filename” <b>To</b> screen number, <i>times</i></p>
<p>This   function   provides   the   most   straightforward   way   of   displaying   a   complete   IFF   animation </p>
<p>sequence   directly   on   screen.   The   “filename”   must   refer   to   a   valid   IFF   animation   saved   in </p>
<p>“compressed” (Mode 5) format. The screen number defines the screen to be created for the animation </p>
<p>sequence. If the requested screen number already exists, it will be replaced by the new definition </p>
<p>automatically. There is an optional parameter to set the number of times the animated sequence is to </p>
<p>be played. If this number is omitted, the animation will be played once.</p>
<p>Remember that frame number 1 is the background screen that serves as the basis for the entire  </p>
<p>sequence, so that your animation will always re-start from frame number 2.</p>
<p>After   the   animation   has   been   played   the   requested   number   of   times   it   will   stop.   The   memory </p>
<p>consumed will automatically be released back to AMOS Professional for re-use.</p>
<p>If you have a disc containing an IFF animation file, place it into any drive and call up the standard file </p>
<p>selector, like this:</p>
<p>Iff Anim Fsel$(“**”) To 0,10</p>
<p>When the file is requested, your animation sequence will be loaded into screen 0 and cycled through </p>
<p>ten times.</p>
<p><b>Direct IFF animation</b></p>
<p>Because   the   standard  AMOS   Professional   drawing   commands   may   be   used   with   IFF </p>
<p>animations,   you   are   provided   with   a   range   of   functions   for   loading   and </p>
<p>manipulating animated sequences directly in your programs.</p>
<p>07.05.03</p>
<p>I</p>
<p>F</p>
<p>F</p>
<p> </p>
<p>A</p>
<p>N</p>
<p>I</p>
<p>M</p>
<h1 style="page-break-before:always; "></h1>
<p>IFF Animation</p>
<p><b>FRAME LOAD</b></p>
<p><i>function: load frames into memory</i></p>
<p>frames=<b>Frame Load</b>(channel To bank/address)</p>
<p>frames=<b>Frame Load</b>(channel To bank/address,number of frames)</p>
<p>Use this function to load one or more IFF frames directly into memory. The parameters in brackets are </p>
<p>as follows:</p>
<p>The channel number is the number of an animation file that is currently opened using the OPEN IN </p>
<p>command.</p>
<p>Next, specify the memory address or bank number where the frames are to be stored. If an address is </p>
<p>specified,   the   entire   file   will   be   loaded   into   the   chosen   memory   area,   exactly   like   a   BLOAD  </p>
<p>instruction. If you give a bank number, a new memory bank will be reserved automatically. It will </p>
<p>hold your animation frames and be a permanent data bank in fast memory, called “IFF”. Please note </p>
<p>that bank numbers can range from 1 to 65535. To avoid overrunning your memory area and crashing </p>
<p>the system, it is vital that enough space is reserved to hold the entire animation sequence in memory.  </p>
<p>The actual storage requirements may be calculated with the FRAME LENGTH function, which is </p>
<p>explained later.</p>
<p>Finally, there is an optional parameter that specifies the number of animation frames to be loaded. If </p>
<p>this number is omitted, only Frame 1 will be loaded, but if your request is greater than the total </p>
<p>number of available frames, all of the images will be grabbed in the current file, if memory allows. </p>
<p>This can be exploited to load entire sequences no matter what their length, by setting this optional </p>
<p>parameter to an over-large number, as no error will be generated.</p>
<p>FRAME LOAD returns the number of frames that have been successfully loaded into memory. This </p>
<p>value may be saved into a variable once the animation has been loaded, and made use of when the </p>
<p>sequence is to be played. For example:</p>
<p>Rem Open animation file for reading</p>
<p>Open In 1,“AMOSPro_Tutorial:Iff_Anim/AMOS.Anim”</p>
<p>Rem Load all frames in current file</p>
<p>Rem use over-large value of 1000 to grab all available images to bank 10</p>
<p>N=Frame Load (1 To 10,1000)</p>
<p>Close</p>
<p>Rem N now holds the number of actual frames</p>
<p>Print “Number of frames in this file is ”;N</p>
<p><b>FRAME LENGTH</b></p>
<p><i>function: return the length of frames in bytes</i></p>
<p>size=<b>Frame Length</b>(channel)</p>
<p>size=<b>Frame Length</b>(channel,<i>number of frames</i>)</p>
<p>This function is used to calculate the precise amount of memory needed to hold the selected frames of </p>
<p>an IFF animation file. To find the exact size of the required data area with FRAME LENGTH, simply </p>
<p>give the channel number of the IFF file previously opened with the OPEN IN command.</p>
<p>07.05.04</p>
<p>I</p>
<p>F</p>
<p>F</p>
<p> </p>
<p>A</p>
<p>N</p>
<p>I</p>
<p>M</p>
<h1 style="page-break-before:always; "></h1>
<p>IFF Animation</p>
<p>You may also specify the number of frames to be taken into consideration. If this number is omitted, </p>
<p>only  the first  frame  in the animation with be checked.  Alternatively,  if an  over-large  number  is </p>
<p>specified, the exact memory requirements of all the frames in the current file will be returned.</p>
<p>FRAME LENGTH does not change the position of the file pointer, but leaves it at the start of the next </p>
<p>animation frame to be loaded. So it can be used immediately before a FRAME LOAD command to </p>
<p>check the memory requirement of your new animation. For example:</p>
<p>Open In 1,“AMOSPro_Tutorial:Iff_Anim/AMOS.Anim”</p>
<p>Rem Load first frame only into memory</p>
<p>L=Frame Length(1)</p>
<p>Rem Reserve space for the frame in Bank 10</p>
<p>Reserve As Work 10,L</p>
<p>N=Frame Load(1 To 10)</p>
<p>Close</p>
<p>Print “Required memory for frame 1=”;L</p>
<p><b>FRAME PLAY</b></p>
<p><i>function: play frames on screen</i></p>
<p>frame=<b>Frame Play</b>(bank/address,number)</p>
<p>frame=<b>Frame Play</b>(bank/address,number,<i>screen</i>)</p>
<p>Use this function to display animations on screen at the appropriate points in your programs. Specify </p>
<p>the memory address or bank number containing an IFF animation sequence that has already been </p>
<p>loaded by FRAME LOAD. Please note that addresses must be <b>even</b> and that the first bytes must be a </p>
<p>valid IFF Frame definition. Next specify the number of frames that you want to play.</p>
<p>The optional screen parameter is the identifier of a new screen to be created for the animation, and it </p>
<p>can be used to automatically define a screen as the first frame of the animation to be displayed. If this </p>
<p>screen number is omitted, an attempt will be made to use the current screen.</p>
<p>Please note that your new screen will not be set up for double buffering, and you should activate this  </p>
<p>directly   from   your   program   with   the   DOUBLE   BUFFER   command,   if   required.   Also,   the   IFF </p>
<p>animation will be displayed on the logical screen, and when using double buffering SCREEN SWAP </p>
<p>must be employed, otherwise the animation will run invisibly in the background!</p>
<p>Once the FRAME PLAY function has been called, the start address of the next frame in the sequence </p>
<p>will be returned, and this address can be used to display the following frame of the animation.</p>
<p>07.05.05</p>
<p>I</p>
<p>F</p>
<p>F</p>
<p> </p>
<p>A</p>
<p>N</p>
<p>I</p>
<p>M</p>
<h1 style="page-break-before:always; "></h1>
<p>IFF Animation</p>
<p>For example:</p>
<p>Rem Play the first frame in Bank 10 using screen 0</p>
<p>F=Frame Play(10,1,0)</p>
<p>Double Buffer : Rem activate non automatic double buffer</p>
<p>Rem Display next frame</p>
<p>F=Frame Play(F,1)</p>
<p>When the end of the animation sequence has been reached, your F variable points to the last frame of </p>
<p>the   animation.   Because   the   exact   number   of  frames   is   returned   to   the   FRAME   LOAD   function, </p>
<p>FRAME PLAY can be enclosed in a loop for simplicity, like this:</p>
<p>Open In 1,“AMOSPro_Tutorialiff_Anim/AMOS.Anim”</p>
<p>L=Frame Load(1 To 10,1000)</p>
<p>Close</p>
<p>Rem Play first frame from Bank 0 and define new screen 0</p>
<p>Do</p>
<p>P=Frame Play(10,1,0)</p>
<p>Double Buffer</p>
<p>For X=2 To L-1 : Rem Play sequence to the end</p>
<p>P=Frame Play(P,1) : Rem Play next frame</p>
<p>Screen Swap : Rem Make animation visible</p>
<p>Wait Vbl : Wait Vbl : Wait Vbl</p>
<p>Next X</p>
<p>Loop</p>
<p><b>FRAME SKIP</b></p>
<p><i>function: skip past an animation frame</i></p>
<p>s=<b>Frame Skip</b>(bank/address)</p>
<p>s=<b>Frame Skip</b>(bank/address,<i>number</i>)</p>
<p>This is exactly the same as FRAME PLAY, except that no output is made to the screen. FRAME SKIP </p>
<p>omits any selected frames and returns the address of the next frame to be played in the sequence. The </p>
<p>bank or address number of a valid IFF animation frame is given, followed by the number of frames to </p>
<p>be skipped over.</p>
<p>Use FRAME SKIP carefully, because frames are stored relative to the existing screen background. This </p>
<p>means that the animation will only re-commence when an identical frame is reached to the one </p>
<p>currently being displayed.</p>
<p><b>FRAME PARAM</b></p>
<p><i>function: return a parameter after playing a frame</i></p>
<p>p=<b>Frame Param</b></p>
<p>This function returns the amount of time needed to successfully display an animation on screen, </p>
<p>measured in 50ths of a second. It is used after FRAME PLAY or FRAME SKIP to delay the program  </p>
<p>until the screen has been totally re-drawn.</p>
<p>07.05.06</p>
<p>I</p>
<p>F</p>
<p>F</p>
<p> </p>
<p>A</p>
<p>N</p>
<p>I</p>
<p>M</p>
<h1 style="page-break-before:always; "></h1>
<p>IFF Animation</p>
<p>Deluxe Paint users may need to slow down the speed of AMOS Professional animations by one </p>
<p>fiftieth of a second, in order to harmonise the display, like this:</p>
<p>Wait Form Param+1</p>
<p>This has nothing to do with the Deluxe Paint package, but takes into account the extra efficiency of  </p>
<p>the AMOS Professional double buffering and copper calculations, when compared to the standard </p>
<p>Workbench routines!</p>
<p><b>IFF Masking</b></p>
<p>AMOS Professional does not restrict you to loading all of an IFF picture file. It is possible to load  </p>
<p>specific parts of the file that hold such items as the palette and the bit-maps only. The PICTURE </p>
<p>function is used in conjunction with the MASK IFF function to achieve this.</p>
<p><b>PICTURE</b></p>
<p><i>function: return mask details of an IFF image</i></p>
<p>mask=<b>Picture</b></p>
<p><b>MASK IFF</b></p>
<p><i>instruction: mask IFF picture data</i></p>
<p>Mask Iff bit-map</p>
<p>The PICTURE function returns the precise format of the mask used by a picture, and it is used like </p>
<p>this:</p>
<p>Mask Iff Picture</p>
<p>Load Iff “Picture_Name”</p>
<p>Here are some typical settings that can be used to load masked data from an IFF file:</p>
<p>Mask Iff %100 : Rem Load palette of picture only</p>
<p>Mask Iff %10000 : Rem Load bitmaps only</p>
<p><b>Freezing the display</b></p>
<p>In   the   next   Chapter,   the   AMOS   Professional   animation   language   AMAL   is   explained.   AMAL </p>
<p>animations can be frozen with an AMAL FREEZE instruction, and unfrozen with AMAL ON. The </p>
<p>following commands are equivalents to these two instructions, and also offer STOS compatibility.</p>
<p><b>FREEZE</b></p>
<p><i>instruction: freeze the display</i></p>
<p><b>Freeze</b></p>
<p><b>UNFREEZE</b></p>
<p><i>instruction: unfreeze the display</i></p>
<p><b>Unfreeze</b></p>
<p>Use   these   commands   in   your  AMOS   Professional   programs   to   perform   a   simple   freezing   and </p>
<p>unfreezing of moving displays.</p>
<p>07.05.07</p>
<p>I</p>
<p>F</p>
<p>F</p>
<p> </p>
<p>A</p>
<p>N</p>
<p>I</p>
<p>M</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p>This Chapter is dedicated to equipping the AMOS Professional programmer with the means to create </p>
<p>the smoothest, fastest and most responsive animations possible. This is achieved by an animation </p>
<p>language that is unique to the AMOS system, and which provides the most complex animation effects </p>
<p>in the simplest way.</p>
<p>A detailed tutorial is held in the AMAL folder on your Tutorial disc.</p>
<p><b>The AMOS Animation Language (AMAL)</b></p>
<p>To generate professional quality computer simulations and arcade games, dozens of objects may need </p>
<p>to be animated on screen simultaneously, and each object must be moved dozens of times every </p>
<p>second. This presents problems for machine code programmers, and as far as normal Basic languages </p>
<p>are concerned, it is asking the impossible!</p>
<p>AMOS Professional ignores these problems altogether! By making use of its own animation language, </p>
<p>and   by   creating   separate   animation   programs,   very   fast,   very   smooth   movements   are   achieved </p>
<p><b>independently</b> </p>
<p>of   the   main   program.   This   animation   facility   is   called   the   AMOS   Animation </p>
<p>Language, or AMAL for short.</p>
<p>Up to 16 different AMAL programs can be run simultaneously, using interrupts, and each program </p>
<p>can be used to animate anything from Sprites and Bobs, to an entire graphical screen!</p>
<p>Each AMAL program controls the movements of a single Object, which can be moved in an infinite </p>
<p>range of pre-defined patterns, from a simple trajectory curve to an incredibly detailed journey around </p>
<p>the screen.</p>
<p>Objects can be controlled directly from the mouse or by joysticks, and any AMAL animation can be </p>
<p>called up from within your main AMOS Professional program. AMAL is so powerful and so versatile </p>
<p>that it really is a question of “seeing is believing”, and there are useful ready-made examples waiting </p>
<p>to be experienced.</p>
<p>AMAL  is   called   a   “language”   because   it   really   does   have   all   the   facilities   of   a   genuine   Basic </p>
<p>vocabulary, with the huge advantage of the fact that all instructions have been optimised for the </p>
<p>greatest possible speed. There are commands for all the features you might expect, such as program </p>
<p>control, decision making and loops, but not only are they executed incredibly fast, AMAL programs </p>
<p>are automatically <b>compiled</b> before they are run!</p>
<p><b>How AMAL is used</b></p>
<p>AMAL commands consist of the shortest possible keywords, so an AMAL instruction is recognised by </p>
<p>only one or two <b>capital</b> letters. <b>Everything in lower case is ignored.</b></p>
<p>This means that you can customise your AMAL instructions to make them more individual, or easier </p>
<p>to recognise. For example, to animate an Object, the appropriate AMAL command word consists of a </p>
<p>single capital A. You are allowed to include this in your listings on its own, or as something like this:</p>
<p>Anim</p>
<p>Animate</p>
<p>Anything</p>
<p>07.06.01</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p>Individual AMAL  instructions  can be  separated from one another  by  almost any  of  the  unused </p>
<p>characters, including spaces. But colons cannot be used for this purpose. You are recommended to use </p>
<p>the semi-colon character “;” instead, like this:</p>
<p>“Move ; Pause ; Jump”</p>
<p>There   is   a   choice   between   two   ways   of   creating   AMAL  programs.   One   way   is   to   define   you </p>
<p>animations from inside AMOS Professional Basic using strings, for which a special AMAL command </p>
<p>is provided. The alternative method is to produce animation sequences with the AMAL accessory </p>
<p>program, and save them into a memory bank.</p>
<p>The next part of this Chapter is a step-by-step guide through the basic principles of AMAL, and is </p>
<p>intended as an introductory tutorial. This is followed by a full list of all the AMAL commands, along </p>
<p>with detailed explanations of their use. Then advanced techniques will be dealt with. At the end of the </p>
<p>Chapter,   problems   with  AMAL  errors   are  solved,   followed   by   a   final   section   that   provides   full </p>
<p>compatibility for STOS programmers.</p>
<p><b>The AMAL guided tour</b></p>
<p>In this section, Sprites will be used to demonstrate the wonders of AMAL. All of these techniques </p>
<p>work equally well with Bobs, so you can take full advantage of both types of Object in your AMAL </p>
<p>programs.</p>
<p><b>Moving an Object</b></p>
<p><b>MOVE</b></p>
<p><i>AMAL instruction: move an Object</i></p>
<p><b>M</b>ove horizontal number,vertical number,step</p>
<p>The M command moves an Object by a specified number of units horizontally and vertically, in </p>
<p>exactly   the   number   of   steps   you   select.   Positive   values   will   move   the   Object   to   the   right   and </p>
<p>downwards,   while   negative   values   control   movement   to   the   left   of   the   screen   and   upwards. </p>
<p>Remember, as with most AMAL commands, this instruction is recognised by a single capital letter, so </p>
<p>if it is entered as “Move” or a similar single word beginning with the letter M, all of the lower case  </p>
<p>letters will be completely ignored. To demonstrate Move, first place a Sprite on screen at coordinates  </p>
<p>100,100 with this:</p>
<p>Load “AMOSPro Tutorial:Objects/Sprites.abk” : Get Sprite Palette</p>
<p>Sprite 8,200,100,1</p>
<p>The range, direction and speed of how the Sprite will move now depends on the three chosen values </p>
<p>given after the Move command. The size of the steps will particularly affect the Sprite's movement,  </p>
<p>with a large number of steps for a large distance resulting in very slow, very smooth movements, and </p>
<p>very few steps giving jerky movements. Add the following lines to the last example:</p>
<p>Amal 8, “M 100,100,50” : Amal On 8 : Wait Key : Rem Slow diagonal movement</p>
<p>07.06.02</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p>The parameters in a Move command are not limited to numbers. You can also employ expressions </p>
<p>using AMAL functions. In the following example, use is made of XM and YM, which are the pair of  </p>
<p>AMAL functions that return the current coordinates of the mouse. This sort of technique is often used </p>
<p>to make an Object appear to chase after a player in “intelligent” pursuit:</p>
<p>Load “AMOSPro_Tutorial:Objects/Sprites.abk” : Get Sprite Palette</p>
<p>Sprite 8,200,100,1</p>
<p>Amal 8,“Move XM-X,YM-Y,32”</p>
<p>Amal On 8 : Wait Key</p>
<p><b>Animating an Object</b></p>
<p><b>ANIM</b></p>
<p><i>AMAL instruction: animate an Object</i></p>
<p><b>A</b>nim number,(image,delay)(image,delay) ...</p>
<p>Once Objects are moving smoothly across the screen, the next stage is to animate them. This is </p>
<p>achieved by cycling an Object through a series of images, using the Anim command. Anim is followed </p>
<p>by a number, which specifies how many times the animation cycle is to be repeated. If this number is </p>
<p>given a value of zero, the animation will be performed continuously. The “frames” of the animation </p>
<p>are each held in a pair of brackets containing two parameters. First, the number of the image is given, </p>
<p>then the delay time that this image is to be displayed on screen, measured in 50ths of a second. </p>
<p>Remember that you are recommended to use semi-colons to separate AMAL commands, as shown in </p>
<p>the following example:</p>
<p>Load “AMOSPro Tutorial:Objects/Sprites.Abk”</p>
<p>Get Sprite Palette</p>
<p>SP=6 : Sprite SP,200,100,7</p>
<p>M$=Anim 26,(7,4)(8,5);”</p>
<p>M$=M$+“Move 100,100,150; Move-100,-100,75”</p>
<p>Channel SP To Sprite SP</p>
<p>Amal SP,M$ : Amal On SP</p>
<p>Direct</p>
<p>For an instant demonstration of an animated Object, please examine this tutorial program:</p>
<p>Load “AMOSPro_Tutorial:Tutorials/AMAL/AMAL_1.AMOS”</p>
<p><b>Moving within AMAL programs</b></p>
<p><b>JUMP</b></p>
<p><i>AMAL instruction: move to a label in AMAL program</i></p>
<p><b>J</b>ump label</p>
<p>As you begin to use the facilities of AMAL with confidence, you will soon need to be able to jump </p>
<p>from one part of a program to another. This is achieved by defining a label, and then using the Jump </p>
<p>command to move to that label.</p>
<p>07.06.03</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p>All AMAL labels are defined using a single capital letter, followed by a colon. In the same way that </p>
<p>commands   are   recognised,   any   lower-case   letters   that   you   may   want   to   use   to   improve   the </p>
<p>understanding of your listings will be ignored. So the following labels are all acceptable:</p>
<p>T:</p>
<p>Target:</p>
<p>Zippadeedoodah:</p>
<p>Remember that each label is defined by one upper-case letter only, so in those examples, both T: and </p>
<p>Target: refer to the same label! If you forget this, and try to define two different labels starting with </p>
<p>the same letter, an error message will be generated.</p>
<p>Each AMAL program can have its own unique set of labels,  so it is perfectly acceptable to use </p>
<p>identical labels in several different programs.</p>
<p><b>AMAL registers</b></p>
<p><b>LET</b></p>
<p><i>AMAL instruction: assign a value to a register</i></p>
<p><b>L</b>et register=expression</p>
<p>The   Let   instruction   is   used   to   assign   a   value   to   an   AMAL  register,   and   it   is   very   similar   to </p>
<p>conventional Basic except for the fact that all expressions are evaluated strictly from left to right.</p>
<p>The registers are used to hold values in AMAL programs, and allowable numbers range from -32768 </p>
<p>up to 32767.</p>
<p>There are three types of AMAL register, as follows.</p>
<p><b>Internal registers R0 to R9</b></p>
<p>Every   AMAL   program   has   its   own   set   of   ten   internal   registers.   Their   names   start   with   the </p>
<p>identification letter R, followed by one of the digits from 0 to 9 and internal registers are like the local </p>
<p>variables defined inside a normal AMOS Professional procedure.</p>
<p><b>External registers RA to RI</b></p>
<p>External AMAL registers keep hold of their values between separate AMAL programs. This allows </p>
<p>them to be used to pass information between several AMAL routines. There are 26 external registers </p>
<p>provided, each having the identification letter R followed by one of the 26 letters of the alphabet from  </p>
<p>A to Z.</p>
<p>The contents of any internal or external register can be accessed directly from your main AMOS </p>
<p>Professional program, using the AMREG function, which is explained later.</p>
<p><b>Special registers X,Y and A</b></p>
<p>There is a set of three values which control the status of an Object, and these are held in three special </p>
<p>registers. X and Y contain the coordinates of the Object, and A stores the number of the image which </p>
<p>is displayed by a Sprite or a Bob.</p>
<p>07.06.04</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p>By changing the values in these registers, the Object can be moved around the screen and animated. </p>
<p>Here is an instant example:</p>
<p>Load “AMOSPro_Tutorial:Tutorials/AMAL/AMAL_2.AMOS”</p>
<p><b>Logical decisions</b></p>
<p>You can trigger a Jump to a label as the result of a simple test performed in an AMAL program.</p>
<p><b>IF</b></p>
<p><i>AMAL structure: perform a test</i></p>
<p><b>I</b>f test <b>J</b>ump label</p>
<p>If the expression in a test is -1 (True), the AMAL program will jump to the specified label, otherwise a </p>
<p>value of zero (False) will result in the execution of the AMAL instruction immediately after the test.</p>
<p>Unlike a standard AMOS Professional structure, you are limited to a single jump after the test.</p>
<p>It is common to pad out this sort of instruction with some lower-case words, which make the program </p>
<p>appear more familiar, but will be ignored by AMAL. If you do add spurious words like “then” or  </p>
<p>“else” you must remember not to use capital letters. For example:</p>
<p>If X&gt;10 then Jump Label else Let X=Y”</p>
<p>Tests can be any logical expression, and may include the following characters:</p>
<p>=</p>
<p>equal</p>
<p>&gt;</p>
<p>greater than</p>
<p>&lt;</p>
<p>less than</p>
<p>&lt; &gt;</p>
<p>not equal</p>
<p>Note that AMAL expressions can include all of the normal arithmetic operations, except MOD. So a </p>
<p>logical AND (&amp;) and a logical OR (|) may be used in AMAL expressions.</p>
<p>Do not try to  <b>combine</b>  several tests into a single AMAL expression using the ampersand (&amp;) or </p>
<p>upright (|) characters.</p>
<p><b>FOR</b></p>
<p><b>TO</b></p>
<p><b>NEXT</b></p>
<p><i>AMAL structure: loop within AMAL program</i></p>
<p><b>F</b>or register=start <b>T</b>o end ... <b>N</b>ext register</p>
<p>This structure is almost identical to Basic's FOR ... NEXT loops. The specified register can be any of </p>
<p>the internal registers from RO to R9, or any external register from RA to RZ. Special registers cannot </p>
<p>be used. Loops may be nested as usual, but the step size of a loop can only be set to 1.</p>
<p>07.06.05</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p>Please note that AMAL automatically waits for the next vertical blank before jumping back to the start </p>
<p>of the loop with Next. The movement of your objects will only be seen when the screen is updated  </p>
<p>after a VBL, so faster loops would merely waste valuable processor time without any visible effect. </p>
<p>AMAL  automatically  synchronises your  For...Next  loops with the screen updates,  producing  the </p>
<p>smoothest possible results. The use of a Pause command is not needed.</p>
<p><b>AUTOTEST</b></p>
<p><b>AU</b>totest (list of tests)</p>
<p>The AUtotest feature provides rapid interaction between AMAL and the user. It adds a special test at </p>
<p>the beginning of the AMAL program, and this test is performed at every VBL before the rest of the  </p>
<p>AMAL program is executed. AUtotest is fully explained in its own section of this Chapter.</p>
<p><b>DIRECT</b></p>
<p><b>D</b>irect</p>
<p>This sets the part of the main program which is to be executed after an Autotest.</p>
<p><b>END</b></p>
<p><b>E</b>nd</p>
<p>The End command terminates the entire AMAL program and turns off the Autotest feature if it has  </p>
<p>been defined.</p>
<p><b>EXIT</b></p>
<p>e<b>X</b>it</p>
<p>This command exits from an Autotest and re-enters the current AMAL program.</p>
<p><b>ON</b></p>
<p><b>O</b>n</p>
<p>The On instruction activates the main program after a Wait command.</p>
<p><b>PAUSE</b></p>
<p><b>P</b>ause</p>
<p>Use Pause to temporarily halt the execution of an AMAL program, and wait for the next vertical blank </p>
<p>period. After the VBL, the program resumes from the next instruction automatically.</p>
<p>You are recommended to use Pause before a Jump command to ensure that the number of jumps is  </p>
<p>less than the maximum of ten per VBL. This frees valuable processor time and can have a superb </p>
<p>effect on the overall speed of your Basic program.</p>
<p>07.06.06</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p><b>WAIT</b></p>
<p><b>W</b>ait</p>
<p>The Wait command freezes your AMAL program and executes an Autotest only.</p>
<p><b>Generating movement patterns</b></p>
<p>Elaborate  movement  patterns  can be  recorded  directly  into  the  AMAL memory  bank,   using  the </p>
<p>AMAL  Editor.   This   superb   accessory   is   fully   detailed   in   Chapter   13.5.   To   create   less   ambitious </p>
<p>movement patterns, AMAL loops can be used to great effect.</p>
<p>The simplest form of motion is a straight line, which is generated by a single For ... Next loop, like </p>
<p>this:</p>
<p>Load “AMOSPro Tutorial:Objects/Sprites.abk” : Get Sprite Palette</p>
<p>SP=4 : Sprite SP, 128,100,7</p>
<p>C$=“For R0=1 To 300; Let X=X+1 ; Next R0” Rem Move from left to right</p>
<p>Amal SP,C$ : Amal On SP</p>
<p>Direct</p>
<p>More complex movements can be created by including extra loops, as follows:</p>
<p>Load “AMOSPro Tutorial:Objects/Sprites.abk” : Get Sprite Palette</p>
<p>SP=6 : Sprite SP,128,60,7</p>
<p>C$=“For R1=0 To 10 ;”</p>
<p>C$=C$+“For R0=1 To 40; Let X=X+8 ; Next R0 ;” : Rem Move right</p>
<p>C$=C$+“Let Y=Y+8 ;” : Rem Move down</p>
<p>C$=C$+“For R0=1 To 40 ; Let X=X-8 ; Next R0 ;” : Rem Move left</p>
<p>C$=C$+“Let Y=Y+8 ; Next R1”: Rem Move down</p>
<p>Amal SP,C$ : Amal On SP</p>
<p>Direct</p>
<p><b>Playing a complex movement path</b></p>
<p>Migrating birds, car-assembly robots, sheep dogs and hostile aliens have one thing in common, they </p>
<p>all seem to move in intelligent patterns. If you have ever envied the animated sequences featured in </p>
<p>the latest video arcade game, your envy is at an end. AMAL allows you complete freedom to animate </p>
<p>Objects through any sequence of movements imaginable.</p>
<p><b>PLAY</b></p>
<p><i>AMAL instruction: create a movement path</i></p>
<p><b>PL</b>ay path</p>
<p>The PLay command is used to play a movement pattern already defined and stored in the AMAL </p>
<p>memory bank. These patterns are created from the AMAL Editor accessory, which records a sequence </p>
<p>of mouse movements and enters them directly into the AMAL memory bank. Once patterns have </p>
<p>been defined in this way, they can be assigned to any Object on the screen, and that Object will </p>
<p>reproduce your original patterns perfectly. The AMAL Editor is fully explained in Chapter 13.5.</p>
<p>07.06.07</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p>The PLay command is followed by the number of the pre-recorded path stored in the AMAL memory </p>
<p>bank, and path numbers can range from 1 up to the maximum number of patterns that have been  </p>
<p>stored. The first time that AMAL comes across a PLay command, it will look for Ow relevant path </p>
<p>number in this memory bank, and if any problem is encountered, AMAL will abort the operation and </p>
<p>skip to the instruction immediately after the animation string.</p>
<p>As soon as the pattern has been initialised, register RU is loaded with the delay time between each </p>
<p>individual movement step, measured in 50ths of a second. By changing the RU register from inside </p>
<p>the AMAL program, Object movements are slowed down or speeded up. Note that each movement </p>
<p>step is <b>added</b> to the current coordinates of the Object. This means that if the Object movements are </p>
<p>controlled by SPRITE or BOB instructions, that Object will continue its pre-recorded movements from </p>
<p>the new screen location. Furthermore, it is easy to animate dozens of different Objects using a single </p>
<p>sequence of pre-recorded movements.</p>
<p>The value which controls the direction of movement is held in register R1. This value can affect </p>
<p>movement in one of three different ways, as follows.</p>
<p><b>R1 Value</b></p>
<p><b>Effect</b></p>
<p>&gt;0</p>
<p>execute sequence in pre-recorded order</p>
<p>0</p>
<p>execute sequence in reverse order</p>
<p>-1</p>
<p>stop sequence and proceed to next AMAL instruction</p>
<p>The   contents   of   both   register   R1   and   RU   can   be   changed   at   any   time   from   within   the  AMOS </p>
<p>Professional Basic program, by using the AMREG or AMPLAY commands, which are explained later.</p>
<p>For a spectacular demonstration of pre-recorded movement patterns, please load this ready- made </p>
<p>program:</p>
<p>Load “AMOSPro_Tutorial:Tutorials/AMAL/AMAL_5.AMOS”</p>
<p><b>AMAL functions list</b></p>
<p>Here is a full alphabetical list of all the available AMAL functions:</p>
<p><b>BC</b></p>
<p>value=<b>B</b>ob <b>C</b>ol(number,first,last)</p>
<p>BC is identical to the BOB COL Basic instruction. It checks the single Bob whose number is specified  </p>
<p>for collisions with other Bobs, whose numbers are given as the first and last in the range to be </p>
<p>monitored. If a collision is detected, a value of -1 (true) is returned, otherwise 0 (false) is given.</p>
<p>This instruction may not be performed within an interrupt,  so it is only available when AMAL </p>
<p>routines are directly executed from Basic using the SYNCHRO command.</p>
<p>07.06.08</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p><b>C</b></p>
<p>value=Col(number)</p>
<p>This function returns the status of the object whose number is specified, after a BC or SC function. If </p>
<p>the object has collided with another object, a value of -1 (true) is returned, otherwise 0 (false) is given.</p>
<p><b>J0</b></p>
<p>bit-map=<b>J0</b></p>
<p>The J0 function tests the status of the right joystick, and returns a bit-map containing its report. Please </p>
<p>see JOY for a full explanation.</p>
<p><b>J1</b></p>
<p>bit-map=<b>J1</b></p>
<p>The J1 function tests the left joystick and returns a bit-map containing its current status. Please see </p>
<p>JOY for a full explanation.</p>
<p><b>K1</b></p>
<p>value=<b>K1</b></p>
<p>The K1 function checks if the left mouse key has been pressed, and returns a value of -1 (true) or 0 </p>
<p>(false).</p>
<p><b>K2</b></p>
<p>value=<b>K2</b></p>
<p>The K2 function checks the right mouse key. If it has been pressed a value of -1 (true) is returned,  </p>
<p>otherwise 0 (false) is given.</p>
<p><b>SC</b></p>
<p>value=<b>S</b>prite <b>C</b>ol(number,first,last)</p>
<p>SC is identical to the SPRITE COL Basic instruction. It checks the single Sprite whose number is </p>
<p>specified for collisions with other Sprites, whose numbers are given as the first and last in the range to </p>
<p>be monitored. If a collision is detected, a value of -1 (true) is returned, otherwise 0 (false) is given.</p>
<p>This instruction may not be performed within an interrupt,  so it is only available when AMAL </p>
<p>routines are directly executed from Basic using the SYNCHRO command.</p>
<p><b>VU</b></p>
<p>intensity=<b>VU</b>(voice)</p>
<p>The VU function samples one of the sound channels and returns the intensity of the current voice.  </p>
<p>This information can then be used to animate objects in synchronisation to sound.</p>
<p>07.06.09</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p>Give the voice number to be checked, from 0 to 3, and the intensity is returned in the form of number  </p>
<p>from 0 (silence) to 63 (maximum). Please see VUMETER in Chapter 8.1 for a working example.</p>
<p><b>XH</b></p>
<p>hardx-coordinate=<b>XH</b>ard(screen ,x-coordinate)</p>
<p>The XH function converts a screen x-coordinate into its equivalent hardware coordinate, relative to </p>
<p>the specified screen number.</p>
<p><b>XM</b></p>
<p>x-coordinate=<b>XM</b>ouse</p>
<p>XM is identical to the X MOUSE function in Basic, and returns the x-coordinate of the mouse cursor in  </p>
<p>hardware coordinates.</p>
<p><b>XS</b></p>
<p>hardx-coordinate=<b>XS</b>(screen,x-coordinate)</p>
<p>This converts a hardware coordinate to a screen coordinate, relative to the specified screen number.</p>
<p><b>YH</b></p>
<p>hardy-coordinate=<b>YH</b>ard(screen,y-coordinate)</p>
<p>The YH function converts a screen y-coordinate into its equivalent hardware coordinate, relative to </p>
<p>the specified screen number)</p>
<p><b>YM</b></p>
<p>y-coordinate=<b>YM</b>ouse</p>
<p>YM is identical to the Y MOUSE function in Basic, and returns the y-coordinate of the mouse cursor in </p>
<p>hardware coordinates.</p>
<p><b>YS</b></p>
<p>hardy-coordinate=<b>YS</b>(screen,y-coordinate)</p>
<p>This converts a hardware coordinate to a screen coordinate, relative to the specified screen number.</p>
<p><b>Z</b></p>
<p>random=<b>Z</b>(bit-mask)</p>
<p>The Z function returns a random number from -32767 to 32768.</p>
<p>This number may be limited to a specific range using an optional bit-mask.</p>
<p>07.06.10</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p>A logical AND operation is performed between this bit-mask and the random number to generate the </p>
<p>final result, so setting the bit-mask to a value of 255 would return numbers in the range 0 to 255.</p>
<p>To optimise speed, the number returned is not truly random, and if true random numbers are needed, </p>
<p>they may be generated by the Basic instruction RND and then loaded into an external AMAL register </p>
<p>using AMREG.</p>
<p>There is a tutorial available on the AMAL functions in the following file:</p>
<p>Load “AMOSPro Tutorial:Tutorials/AMAL/AMAL_3.AMOS”</p>
<p><b>Calling an AMAL program from AMOS Professional</b></p>
<p><b>AMAL</b></p>
<p><i>instruction: call an AMAL program</i></p>
<p><b>Amal</b> channel number,“instruction string”</p>
<p><b>Amal</b> channel number,program number</p>
<p><b>Amal</b> channel number,memory bank address</p>
<p><b>Amal</b> channel number,“instruction string” To address</p>
<p>The AMAL command is used to assign an AMAL program to an animation channel. This program can </p>
<p>be taken from an instruction string, or it may be taken directly from the AMAL memory bank. In </p>
<p>either case, the AMAL instruction is followed by the channel number to be assigned, ranging from 0 </p>
<p>to 63.</p>
<p>Each channel can be independently assigned to a Sprite, or a Bob, or a screen.</p>
<p>Only the first 16 AMAL programs, assigned to channels 0 to 15, can be performed using interrupts. </p>
<p>Channels 16 to 63 must be executed directly from Basic using the SYNCHRO command, which is </p>
<p>explained elsewhere in this Chapter.</p>
<p>There is also a version of the AMAL command provided for advanced users. In this version, the </p>
<p>contents of registers X,Y and A are copied into a specific area of memory. This information can then be </p>
<p>used in AMOS Professional Basic routines, which means that AMAL can be exploited to animate </p>
<p>anything from an individual character, to a graphical block. The format used by this technique is as </p>
<p>follows:</p>
<p>Amal channel number,A$ To address</p>
<p>The address must be even, and point to a safe memory location, preferably in an AMOS Professional </p>
<p>string, or memory bank. The AMAL program is executed every 50th of a second, and the following </p>
<p>values will be written into the specified memory area:</p>
<p><b>Location</b></p>
<p><b>Effect</b></p>
<p>Address</p>
<p>Bit 0 This is set to 1 if X register has changed</p>
<p>Bit 1 This indicates that Y register has changed</p>
<p>Bit 2 This is set if image (A) has changed since last interrupt</p>
<p>Address+2</p>
<p>This is a word containing the latest value of X</p>
<p>Address+4</p>
<p> Holds the current value of Y</p>
<p>Address+6</p>
<p>Stores the value of A</p>
<p>07.06.11</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p>Note that these values can be accessed from your program using the DEEK function. Note also that  </p>
<p>this AMAL option overrides any previous CHANNEL assignments.</p>
<p><b>Controlling update timings</b></p>
<p>Although most AMAL programs are performed incredibly quickly, all Objects that are manipulated </p>
<p>must be drawn on screen individually, and updated at regular intervals. The amount of time needed </p>
<p>for this updating procedure can vary during the course of a program, and so it is unpredictable. This </p>
<p>can generate jerky movement patterns for certain Objects. Fortunately, This problem can be solved </p>
<p>very easily.</p>
<p><b>UPDATE EVERY</b></p>
<p><i>instruction: control update intervals</i></p>
<p><b>Update Every</b> number</p>
<p>The UPDATE EVERY command slows down the updating process, so that even the largest Object can </p>
<p>be re-drawn during a single screen update. The animation system is regulated by this process, once </p>
<p>again providing smooth movement. After the UPDATE EVERY command, simply specify the number </p>
<p>of vertical blank periods between each screen update, in 50ths of a second. Begin your timing changes </p>
<p>with a value of two, and increase the value by one unit at a time until the animation becomes smooth.</p>
<p>One useful effect of using UPDATE EVERY is to reserve more time for AMOS Professional to execute </p>
<p>the main program. In fact, with careful use of this instruction, it is possible to speed up programs by </p>
<p>as much as one third, and still maintain excellent animation.</p>
<p><b>Assigning Objects to Channels</b></p>
<p>Up to 64 different AMAL programs can be executed simultaneously, and each program must be </p>
<p>assigned to a specific animation “channel”. The first 16 channels can be performed using interrupts, </p>
<p>but if more than 16 animations are needed, interrupts must be turned off using the SYNCHRO OFF </p>
<p>command, which is explained below. As a default, the 16 interrupt channels are assigned to the </p>
<p>relevant Sprite numbers.</p>
<p><b>CHANNEL</b></p>
<p><i>instruction: assign an Object to an AMAL channel</i></p>
<p><b>Channel</b> number To Sprite number</p>
<p><b>Channel</b> number To Bob number</p>
<p>The CHANNEL command assigns an animation channel to a particular screen-related Object. There is </p>
<p>no restriction to a single channel, and any single Object can be animated with several channels, if </p>
<p>necessary.</p>
<p><b>Animating Sprites</b></p>
<p>As a default, channels 0 to 7 are allocated to the equivalent hardware Sprite number, and channels 8 </p>
<p>to 15 are reserved for the equivalent computed Sprite numbers.</p>
<p>07.06.12</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p>To animate computed Sprite numbers 16 to 63,  they must be directly allocated to an animation </p>
<p>channel with the CHANNEL command, like this:</p>
<p>Load “AMOSPro_Tutorial:Tutorials/AMAL/Channel 20 To Sprite 18”</p>
<p>The X,Y registers in your AMAL program now refer to the hardware coordinates of the selected  </p>
<p>Sprite, and the current image of that Sprite is held in register A.</p>
<p><b>Animating Bobs</b></p>
<p>A Bob is assigned to an animation channel in the same way, and will be treated in an identical manner </p>
<p>to the equivalent hardware Sprite. The only difference will be that registers X and Y will hold the </p>
<p>current Bob position in screen coordinates.</p>
<p>Please loads the following program for a demonstration of assigning channels:</p>
<p>Load “AMOSPro_Tutorial:Tutorials/AMAL/AMAL_4.AMOS”</p>
<p><b>Animating more than 16 Objects</b></p>
<p>As has been explained, up to 16 different AMAL programs can normally be executed at one time. This </p>
<p>limitation   is   imposed   by   the   Amiga's   interrupt   capabilities   being   unable   to   cope   with   more. </p>
<p>Fortunately, the AMOS Professional programmer is provided with the means to beat this limitation, </p>
<p>by executing AMAL programs directly, and bypassing the interrupt system altogether.</p>
<p><b>SYNCHRO</b></p>
<p><b>SYNCHRO ON</b></p>
<p><b>SYNCHRO OFF</b></p>
<p><i>instructions: execute AMAL programs directly</i></p>
<p><b>Synchro</b></p>
<p><b>Synchro On</b></p>
<p><b>Synchro Off</b></p>
<p>All  AMAL  programs   can   be   run   by   a   single   call   to   the   SYNCHRO   command.   Prior   to   calling  </p>
<p>SYNCHRO, the interrupts must be turned off with a SYNCHRO OFF instruction. It is important that </p>
<p>this is done  <b>before</b>  defining your AMAL programs, otherwise you will still be restricted to using </p>
<p>channels 0 to 15.</p>
<p>Because   AMAL   programs   are   so   much   faster   than   their   Basic   equivalents,   animations   will   be </p>
<p>incredibly smooth, even when the limit of 16 Objects is broken. For a ready-made example please load </p>
<p>the following program:</p>
<p>Load “AMOSPro_Tutorial:Tutorials/AMAL/AMAL_6.AMOS”</p>
<p><b>Manipulating screens</b></p>
<p>The CHANNEL command is not restricted to assigning Objects. It can also be used to affect entire </p>
<p>screens in four different ways: positioning screens, scrolling screens, changing the screen size and </p>
<p>generating rainbow effects.</p>
<p>07.06.13</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p><b>CHANNEL</b></p>
<p><i>instruction: manipulate a screen</i></p>
<p><b>Channel</b> channel number <b>To Screen Display</b> screen number</p>
<p><b>Channel</b> channel number <b>To Screen Offset</b> screen number</p>
<p><b>Channel</b> channel number <b>To Screen Size</b> screen number</p>
<p><b>Channel</b> channel number <b>To Rainbow</b> rainbow number</p>
<p><b>Moving a screen</b></p>
<p>Normally, the SCREEN DISPLAY command is used to position the current screen on a television </p>
<p>display. However, you may need to achieve the same effect using interrupts, and the CHANNEL </p>
<p>instruction may be used for this purpose. Simply specify which channel number is to be set to which </p>
<p>screen number, and the X and Y variables in AMAL will hold the position of the screen in hardware </p>
<p>coordinates. Note that register A is not used by this technique, and screens may not be animated </p>
<p>using the ANIM command, although all other AMAL instructions can be performed as normal.</p>
<p>In fact the screen number can be defined anywhere in your program, and this system will work </p>
<p>perfectly   provided   that   the   screen   is   opened  <b>before</b>  the   animation   is   started.   Here   is   a   simple </p>
<p>example:</p>
<p>Flash Off : Load Iff “AMOSPro Examples:Iff/Logo.Iff”</p>
<p>Channel 0 To Screen Display 0</p>
<p>Amal 0,“Loop: Move 0,200,100; Move 0,-200,100; Jump Loop”</p>
<p>Amal On: Direct</p>
<p><b>Hardware scrolling</b></p>
<p>Using hardware scrolling to manipulate screens can be achieved by the SCREEN OFFSET instruction, </p>
<p>but it is often much easier to animate screens using the smooth techniques of AMAL. Specify which </p>
<p>channel   number   is   to   assigned   to   which   screen   number,   using   the   CHANNEL   command   in </p>
<p>conjunction with the SCREEN OFFSET command. AMAL's X and Y registers will now refer to the  </p>
<p>section of the screen which is to be displayed on your television display. By changing these registers, </p>
<p>the visible screen area can be scrolled around the display. Try moving the mouse in Direct Mode, to </p>
<p>affect this example:</p>
<p>Screen Open 0,320,500,32,Lowres : Rem Open tall screen</p>
<p>Screen Display 045,320,250</p>
<p>Flash Off : Cls 0</p>
<p>Load Iff “AMOSPro_Examples:Iff/Logo.Iff”</p>
<p>Screen Copy 0,0,0,320,250 To 0,0,251</p>
<p>Screen 0: Get Palette (0)</p>
<p>Channel 0 To Screen Offset 0</p>
<p>Amal 0,“Loop: Let X=XM-128 ; Let Y=YM-45 ; Pause; Jump Loop”</p>
<p>Amal On : Wait Key</p>
<p><b>Changing the screen size</b></p>
<p>Similarly to moving and scrolling a screen with the CHANNEL command, the size of a screen can be </p>
<p>changed when CHANNEL is used in conjunction with SCREEN SIZE. When the channel number is </p>
<p>assigned TO a screen number in this way, registers A and Y will control the width and height of the </p>
<p>screen.</p>
<p>07.06.14</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p>Here is an example:</p>
<p>Load Iff “AMOSPro Examples:Iff/Logo.Iff”,0</p>
<p>Channel 0 To Screen Size 0</p>
<p>Screen Display 0,320,1 : Rem Set screen size to 1</p>
<p>A$=“Loop: For R0=0 To 255; Let Y=R0; Next R0;”</p>
<p>A$=A$+“For R0=0 To 254; Let Y=255-R0; Next R0 ; J Loop”</p>
<p>Amal 0,A$ : Amal On: Direct</p>
<p><b>Creating rainbow effects</b></p>
<p>The final use of CHANNEL is with the RAINBOW command. As usual, a channel number between 0 </p>
<p>and 63 is assigned to a rainbow number. Please remember that rainbow numbers range from 0 to 3. </p>
<p>The X register will now hold the first colour of the rainbow palette which is to be displayed, and by </p>
<p>changing the value in this register the rainbow will appear to cycle. The Y register will contain the line </p>
<p>on screen where the rainbow effect begins. By changing this value, the rainbow effect can be moved </p>
<p>up and down. All positions are measured in hardware coordinates. Finally, register A stores the </p>
<p>height of the rainbow on screen.  Remind  yourself  of the  scrolling  rainbow  effect in  this instant </p>
<p>example:</p>
<p>Load “AMOSPro_Tutorial:Tutorials/AMAL/AMAL_4.AMOS”</p>
<p><b>The Autotest system</b></p>
<p>Normally, all AMAL programs are performed in sequence, from start to finish. There are certain </p>
<p>routines that will take a few seconds to complete, such as a For ... Next loop or a Move. In most cases  </p>
<p>this   does   not   cause   any   problem,   but   sometimes   delays   can   be  caused.   The  Autotest   feature   is </p>
<p>provided to solve such problems, and it is used to change the sequence of instructions.</p>
<p>The following example demonstrates just such a problem, which could benefit from an Autotest. In </p>
<p>this example, the Sprite is supposed to follow the movements of the mouse. However, because the </p>
<p>new XM and YM movements are entered after the Sprite movement has completely finished, the </p>
<p>routine is unacceptably slow. Try moving the mouse in a circle, to exaggerate the problem:</p>
<p>Load “AMOSPro_Tutorial:Objects/Sprites.abk” : Get Sprite Palette</p>
<p>Sprite 8,130,50,1</p>
<p>Amal 8,“Loop: Let R0=XM-X ; Let R1=YM-Y ; Move R0,R1,50 ; Jump Loop”</p>
<p>Amal On: Direct</p>
<p>After an explanation of the Autotest commands, and an explanation of how to use them, you will be </p>
<p>able to rewrite that example and solve the problem.</p>
<p><b>AUTOTEST</b></p>
<p><i>AMAL Autotest system</i></p>
<p><b>AU</b>totest (list of test commands)</p>
<p>The feature is activated by a call to AUtotest, followed by a pair of brackets containing the series of  </p>
<p>the tests you want to use.</p>
<p>07.06.15</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p>These tests consist of any of the following commands:</p>
<p><b>Let</b></p>
<p><b>L</b> register=expression</p>
<p>This is the standard AMAL Let instruction, and it assigns the result of an expression to a register. For </p>
<p>example:</p>
<p>Let R0=XM</p>
<p><b>JUMP</b></p>
<p><b>J</b> label</p>
<p>Use Jump to go to a label positioned at another part of the current Autotest. The label is defined using </p>
<p>a colon, and it must lie <b>inside</b> the Autotest brackets, like this:</p>
<p>(... J Targetlabel … Targetlabel: ...)</p>
<p><b>EXIT</b></p>
<p>e<b>X</b>it</p>
<p>This leaves the Autotest and re-enters the main program once again, at the original departure point.</p>
<p><b>WAIT</b></p>
<p><b>W</b>ait</p>
<p>This turns off the main AMAL program completely, and only allows the Autotest to be executed.</p>
<p><b>ON</b></p>
<p><b>O</b>n</p>
<p>The On instruction re-starts the main program again after a previous Wait command. This allows you </p>
<p>to wait for a specific event, such as a mouse click, without wasting valuable processor time.</p>
<p><b>DIRECT</b></p>
<p><b>D</b>irect label</p>
<p>The   Direct   command   changes   the   point   at   which   the   main   program   will   be   resumed,   after   an </p>
<p>Autotest. AMAL will now jump to this point at the next vertical blank period. Note that the label must </p>
<p>be defined <b>outside</b> of the Autotest brackets. For example:</p>
<p>(... Direct M)</p>
<p>... M:</p>
<p>07.06.16</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p><b>IF</b></p>
<p><b>I</b>f expression <b>J</b>ump label</p>
<p><b>I</b>f expression <b>D</b>irect label</p>
<p><b>I</b>f expression e<b>X</b>it</p>
<p>This is a specially extended version of the standard If statement used in AMAL, and it is used to </p>
<p>simplify the testing process inside an Autotest routine. It depends on the result of a logical expression, </p>
<p>and triggers one ,of three actions. The three alternatives are a Jump to another part of the Autotest, or </p>
<p>a Direct change of the resumption point of a program, or an eXit from the Autotest.</p>
<p>Here is the example at the start of this section, re-written with the Autotest system in place:</p>
<p>Load “AMOSPro Tutorial:Objects/Sprites.abk” : Get Sprite Palette</p>
<p>Sprite 8,130,50,1</p>
<p>A$=“AUtotest (If R1&lt;&gt;XM Jump Update)”</p>
<p>A$=A$+“If R1&lt;&gt;YM Jump Update else eXit”</p>
<p>A$=A$+“Update: Let R0=XM; Let R1=YM; Direct M)” : Rem End of Autotest</p>
<p>A$=A$+“M: Move R0-X,R1-Y,20; Wait;” : Rem Try Changing 20 to other </p>
<p>values</p>
<p>Amal 8,A$ : Amal On : Direct</p>
<p>If all is well, the Sprite should now be following your mouse, no matter how fast it is moved. To </p>
<p>analyse the last example, identify how the mouse coordinates are tested every 50th of a second, using </p>
<p>the XM and YM functions. If they remain unchanged since the last test, the Autotest is short-circuited </p>
<p>by the eXit command, and the main program resumes exactly where it left off. But if the mouse has </p>
<p>been moved, the Autotest re-starts the main program from label M, at the beginning, using the new </p>
<p>coordinates in XM and YM.</p>
<p>For a tutorial session involving the Autotest feature, as well as a fully playable arcade game, please  </p>
<p>load the following program and remember to watch the birdie!</p>
<p>Load “AMOSPro_Tutorial:Tutorials/AMAL/AMAL_7.AMOS”</p>
<p><b>AMAL program control from AMOS Professional</b></p>
<p>Once an AMAL program has been defined, you will need to be able to execute and control it from </p>
<p>inside an ordinary AMOS Professional program. Here are the commands provided for this purpose.</p>
<p><b>AMAL ON</b></p>
<p><b>AMAL OFF</b></p>
<p><i>instructions: start and stop AMAL programs</i></p>
<p><b>Amal On</b></p>
<p><b>Amal On</b> <i>number</i></p>
<p><b>Amal Off</b></p>
<p><b>Amal Off</b> <i>number</i></p>
<p>AMAL ON is used to activate all AMAL programs.</p>
<p>07.06.17</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p>If an optional number is given, then only that AMAL routine will be activated. Similarly, AMAL OFF </p>
<p>stops all AMAL programs from executing, by erasing them from memory. They can only be re-</p>
<p>activated by using the AMAL command again. By specifying an individual AMAL program number, </p>
<p>only that program is stopped.</p>
<p><b>AMAL FREEZE</b></p>
<p><i>instruction: suspend AMAL programs</i></p>
<p><b>Amal Freeze</b></p>
<p><b>Amal Freeze</b> <i>number</i></p>
<p>Use this command to temporarily freeze one or all AMAL programs from running. These programs </p>
<p>may be started again at any time with an AMAL ON command. Please note that AMAL FREEZE  </p>
<p>should be used to suspend AMAL before a command such as DIR is executed, otherwise timing </p>
<p>problems may happen.</p>
<p><b>AMREG</b></p>
<p><i>reserved variable: give value of AMAL register</i></p>
<p>register=<b>Amreg</b>(number)</p>
<p>register=<b>Amreg</b>(<i>channel</i>,number)</p>
<p><b>Amreg</b>(number)=expression</p>
<p><b>Amreg</b>(<i>channel</i>,number)=expression</p>
<p>The AMREG function  allows you to  gain  access  to the contents of internal and  external AMAL </p>
<p>registers,   from   inside   your   AMOS   Professional   program.   An   AMAL   register   number   must   be </p>
<p>specified, ranging from 0 to 25, with zero representing external register RA, up to 25 representing </p>
<p>register RZ. An optional channel parameter can be given, where a specified number from 0 to 9 is </p>
<p>used to represent the AMAL internal registers from RU to R9.</p>
<p>The following example demonstrates how the position of an AMAL Sprite can be returned:</p>
<p>Load “AMOSPro_Tutorial:Objects/Sprites.abk” : Get Sprite Palette</p>
<p>Channel 1 To Sprite 8 : Sprite 8,100,100,1</p>
<p>A$=“Loop : Let RX=X+1 Let X=RX ; Pause ; Jump Loop”</p>
<p>Amal 1,A$ : Amal On : Curs Off</p>
<p>Do</p>
<p>Locate 0,0</p>
<p>Z=Asc(“X”)-65</p>
<p>Print Amreg(Asc(“X”)-65) : Rem Use Asc to get register number</p>
<p>Loop</p>
<p><b>AMPLAY</b></p>
<p><i>instruction: control animation produced by PLay</i></p>
<p><b>Amplay</b> <i>speed, direction</i></p>
<p><b>Amplay</b> <i>speed,direction start <b>To</b> end</i></p>
<p>Movement sequences that have been produced using the PLay command are controlled through the</p>
<p>07.06.18</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p>internal registers R0 and R1. Every animated Object is assigned its own unique set of AMAL registers, </p>
<p>but if several Objects are being animated together, several registers may need to be set with exactly </p>
<p>the same values. Although this can be achieved by the AMREG function, it is simpler to use a single </p>
<p>instruction for changing these registers, affecting a whole batch of Objects simultaneously.</p>
<p>When speed and direction parameters are given after an AMPLAY command, they are loaded in to </p>
<p>registers R0 and R1 in the selected channels. The controlling speed of the Object is set by a delay time, </p>
<p>given in 50ths of a second, between each movement of the Object. The direction parameter changes </p>
<p>the direction of the movement, and is set by one of the following values:</p>
<p><b>Value</b></p>
<p><b>Direction of Motion</b></p>
<p>&gt;0</p>
<p>Move the selected Object in the original movement direction</p>
<p>0</p>
<p>Reverse the motion and move the Object backwards</p>
<p>-1</p>
<p>Abort movement and jump to next AMAL instruction</p>
<p>Note that either the speed or direction parameters can be omitted, as required.</p>
<p>The AMPLAY command normally affects all current animation channels, but optional start and end </p>
<p>points may also be given to set the channel numbers of the first and last Objects to be affected. Here </p>
<p>are some examples:</p>
<p>Amplay ,0: Rem Reverse objects</p>
<p>Amplay 2, : Rem Slow down movement pattern</p>
<p>Amplay 3,1 : Rem Set speed to 3 and direction to 1</p>
<p>Amplay ,-1 3 To 6: Rem Stop movement on channels 3,4,5 and 6</p>
<p><b>CHANAN</b></p>
<p><i>function: test a channel for an active animation</i></p>
<p>value=<b>Chanan</b>(channel number)</p>
<p>This simple function is used to check if the specified animation channel is currently engaged. A value </p>
<p>of -1 (true) is returned if the animation is active, otherwise a zero (false) is given if the animation is </p>
<p>complete. Here is an example:</p>
<p>Load “AMOSPro Tutorial:Objects/Sprites.abk” : Get Sprite Palette</p>
<p>Sprite 9,150,150,1</p>
<p>M$=“Anim 12,(1,4)(2,4)”</p>
<p>Amal 9,M$ : Amal On : Wait Vbl</p>
<p>While Chanan(9)</p>
<p>Wend</p>
<p>Print “Animation complete!”</p>
<p><b>CHANMV</b></p>
<p><i>function: test channel for an active Object</i></p>
<p>value=<b>Chanmv</b>(channel number)</p>
<p>The CHANMV function is used to check if the Object assigned to the specified channel is  </p>
<p>currently moving.</p>
<p>07.06.19</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p>A value of -1 (true).is given if the Object is in motion, otherwise zero (false) is returned. When used  </p>
<p>with   the   Move   instruction   in  AMAL,   the   CHANMV   function   can   check   whether   a   movement </p>
<p>sequence has exhausted its steps. The sequence can then be started again at the new position, with an </p>
<p>appropriate movement string. For example:</p>
<p>Load “AMOSPro Tutorial:Objects/Sprites.abk” : Get Sprite Palette</p>
<p>Sprite 9,90,30,1</p>
<p>M$=“Move 300,150,150; Move -300,-150,75”</p>
<p>Amal 9,M$ : Amal On</p>
<p>While Chanmv(9)</p>
<p>Wend</p>
<p>Print “Movement complete!”</p>
<p><b>AMAL errors</b></p>
<p><b>AMALERR</b></p>
<p><i>function: give position of an AMAL error</i></p>
<p>position=<b>Amalerr</b></p>
<p>The AMALERR function returns the position in the current animation string where an error has been </p>
<p>found. It has been provided to allow the AMOS Professional programmer to locate and correct AMAL </p>
<p>mistakes as quickly as possible. Type the following example exactly as it appears:</p>
<p>Load “AMOSPro Tutorial:Objects/Sprites.Abk” : Get Sprite Palette</p>
<p>Sprite 8,100,100,1</p>
<p>A$=“L: IF X=300 Jump L; Pause; Let X=X+1; Jump L”</p>
<p>Amal 8,A$ : Amal On : Direct</p>
<p>That example will generate an error, because IF will not be interpreted as an “If” structure, but as the </p>
<p>two AMAL instructions I and F. To find the position in the animation string of this error, type the </p>
<p>following line from Direct Mode:</p>
<p>Print Mid$(A$,Amalerr,Amalerr+5)</p>
<p><b>AMAL error messages</b></p>
<p>As soon as a mistake is encountered in an AMAL program, AMOS Professional will exit back to Basic </p>
<p>with an appropriate error message. Here is a list of the errors that can be generated by this system,  </p>
<p>and an explanation of their most likely causes.</p>
<p><b>Bank not reserved</b></p>
<p>You have tried to call the PLay instruction but have forgotten to load a bank containing the movement </p>
<p>data into memory. This should be created with the AMAL accessory program. If the PLay command is </p>
<p>not in use, then check that any Pause and Let commands are separated in your listing.</p>
<p>07.06.20</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p><b>Instruction only valid in autotest</b></p>
<p>The Direct or the eXit instructions have been called from the main AMAL program, by mistake.</p>
<p><b>Illegal instruction in Autotest</b></p>
<p>Autotest can only be used together with a limited range of AMAL commands. Objects cannot be </p>
<p>moved or animated in any way from inside an Autotest, so check for misuse of instructions such as </p>
<p>Move, Anim or For ... Next structures.</p>
<p><b>Jump To/Within Autotest in animation string</b></p>
<p>The commands inside an Autotest are completely separate from the main AMAL program, and direct </p>
<p>jumps are not allowed inside an Autotest procedure. To leave an Autotest and return to the main  </p>
<p>AMAL program, either Direct or eXit must be used.</p>
<p><b>Label already defined in animation string</b></p>
<p>You are trying to define the same label twice in an AMAL program. All AMAL labels consist of a  </p>
<p>single capital letter (For example, “Test” and “Total” are seen as two versions of the same label “T”). </p>
<p>This error can also be generated if two instructions have been separated by a colon. Semi- colons </p>
<p>should be used for this purpose.</p>
<p><b>Label not defined in animation string</b></p>
<p>You are trying to jump to a label that does not currently exist in your animation string.</p>
<p><b>Next without For in animation string</b></p>
<p>Every For command must be matched by a corresponding Next statement. Check any nested loops </p>
<p>for an unnecessary Next.</p>
<p><b>Syntax error in animation string</b></p>
<p>A mistake has been made when typing in an animation string. AMAL commands consist of one or </p>
<p>two capital letters only, and not full keywords as used in AMOS Professional Basic.</p>
<p><b>Compatibility with STOS animation commands</b></p>
<p>AMOS   Professional   has   evolved   from   the   original   STOS   Basic,   written   by   François   Lionet   and </p>
<p>released in 1988 for the Atari-ST. STOS included a celebrated and powerful animation system using </p>
<p>interrupts, which allowed Sprites to be moved in complex patterns. Although this system has been </p>
<p>overshadowed by AMAL, it still provides a simple introduction to Amiga animation. Furthermore, </p>
<p>the   following   commands   will   allow   those   loyal   AMOS   Professional   users,   who   created   STOS </p>
<p>programs in the past, to convert STOS to AMOS!</p>
<p>Unlike   STOS,   the   movement   patterns   in  AMOS   Professional   can   be   assigned   to   any   animation </p>
<p>channel, and the MOVE commands can be used to animate Bobs, Sprites and screens, using exactly </p>
<p>the same techniques.</p>
<p>As a default, all animation channels are assigned to the equivalent hardware Sprites, but because Bobs </p>
<p>are much closer to the standard STOS Sprites, it may be found more convenient to substitute Bobs by </p>
<p>adding a set of CHANNEL commands at the start of a program, like this:</p>
<p>Channel 1 To Bob 1</p>
<p>Channel 2 To Bob 2</p>
<p>07.06.21</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p>Remember to call DOUBLE BUFFER during the initialisation procedure, to prevent unwanted flickers </p>
<p>when your Bobs are moved.</p>
<p>The same channel can be used for STOS animations and AMAL programs, so it is easy to extend your </p>
<p>routines once they have been successfully converted from STOS to AMOS Professional. The order of </p>
<p>execution is AMAL … MOVE X ... MOVE Y ... ANIM.</p>
<p>STOS compatibility is featured in the following ready-made demonstration program:</p>
<p>Load “AMOSPro Tutorial:Tutorials/AMAL/AMAL_5.AMOS”</p>
<p>Here is the entire STOS-compatible range of commands.</p>
<p><b>MOVE X</b></p>
<p><i>instruction: move a Sprite horizontally</i></p>
<p><b>Move X</b> number,“(speed,step,count)... (speed,step,count)<i>L</i>”</p>
<p><b>Move X</b> number,“(speed,step,count)<i>Enumber</i>”</p>
<p>The MOVE X command defines a list of horizontal movements to be performed on the animation </p>
<p>channel  specified  by the  given  <b>number</b>.  This  <b>number</b>  can  range  from  0  to  15,   and  refers  to  an </p>
<p>animation sequence for an Object already assigned by the CHANNEL command. The number is </p>
<p>followed by a “movement string” containing a series of instructions which control the speed and </p>
<p>direction of the Object. These movement commands are enclosed by brackets, and are entered as the </p>
<p>following three parameters, separated by commas.</p>
<p>The  <b>speed</b>  parameter sets a delay between each step of the movement, given in 50ths of a second. </p>
<p>Speed can vary from a value of 1 for very fast, all the way to 32767 for incredibly slow. This is </p>
<p>followed   by   a  <b>step</b>  value,   setting   the   number   of   pixels   the   Object   is   to   be   moved   during   each </p>
<p>operation. A positive value moves the Object to the right, and a negative number to the left. The </p>
<p>apparent speed of the Object will depend on the relationship between the speed and the step values, </p>
<p>varying from slow and smooth, to rapid but jerky movements. A speed value of about 10 (or -10) is  </p>
<p>recommended.   The  last   parameter   is  a  <b>count</b>  value,   which   determines  the   number   of   times   the </p>
<p>movement is to be repeated. Values range between 1 and 32767, with the additional value of zero </p>
<p>causing an indefinite repetition.</p>
<p>It is vital to add an L (loop) instruction to the movement string after these parameters, if you want to  </p>
<p>force a jump to the start of the string, forcing the entire sequence to be run again. Here is an example:</p>
<p>Load “AMOSPro_Tutorial:Objects/Sprites.Abk” :Get Sprite Palette</p>
<p>Sprite 1,360,100,1</p>
<p>Move X1,“(1,1,60)(1,-5,60)L”</p>
<p>Move On</p>
<p>Direct</p>
<p>An alternative ending to the movement string is to use the E option, followed by the value of an x-</p>
<p>coordinate.</p>
<p>07.06.22</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p>This stops the Object when it reaches the specified coordinate value, which must be less than (or equal </p>
<p>to) the original horizontal target destination. Try changing the third line of the last example to this:</p>
<p>Move X 1,”(1,-5,30)E100”</p>
<p><b>MOVE Y</b></p>
<p><i>instruction: move Object vertically</i></p>
<p><b>Move Y</b> number,”(speed,step,count) ...(speed,step,count)”</p>
<p><b>Move Y</b> number,”(speed,step,count) ...(speed,step,count)L”</p>
<p>This command operates in the same way as MOVE X, and controls vertical movement. First the </p>
<p>number of an animation sequence is given, ranging from 0 to 15, and this sequence must be Already </p>
<p>allocated using the CHANNEL command. Then the movement string is given, as explained above. </p>
<p>Positive values for the step parameter control downward movements, and a negative value will result </p>
<p>in an upward movement. Here is an example:</p>
<p>Load “AMOSPro_Tutorial:Objects/Sprites.abk” : Get Sprite Palette</p>
<p>Channel 1 To Sprite 1: Sprite 1,228,50,1: Wait Vbl</p>
<p>Move Y 1,“(1,1,180)(1,-1,180)L” : Rem Loop Sprite</p>
<p>Channel 2 To Screen Display 0: Rem Assign screen position</p>
<p>Move Y 2,“(1,4,25)(1,-4,25)” : Rem Bounce screen up and down</p>
<p>Move On : Wait Key</p>
<p><b>MOVE ON</b></p>
<p><b>MOVE OFF</b></p>
<p><i>instructions: toggle movements</i></p>
<p><b>Move On</b></p>
<p><b>Move On</b> <i>number</i></p>
<p><b>Move Off</b></p>
<p><b>Move Off</b> <i>number</i></p>
<p>Before any movement patterns can be executed, they must be activated by a MOVE ON command. All </p>
<p>movements will begin at once unless an optional number is given, in which case only that particular </p>
<p>animation sequence will be activated. MOVE OFF has the opposite effect, halting all animations, or a </p>
<p>single sequence specified by its number.</p>
<p><b>MOVON</b></p>
<p><i>function: report movement status</i></p>
<p>value=<b>Move On</b>(Object number)</p>
<p>Use the MOVON function to check whether a particular Object is being moved by a MOVE X or </p>
<p>MOVE Y command. A value of -1 (true) is returned while the Object is in motion, otherwise zero  </p>
<p>(false) is given for static Objects. Please note that MOVON does not search for patterns generated by </p>
<p>AMAL.</p>
<p>07.06.23</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p><b>MOVE FREEZE</b></p>
<p><i>instruction: suspend Object movement</i></p>
<p><b>Move Freeze</b></p>
<p><b>Move Freeze</b> <i>number</i></p>
<p>This command suspends the movement of all Objects on screen. Frozen Objects may be re- animated </p>
<p>using the MOVE ON command. If an optional Object number is given after MOVE FREEZE, then </p>
<p>only that Object will be frozen.</p>
<p><b>ANIM</b></p>
<p><i>instruction: animate an Object</i></p>
<p><b>Anim</b> number“(image,delay) (image,delay)”</p>
<p><b>Anim</b> number“(image,delay) (image,delay)L”</p>
<p>ANIM is used to take an Object through a sequence of different images, creating smooth animation </p>
<p>effects. These animations are performed fifty times every second, using interrupts, so they can be </p>
<p>executed  simultaneously  with AMOS  Professional Basic programs. After  the ANIM command,  a </p>
<p>channel number must be given to specify the Object to be animated. Then an animation string is </p>
<p>given, with each operation composed of a pair of brackets holding an image number and a delay time </p>
<p>(in 50ths of a second). For example:</p>
<p>Load “AMOSPro_Tutorial:Objects/Sprites.abk” : Get Sprite Palette</p>
<p>Channel 1 To Sprite 8: Sprite 8,200,100,1</p>
<p>Anim 1,“(1,10)(2,10)(3,10)(4,10)”</p>
<p>Anim On : Wait Key</p>
<p>Similarly to the MOVE command, an L(loop) directive can be added to the movement string, which </p>
<p>will continuously repeat the animation. Try changing the third line in the last example to this:</p>
<p>Anim 1,“(1,10)(2,10)(3,10)(4,10)L”</p>
<p><b>ANIM ON</b></p>
<p><b>ANIM OFF</b></p>
<p><i>instructions: toggle animations on and off</i></p>
<p><b>Anim On</b></p>
<p><b>Anim On</b> <i>number</i></p>
<p><b>Anim Off</b></p>
<p><b>Anim Off</b> <i>number</i></p>
<p>To activate all animation sequences already created by an ANIM command, use ANIM ON. If ail </p>
<p>individual  sequence  is  specified  by  <b>number</b>,  then  only  that  sequence  will  be  affected.  Similarly, </p>
<p>sequences started by ANIM ON may be turned off by the ANIM OFF command.</p>
<p>07.06.24</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>AMAL</p>
<p><b>ANIM FREEZE</b></p>
<p><i>instruction: freeze an animation</i></p>
<p><b>Anim Freeze</b></p>
<p><b>Anim Freeze</b> <i>number</i></p>
<p>The ANIM FREEZE command suspends all animation sequences on screen, leaving them frozen in </p>
<p>place. An optional number may be given to freeze that specific sequence only. Animations can be </p>
<p>started again with a simple call to ANIM ON.</p>
<p><b>The AMAL Editor</b></p>
<p>As   a   final   reminder,   the   AMAL   Editor   is   a   vital   accessory   program   for   AMOS   Professional </p>
<p>programmers   wishing   to   create   detailed   or   complex   movement   patters.   It   is   fully   explained   in </p>
<p>Chapter 13.5.</p>
<p>07.06.25</p>
<p>A</p>
<p>M</p>
<p>A</p>
<p>L</p>
<h1 style="page-break-before:always; "></h1>
<p>Icons and Blocks</p>
<p>This Chapter deals with the practical handling of rectangular units of graphic images.</p>
<p><b>Background screen graphics</b></p>
<p>It is common for modern arcade games to feature hundreds of different background screens, over </p>
<p>which the animated action takes place. Similarly, practical programs like kitchen-planners may need </p>
<p>to display scores of varied settings. A fraction of these requirements would normally exhaust your </p>
<p>Amiga's memory, leaving no room at all for your program!</p>
<p>To overcome this restriction, backgrounds can be constructed from a set of simple graphic blocks, to </p>
<p>be arranged and re-arranged as you wish, in varied patterns Each background screen can now be </p>
<p>stored as a simple list of component blocks. These blocks are sometimes known as “tiles”, and AMOS </p>
<p>Professional provides two sets of alternative tiles: <b>Icons</b>, which are held in their own memory bank, </p>
<p>and <b>Blocks</b>, which are held as temporary data.</p>
<p><b>Icons</b></p>
<p>An Icon is an individual image, specifically designed to act as a component of a background screen  </p>
<p>picture. All Icons are stored in their own AMOS Professional memory bank, which is bank 2, and this </p>
<p>Icon Bank will be saved along with your program listing automatically.</p>
<p>Once an Icon is drawn it has a fixed location and cannot be moved to another part of the screen.</p>
<p>Icons are displayed using the Amiga's Blitter chip, which is also responsible for the display of Robs.  </p>
<p>However, because Icons are essentially static Objects, they are normally drawn in replace mode. This </p>
<p>means that any existing graphics at the relevant screen location will be completely erased by the Icon.</p>
<p>Here is a complete list of the Icon commands.</p>
<p><b>GET ICON</b></p>
<p><i>instruction: create an Icon</i></p>
<p><b>Get Icon</b> Icon number,x1,y1 <b>To</b> x2,y2</p>
<p><b>Get Icon</b> <i>screen number</i>,lcon number,x1,y1 <b>To</b> x2,y2</p>
<p>The GET ICON command grabs an image from the screen and loads it into an Icon. Specify the Icon </p>
<p>number, and then give the coordinates of the rectangle that is to be grabbed, from the top left-hand  </p>
<p>corner to the bottom right-hand corner. If the Icon whose number you specify does not already exist,  </p>
<p>it will be created in Bank 2.  If the memory bank has not been reserved, this will also be done </p>
<p>automatically.</p>
<p>An optional screen number can also be given, immediately after the GET ICON instruction, and this </p>
<p>will select the screen to be used as the source of the Icon's image. If this screen number is omitted, the  </p>
<p>image is taken from the current screen.</p>
<p><b>GET ICON PALETTE</b></p>
<p><i>instruction: load Icon colours into current screen</i></p>
<p><b>Get Icon</b> Palette</p>
<p>This instruction is usually employed to initialise a screen, after Icons have been loaded </p>
<p>from disc.</p>
<p>07.07.01</p>
<p>I</p>
<p>C</p>
<p>O</p>
<p>N</p>
<p>S</p>
<p>/</p>
<p>B</p>
<p>L</p>
<p>O</p>
<p>C</p>
<p>K</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Icons and Blocks</p>
<p>GET ICON PALETTE grabs the colours of the Icon images stored in Bank 2, and loads them in to the </p>
<p>current screen.</p>
<p><b>PASTE ICON</b></p>
<p><i>instruction: draw an Icon</i></p>
<p><b>Paste Icon</b> x,y,number</p>
<p>Use the PASTE ICON command to draw the specified Icon number already stored in Bank 2, on  </p>
<p>screen. The screen position is defined by  <b>graphic</b>  coordinates, and can be anywhere you like. Icon </p>
<p>images will be clipped in the normal way, if they exceed the standard limitations. Here is a simple </p>
<p>example:</p>
<p>Flash Off : Load Iff “AMOSPro_Examples:Iff/logo.iff”</p>
<p>Z=0</p>
<p>For A=0 To 304 Step 16</p>
<p>Inc Z</p>
<p>Get Block Z,A,1,16,199</p>
<p>Next A</p>
<p>Cls 0</p>
<p>For A=0 To 304 Step 16</p>
<p>Put Block Z,A,0</p>
<p>Dec Z</p>
<p>Wait Vbl</p>
<p>Next A</p>
<p>If the DOUBLE BUFFER system in engaged, a copy of the Icon will be drawn into both the logical and </p>
<p>physical screens, and because this takes a little time, you are advised to add a call to AUTOBACK 0  </p>
<p>before drawing Icons on screen. This restricts the Icon to the current logical screen, and then the entire </p>
<p>background may be copied to the physical screen, using SCREEN COPY, which is a much faster </p>
<p>process.</p>
<p><b>DEL ICON</b></p>
<p><i>instruction: delete Icons</i></p>
<p><b>Del Icon</b> number</p>
<p><b>Del Icon</b> first number <i><b>To</b></i> <i>last number</i></p>
<p>DEL ICON erases the Icon whose number is specified from Bank 2. A second Icon number may also  </p>
<p>be given, in which case, all Icons from the first number TO the second number will be deleted. When </p>
<p>the final Icon in the bank has been deleted, the whole bank will be removed from memory.</p>
<p><b>INS ICON</b></p>
<p><i>instruction: insert a blank Icon image into the Icon bank</i></p>
<p><b>Ins Icon</b> number</p>
<p><b>Ins Icon</b> first To last</p>
<p>The INS ICON instruction operates in exactly the same way as INS BOB, which is explained in </p>
<p>Chapter 7.2.</p>
<p>07.07.02</p>
<p>I</p>
<p>C</p>
<p>O</p>
<p>N</p>
<p>S</p>
<p>/</p>
<p>B</p>
<p>L</p>
<p>O</p>
<p>C</p>
<p>K</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Icons and Blocks</p>
<p><b>MAKE ICON MASK</b></p>
<p><i>instruction: set colour zero to transparent</i></p>
<p><b>Make Icon Mask</b></p>
<p><b>Make Icon Mask</b> <i>number</i></p>
<p>Normally, any Icons that are drawn on screen completely replace the existing background image, and </p>
<p>the Icon appears in a rectangular box filled with colour zero. If you prefer to overlay Icons on top of </p>
<p>the current graphics, a mask must be created. This is achieved by the MAKE ICON MASK command,  </p>
<p>and sets colour zero to transparent. All Icons in Bank 2 will be affected by this instruction, unless an </p>
<p>optional Icon number is given, in which case only that Icon will be masked.</p>
<p><b>NO ICON MASK</b></p>
<p><i>instruction: remove colour zero mask from Icon</i></p>
<p>No Icon Mask number</p>
<p>This command performs exactly the same task as the NO MASK instruction, explained in Chapter 7.2, </p>
<p>except that it is used with Icons instead of Bobs.</p>
<p><b>Screen Blocks</b></p>
<p>Unlike Icons, graphic Blocks are  <b>not</b>  saved along with your programs, and the following BLOCK </p>
<p>Instructions are used to hold and manipulate temporary graphics data. Blocks are extremely useful </p>
<p>for setting up items such as dialogue boxes, by saving background pictures before new graphics are </p>
<p>displayed. They can be used to create “tiles” for all sorts of entertainment programs, such as visual </p>
<p>puzzles, as well as practical programs like identi-kits and architectural planners.</p>
<p><b>GET BLOCK</b></p>
<p><i>instruction: grab a screen Block into memory</i></p>
<p><b>Get Block</b> number,x,y,width,height</p>
<p><b>Get Block</b> number,x,y,width,height,mask</p>
<p>The GET BLOCK command is used to grab a rectangular area from the graphics on the current screen. </p>
<p>First specify a Block number from 1 up to 65535, then set the coordinates of the top left- hand corner </p>
<p>of the rectangle to be grabbed, followed by the number of pixels making up the width and height of </p>
<p>the Block.</p>
<p>An optional mask code can be added after these parameters. If this code is set to zero, the Block will </p>
<p>destroy and replace any graphics that used to occupy its position on screen. If the mask code is set to </p>
<p>1, the block is given a background mask, and colour zero becomes transparent.</p>
<p><b>PUT BLOCK</b></p>
<p><i>instruction: copy Block onto screen</i></p>
<p><b>Put Block</b> number</p>
<p><b>Put Block</b> number,<i>x,y</i></p>
<p><b>Put Block</b> number,<i>x,y,bit-planes</i></p>
<p><b>Put Block</b> number,<i>x,y,bit-planes,blitter mode</i></p>
<p>To   re-draw   a   Block   at   its   original   coordinates   on   the   current   screen,   simply   add   the   Block's </p>
<p>identification number after the PUT BLOCK command.</p>
<p>07.07.03</p>
<p>I</p>
<p>C</p>
<p>O</p>
<p>N</p>
<p>S</p>
<p>/</p>
<p>B</p>
<p>L</p>
<p>O</p>
<p>C</p>
<p>K</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Icons and Blocks</p>
<p>If you want to draw the Block at a new position, then add the new x,y-coordinates for the It left-hand </p>
<p>corner, after the Block number.</p>
<p>The   Amiga's   screen   is   divided   into   segments   known   as   “bit-planes”,   and   Blocks   are   normally </p>
<p>displayed using all the available screen bit-planes, which is a bit-pattern of %111111. Re-setting these </p>
<p>bit-planes can create numerous special effects, and various settings are dealt with at the beginning of </p>
<p>Chapter 6.2.</p>
<p><b>DEL BLOCK</b></p>
<p><i>instruction: delete a screen Block</i></p>
<p><b>Del Block</b></p>
<p><b>Del Block</b> number</p>
<p>To delete all new screen Blocks, the DEL BLOCK command is used. The memory these Blocks used is </p>
<p>returned to the main program automatically. If you only want to get rid of a single Block, follow the  </p>
<p>command with that Block's identification number.</p>
<p><b>HREV BLOCK</b></p>
<p><i>instruction: flip a Block horizontally</i></p>
<p><b>Hrev Block</b> number</p>
<p>This command reverses any numbered Block, by flipping it over its own horizontal axis.</p>
<p><b>VREV BLOCK</b></p>
<p><i>instruction: flip a Block vertically</i></p>
<p><b>Vrev Block</b> number</p>
<p>Similarly, VREV BLOCK is used to flip a block over its own vertical axis.</p>
<p><b>Compacted blocks</b></p>
<p>If   you   need   reminding   about   the   screen   compaction   memory-saving   techniques,   please   refer   to </p>
<p>SPACK and PACK, which are fully explained at the end of Chapter 6.2. The compaction system used </p>
<p>for the following commands is designed for speed as opposed to efficiency. They save less memory </p>
<p>than SPACK and PACK, but they are a lot faster!</p>
<p><b>GET CBLOCK</b></p>
<p><i>instruction: save and compact a screen Block</i></p>
<p><b>Get Cblock</b> number,x,y,width,height</p>
<p>The GET CBLOCK command is used to save and compact a rectangular area of graphics from the  </p>
<p>screen. These Blocks are often used to grab the area underneath dialogue boxes, so that after the  </p>
<p>dialogue has been completed, the screen can be rapidly restored to its original state.</p>
<p>Specify the Block number from 1 to 65535, followed by the x,y-coordinates of its top left-hand corner. </p>
<p>Then define the Block by giving its width and height, in pixels. Note that the x- coordinate, and the </p>
<p>width of the Block will be rounded to the nearest multiple of eight pixels.</p>
<p>07.07.04</p>
<p>I</p>
<p>C</p>
<p>O</p>
<p>N</p>
<p>S</p>
<p>/</p>
<p>B</p>
<p>L</p>
<p>O</p>
<p>C</p>
<p>K</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Icons and Blocks</p>
<p><b>PUT CBLOCK</b></p>
<p><i>instruction: display a compacted Block</i></p>
<p><b>Put Cblock</b> number</p>
<p><b>Put Cblock</b> number,<i>x,y</i></p>
<p>This command places the Block whose number is specified at its original screen coordinates. Optional </p>
<p>target coordinates can be added, in which case the Block will be unpacked and then drawn at the new  </p>
<p>position. Any new x-coordinate will also be rounded to the nearest 8-pixel boundary.</p>
<p><b>DEL CBLOCK</b></p>
<p><i>instruction: delete compacted Blocks</i></p>
<p><b>Del Cblock</b></p>
<p><b>Del Cblock</b> <i>number</i></p>
<p>The DEL CBLOCK instruction erases all compacted Blocks from memory, unless an individual Block </p>
<p>number is specified, in which case only that Block will be erased.</p>
<p>07.07.05</p>
<p>I</p>
<p>C</p>
<p>O</p>
<p>N</p>
<p>S</p>
<p>/</p>
<p>B</p>
<p>L</p>
<p>O</p>
<p>C</p>
<p>K</p>
<p>S</p>
</body>
</html>
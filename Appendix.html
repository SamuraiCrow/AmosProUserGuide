<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 5.2.7.2 (Linux)"/>
  <meta name="created" content="2017-10-03T08:02:59.609303422"/>
  <meta name="changed" content="2017-10-04T06:21:36.057566172"/>
</head>
<body>
<h1></h1>
<p>Appendix</p>
<p>14.A</p>
<p>Machine Code</p>
<p>14.B</p>
<p>AMOS Professional Run Time</p>
<p>14.C</p>
<p>PAL and NTSC</p>
<p>14.D</p>
<p>Extensions</p>
<p>14.E</p>
<p>Memory Bank Structures</p>
<p>14.F</p>
<p>Copper Lists</p>
<p>14.G</p>
<p>Command Index</p>
<p>14.H</p>
<p>AMOS PD Library</p>
<p>14.I</p>
<p>Future Support</p>
<h1 style="page-break-before:always; "></h1>
<p>App. A: Machine Code</p>
<p>AMOS Professional Basic includes a range of commands that provide the advanced programmer with </p>
<p>total access to the inner workings of the Amiga's hardware. In experienced hands these instructions </p>
<p>can be invaluable. But be warned, if you are not completely sure what you are doing, these commands </p>
<p>may be lethal for your programs!</p>
<p>All the important hardware routines are built in to AMOS Professional Basic, allowing you to exploit </p>
<p>the Amiga's full potential using the simple commands already detailed in this User Guide. In other </p>
<p>words, if you prefer to opt for the simple life, you are free to ignore this machine code section </p>
<p>altogether. You certainly do not need these functions to create superb computer games.</p>
<p><b>Converting numbers</b></p>
<p>Human beings normally count in multiples of ten, based on the number of fingers most of us possess. </p>
<p>These “decimal” numbers are expressed by a group of characters from 0 to 9, and the relative position </p>
<p>of these “digits” determines whether a character represents the number of ones, or tens, or millions, </p>
<p>and so on.</p>
<p>So in the decimal system, the number 1234 is equivalent to:</p>
<p>1*1000 + 2*100 + 3*10 + 4</p>
<p>Computers do not posses ten fingers, but count in a “binary” system instead, which means that each </p>
<p>digit can only be in one of two possible states, non-existent or existent. This is represented by either a </p>
<p>0 or a 1.</p>
<p>As with the decimal system, the meaning of a binary digit depends entirely on its position in a binary </p>
<p>number. Both systems rely on the fact that the value of digits change depending on their position </p>
<p>from right to left in the number. The human system uses a base of ten, but the computer prefers a base </p>
<p>of 2. So as you move from right to left, the values of binary numbers increase by a factor of two. In </p>
<p>other words, the digit at the extreme right of a binary number represents the number of ones, the next </p>
<p>one along represents the number of twos, then fours, eights, and so on.</p>
<p>Examine the number 15. In the decimal system this is depicted as follows:</p>
<p>1*10 + 5</p>
<p>But in binary, the same number is stored like this:</p>
<p>1*8 + 1*4 + 1*2 + 1</p>
<p>Which can be written as follows:</p>
<p>1111</p>
<p>14.A.01</p>
<p>C</p>
<p>O</p>
<p>D</p>
<p>E</p>
<h1 style="page-break-before:always; "></h1>
<p>Machine Code</p>
<p><b>BIN$</b></p>
<p><i>function: convert a decimal value into a string of binary digits</i></p>
<p>b$=<b>Bin$</b>(value)</p>
<p>b$=<b>Bin$</b>(value,digits)</p>
<p>This is the function that converts a decimal number or expression into the equivalent string of binary </p>
<p>digits. The binary number that is returned will automatically have a leading % (per cent) character </p>
<p>added to it. This character acts as an introduction sign, to indicate that the number which follows it is </p>
<p>in binary notation, rather than the standard decimal system.</p>
<p>After the decimal value that is to be converted, an optional number between 1 and 31 can be added  </p>
<p>which sets the number of digits to be returned in the binary string. If this parameter is omitted, </p>
<p>AMOS Professional will express the value in the fewest possible digits, with no leading zeros. Here </p>
<p>are a few examples:</p>
<p>Print Bin$(5)</p>
<p>Print Bin$(10)</p>
<p>Print Bin$(255)</p>
<p>X$=Bin$(100) : Print X$</p>
<p>You may enter binary numbers directly, as part of an expression, providing that the % (per cent) </p>
<p>character is placed in front of your binary value. Such numbers will be converted into standard </p>
<p>decimal notation automatically. For example:</p>
<p>Print %101</p>
<p>Print %1010</p>
<p>Print %11111111</p>
<p>X$=Bin$(100) : Print Val(X$)</p>
<p>Certain functions make use of yet another system of counting. The Hexadecimal system counts in </p>
<p>units of 16 rather than ten, so a total of 16 different digits is needed to represent all the different </p>
<p>numbers. The digits from 0 to 9 are used as normal, but the digits from 10 to 15 are signified by the </p>
<p>letters A to F, as shown in the following table:</p>
<p><b>Hex </b></p>
<p>0</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>A</p>
<p>B</p>
<p>C</p>
<p>D</p>
<p>E</p>
<p>F</p>
<p><b>Decimal digit</b></p>
<p>0</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p><b>HEX$</b></p>
<p><i>function: convert a decimal value into a string of hexadecimal digits</i></p>
<p>h$=<b>Hex$</b>(value)</p>
<p>h$=<b>Hex$</b>(value,digits)</p>
<p>HEX$ converts numbers from the decimal system into a string of hexadecimal (Hex) digits. The </p>
<p>decimal   value   to   be   converted   is   specified   in   brackets.   The   hex   number   that   is   returned   will </p>
<p>automatically have a leading $ (dollar) character added to it.</p>
<p>14.A.02</p>
<p>C</p>
<p>O</p>
<p>D</p>
<p>E</p>
<h1 style="page-break-before:always; "></h1>
<p>Machine Code</p>
<p>This   character   acts   as   an   introduction   sign,   to   indicate   that   the   number   which   follows   it   is   in </p>
<p>hexadecimal notation, rather than the standard decimal system.</p>
<p>After the decimal value that is to be converted, an optional number can be added which sets the </p>
<p>number of digits to be returned in the hex string. If this parameter is omitted, AMOS Professional will </p>
<p>return the value in the fewest possible digits needed to express the hex number. For example:</p>
<p>Print Hex$(100)</p>
<p>Print Hex$(100,3</p>
<p>)</p>
<p>HEX$ is often used with the COLOUR function to display the precise mixture of Red, Green and Blue </p>
<p>components in a particular colour, as follows:</p>
<p>Print Hex$(Colour(2))</p>
<p>Hexadecimal notation is ideal for handling large numbers such as addresses, and it may be entered </p>
<p>directly in any AMOS Professional Basic expression. The $ (dollar) character must be placed in front </p>
<p>of   hex   numbers,   and   they   will   be   converted   into   standard   decimal   notation   automatically.   For </p>
<p>example:</p>
<p>Print $64</p>
<p>Print $A</p>
<p>Do not confuse the use of the  <b>leading</b>  $ character for a hex number with the use of a  <b>trailing</b>  $ </p>
<p>character for a string. $A is a hexadecimal number, but A$ is a variable!</p>
<p><b>Manipulating memory</b></p>
<p>A “byte” is a single unit of data, resident at an address in memory. If no unit of data exists at a </p>
<p>particular address, the address remains empty. Each byte can hold a number between 0 and 255. Each </p>
<p>byte is made up of eight smaller units of memory called “bits”, and a bit is the smallest unit of data </p>
<p>that can be represented in a computer's memory by a 1 or a 0.</p>
<p><b>PEEK</b></p>
<p><i>function: read a byte from an address</i></p>
<p>byte=<b>Peek</b>(address)</p>
<p>The PEEK function returns a single 8-bit byte from an address in memory.</p>
<p><b>POKE</b></p>
<p><i>instruction: change a byte at an address</i></p>
<p><b>Poke</b> address,number</p>
<p>The POKE  command moves a number  from 0 to  255  into  the memory location  at  the  specified </p>
<p>address. Take great care with this instruction! Only POKE addresses that you completely understand, </p>
<p>such as the contents of an AMOS Professional memory bank. Random poking will provoke your </p>
<p>Amiga into taking horrible reprisals!</p>
<p>14.A.03</p>
<p>C</p>
<p>O</p>
<p>D</p>
<p>E</p>
<h1 style="page-break-before:always; "></h1>
<p>Machine Code</p>
<p><b>DEEK</b></p>
<p><i>function: read two bytes from an even address</i></p>
<p>word=<b>Deek</b>(address)</p>
<p>DEEK reads a two-byte “word” at a specified address. This address must be even, or an address error </p>
<p>will be generated.</p>
<p><b>DOKE</b></p>
<p><i>instruction: change a two-byte word at an even address</i></p>
<p><b>Doke</b> address,number</p>
<p>Use the DOKE command to copy a two-byte number between 0 and 65535 into the memory location </p>
<p>at   a   specified   even   address.   Only   DOKE   into   places   where   you   are   certain   of   safety,   because </p>
<p>indiscriminate use of this command will almost certainly crash your Amiga!</p>
<p><b>LEEK</b></p>
<p><i>function: read four bytes from an even address</i></p>
<p>word=<b>Leek</b>(address)</p>
<p>The LEEK function returns a four-byte “long word” stored at the specified <b>even</b> address. The result </p>
<p>will be in exactly the same format as a standard AMOS Professional integer. This may result in </p>
<p>negative values being returned in certain circumstances, such as if bit 31 of your number is set to 1. </p>
<p>The correct value can be calculated by making use of DEEK, then loading the result into a floating  </p>
<p>point number, like this:</p>
<p>A=$FFFFFFFE</p>
<p>Print Leek(Varptr(A))</p>
<p>A#=Deek(Varptr(A))*65535.0+Deek(Varptr(A)+2)</p>
<p>Print A#</p>
<p><b>LOKE</b></p>
<p><i>instruction: change a four-byte word at an even address</i></p>
<p><b>Loke</b> address,number</p>
<p>LOKE copies a four-byte number into the memory location at a specified address. As before, the </p>
<p>address must be an even location, and this command must be used with the greatest of care to avoid </p>
<p>crashing the computer.</p>
<p><b>POKE$</b></p>
<p>instruction: poke a string of characters into memory</p>
<p><b>Poke$</b> address, string$</p>
<p>Use the POKE$ command to take a source string and copy it directly to a chosen memory location, </p>
<p>one character at a time. The address parameter holds the address of the first byte to be loaded with </p>
<p>the new string data.</p>
<p>14.A.04</p>
<p>C</p>
<p>O</p>
<p>D</p>
<p>E</p>
<h1 style="page-break-before:always; "></h1>
<p>Machine Code</p>
<p>The copying operation will continue until the last character of the source string is reached, and the </p>
<p>end address will be as follows:</p>
<p>address+Len(string$)-1</p>
<p>The address may be odd or even, and can be anywhere in the Amiga's memory space. As always, </p>
<p>mistakes with the address can crash your computer! Here is an example of the correct technique:</p>
<p>Reserve As Data 10,1000: Rem Reserve a memory bank</p>
<p>NAME=Start(10)-8 : Rem Get the address of the name</p>
<p>T$=“Testbank” : Rem Choose a new name of up to 8 characters</p>
<p>Poke$ NAME,Left$(T$,8) : Rem Poke the first 8 characters into the name</p>
<p><b>PEEK$</b></p>
<p><i>function: read a string of characters from memory</i></p>
<p>string$=<b>Peek$</b>(address,length)</p>
<p>string$=<b>Peek$</b>(address,length,stop$)</p>
<p>PEEK$ reads the maximum number of characters specified in the length parameter, into a new string. </p>
<p>If this is not a sensible value, the length is assumed to be 65500. The address parameter is the location </p>
<p>of the first character to be read.</p>
<p>There is an optional stop$ parameter, and if this is included, AMOS Professional will stop in its tracks </p>
<p>the moment a specified stop$ character is encountered in the memory area. You will then be left with </p>
<p>a string of characters up to the final stop$. Here is an example using PEEKS:</p>
<p>Reserve As Data 10,1000 : Rem Reserve a memory bank</p>
<p>NAME=Start(10)-8 : Rem Get the address of the name</p>
<p>Print Peek$(NAME,8)</p>
<p><b>COPY</b></p>
<p><i>instruction: copy a memory block</i></p>
<p><b>Copy</b> start,finish <b>To</b> destination</p>
<p>The COPY command is used to move large sections of the Amiga's memory rapidly from one place to </p>
<p>another. Specify the start and finish locations of the data to be moved, then give the destination of the </p>
<p>position of memory area which is to be loaded with the data. Addresses may be odd or even, and </p>
<p>special care should be taken to ensure that the destination area points to somewhere safe!</p>
<p><b>FILL</b></p>
<p><i>instruction: fill memory block with the contents of a variable</i></p>
<p><b>Fill</b> start <b>To</b> finish,pattern</p>
<p>The FILL instruction packs an area of memory specified from start to finish. This area is filled with  </p>
<p>multiple copies of a specified four-byte pattern. The addresses of the start and finish determine the </p>
<p>size and position of the memory block, and they must both be even.</p>
<p>14.A.05</p>
<p>C</p>
<p>O</p>
<p>D</p>
<p>E</p>
<h1 style="page-break-before:always; "></h1>
<p>Machine Code</p>
<p>The fill pattern is a standard four-byte integer, but if you need to fill the area with multiple copies of a </p>
<p>single byte, this value can be calculated as follows, where V will contain the required value of your fill </p>
<p>command:</p>
<p>BYTE=255 : Rem This can be any number from 0 to 255</p>
<p>V=0</p>
<p>Poke Varptr(V),BYTE : Poke Varptr(V)+1,BYTE</p>
<p>Poke Varptr(V)+2,BYTE : Poke Varptr(V)+3,BYTE</p>
<p>Print V</p>
<p><b>HUNT</b></p>
<p><i>function: find a string of characters in memory</i></p>
<p>first=<b>Hunt</b>(start </p>
<p><b>To</b></p>
<p> finish,s$)</p>
<p>HUNT is really a low level version of the familiar INSTR$ command. It searches the memory area </p>
<p>defined by the given start and finish addresses, looking for the first occurrence of the characters held  </p>
<p>in your specified string.</p>
<p>If the search is successful, the position of the first character in memory is returned, otherwise a value </p>
<p>of zero will be given. When using this function, take great care in selecting the start and finish points </p>
<p>for the search.</p>
<p><b>Direct access to variables</b></p>
<p><b>VARPTR</b></p>
<p><i>function: read the address of a variable</i></p>
<p>address=<b>Varptr</b>(variable)</p>
<p>This useful function returns the location of any AMOS Professional variable in the Amiga's memory. </p>
<p>Programmers familiar with C should find it very similar  to the &amp; (ampersand) operator in that </p>
<p>language.</p>
<p>VARPTR provides back-door access to your variables, and with careful use you are able to get to them </p>
<p>directly,without having to rely on standard routines. This is especially valuable with procedures, </p>
<p>because if procedures are loaded with the  <b>address</b>  of a variable instead of its actual value, that </p>
<p>variable can be changed from <b>inside</b> the procedure. For example:</p>
<p>TEST=0</p>
<p>Rem Correct use of square brackets</p>
<p>ANSWER[Varptr(Test)] : Rem Load ADDRESS of variable into AD parameter</p>
<p>Print TEST</p>
<p>Procedure ANSWER[AD]</p>
<p>Loke AD,42 : Rem Copy new value into variable, by back door!</p>
<p>End Proc</p>
<p>There should be few problems encountered when reading the variables, but changing them is a very </p>
<p>hazardous process!</p>
<p>14.A.06</p>
<p>C</p>
<p>O</p>
<p>D</p>
<p>E</p>
<h1 style="page-break-before:always; "></h1>
<p>Machine Code</p>
<p>The slightest error made in your address calculations will crash AMOS Professional, so it is vital to  </p>
<p><b>save your programs before attempting to change your variables in this way.</b></p>
<p>With   machine   code  programs,   VARPTR  can  also   be  used   to  manipulate  entire  strings   or   arrays </p>
<p>directly. Each type of variable is stored in its own individual format, as listed below.</p>
<p><b>Integers</b> are held as a simple group of four bytes. They can be read from your Basic program using </p>
<p>LEEK, and altered by LOKE. Here is an example of this (dangerous) method:</p>
<p>ANSWER=43 : Rem Load a variable</p>
<p>AN=Varptr(ANSWER) : Rem Find address of variable</p>
<p>Loke AN,LEEK(AN)-1 : Rem Equivalent to ANSWER=ANSWER-1</p>
<p>Print ANSWER</p>
<p><b>Floating   point   numbers</b>  are   stored   as   four   bytes,   using   the   special   Fast-Floating   point   format. </p>
<p>However, if DOUBLE PRECISION is being used, floating point numbers are held as a group of eight </p>
<p>bytes in IEEE double precision format.</p>
<p><b>Strings</b> are stored' as a series of characters in standard ASCII format. The address given by VARPTR </p>
<p>points to the first character in the string, and this can be examined with PEEK or replaced using </p>
<p>POKE. Note that the length of the string is contained in two bytes immediately before the string. This </p>
<p>means that it can be loaded into Basic using a line like this:</p>
<p>Print Deek(Varptr(A$)-2) : Rem Equivalent to Print Len(A$)</p>
<p>One application of this function is to return the ASCII value of a single character in an AMOS </p>
<p>Professional string.</p>
<p>The standard method is to make use of the ASC and M1D$ functions, like this:</p>
<p>A=Asc(Mid$(A$),C,1) : Rem Return ASCII code of character C in A$</p>
<p>Using VARPTR, that could be replaced by the following line:</p>
<p>A=Peek(Varptr(A$)+C)</p>
<p>To avoid danger, special precautions must be taken before new values are poked into a string. During </p>
<p>the course of a program, the address of a string may change many times, so it is vital to load the  </p>
<p>current address of a string using VARPTR immediately before that string is used.</p>
<p>AMOS Professional regularly reorganises all strings in memory, using a “garbage collection” process. </p>
<p>This frees valuable space needed for variables, and is essential for the smooth running of the system. </p>
<p>But if you wish to pass the address of a string as a procedure garbage collection can play havoc. The  </p>
<p>obvious solution is to collect the garbage <b>before</b> the address is calculated, using a simple line like this:</p>
<p>X=Free</p>
<p>14.A.07</p>
<p>C</p>
<p>O</p>
<p>D</p>
<p>E</p>
<h1 style="page-break-before:always; "></h1>
<p>Machine Code</p>
<p>The address of the string can now be established, and passed to the procedure. So providing strings  </p>
<p>themselves are not used in the procedure, you should remain safe.</p>
<p>Another hazard can be encountered if you try to POKE values straight into a string.</p>
<p>Try</p>
<p>A$=“123456789”: Rem Define a string of characters</p>
<p>For C=0 To Len(A$)-1</p>
<p>AD=Varptr(A$) : Rem Get the address</p>
<p>V=Peek(AD+C) : Rem Get Ascii value of current element</p>
<p>Poke AD+C,V+1 : Rem Add 1 to it</p>
<p>Next C</p>
<p>Print A$</p>
<p>When   you   return   to   the   Editor,   you   will   discover   that   your   listing   has   been   changed!-  AMOS </p>
<p>Professional is trying to save space by storing your string in the program listing, rather than the </p>
<p>standard variable “buffer”. This problem can be solved by loading the first character into the start of </p>
<p>the string, then adding the remaining characters later. Here is how:</p>
<p>A$=“1” : Rem Set up the first character</p>
<p>A$=A$+“23456789” : Rem Now add remaining characters</p>
<p>This fools AMOS Professional into creating a separate copy of the string in the variable buffer.</p>
<p><b>Numerical arrays</b> are stored as a simple list of values, with each dimension stored in turn. Look at the </p>
<p>following array:</p>
<p>Dim TEST(3,3)</p>
<p>That array is held in the following order:</p>
<p>0,0 0,1 0,2 0,3</p>
<p>1,0 1,1 1,2 1,3</p>
<p>2,0 2,1 2,2 2,3</p>
<p>3,0 3,1 3,2 3,3</p>
<p>So to return the address of the <b>first</b> value of the array, you would use this:</p>
<p>Varptr TEST(0,0)</p>
<p><b>String arrays</b> are more complex, because their length needs to change whenever one of their elements </p>
<p>is assigned to a new value. The only way of ensuring total safety is to avoid them altogether! If you </p>
<p>ignore this advice and try to access them using VARPTR, you are risking real danger.</p>
<p>14.A.08</p>
<p>C</p>
<p>O</p>
<p>D</p>
<p>E</p>
<h1 style="page-break-before:always; "></h1>
<p>Machine Code</p>
<p><b>Manipulating bits</b></p>
<p><b>ROL</b></p>
<p><i>instruction: rotate left</i></p>
<p><b>Rol.B</b> number,bin value</p>
<p><b>Rol.W</b> number,bin value</p>
<p><b>Rol.L</b> number,bin value</p>
<p>ROL is the AMOS Professional Basic version of the ROL command available from 68000 assembly </p>
<p>language. It takes the given binary value, and rotates it the specified number of places to the left. The </p>
<p>value can be a normal variable, or an expression. Expressions will be treated as a memory location,  </p>
<p>and AMOS Professional will change the value at the address of the result.</p>
<p>This command allows instant rotation of any part of the Amiga's memory, and it must be used with </p>
<p>extreme caution! If variables are confused with bit numbers, your machine will crash. Take heed of </p>
<p>the next lines:</p>
<p>A=1</p>
<p>Rol.l 1,A : Rem This is fine</p>
<p>Rol.l A,1 : Rem This is lethal. DO NOT DO IT!</p>
<p>There are three forms of the ROL instruction:</p>
<p>ROL.B rotates the first eight bits of the value</p>
<p>ROL.W rotates the bottom 16 bits of the value</p>
<p>ROL.L rotates the entire number</p>
<p>The ROL command is invaluable as a rapid method of multiplying and positive number by a power </p>
<p>of two, like this:</p>
<p>B=1</p>
<p>Rol.l 2,B</p>
<p>Print B</p>
<p>Here is an example routine:</p>
<p>Curs Off : Locate 0,20 : Centre “Press a key to ROL the number”</p>
<p>Locate 0,0 : Print “Binary version”</p>
<p>Locate 0,4 : Print “Decimal version”</p>
<p>B=1 : Rem Set initial value</p>
<p>Do</p>
<p>Locate 0,2: Print Bin$(B,32) : Rem Display number in binary</p>
<p>Locate 0,6: Print B;“         ”; : Rem Nine spaces</p>
<p>Wait Key</p>
<p>Rol.l 1,B : Rem Try ROL.W and ROL.B too</p>
<p>Loop</p>
<p>14.A.09</p>
<p>C</p>
<p>O</p>
<p>D</p>
<p>E</p>
<h1 style="page-break-before:always; "></h1>
<p>Machine Code</p>
<p><b>ROR</b></p>
<p><i>instruction: rotate right</i></p>
<p><b>Ror.B</b> number,bin value</p>
<p><b>Ror.W</b> number,bin value</p>
<p><b>Ror.L</b> number,bin value</p>
<p>The ROR commands are similar to ROL, except they rotate numbers from left to right. As before, the </p>
<p>number of places to be moved must be set, followed by a variable or an expression. If an expression is </p>
<p>used, it will be treated as the address of your value. ROR can be used as a fast way of dividing any  </p>
<p>positive number by a power of two, like this:</p>
<p>A=8</p>
<p>Ror.l 1,A</p>
<p>Print A</p>
<p><b>BTST</b></p>
<p><i>function: test a bit</i></p>
<p>bit=<b>Btst</b>(number,value)</p>
<p>The BTST function tests a single binary bit in a given value. Specify the number of the bit to be tested,  </p>
<p>from 0 to 31, then give the chosen variable or expression. If the given value is an expression, it will be  </p>
<p>used as an address, so the bit will then be checked at LEEK(value) instead. Note that only bits 0 to 7  </p>
<p>can be tested by this system, and that AMOS Professional will take your bit number and perform an </p>
<p>automatic AND operation with 7, to ensure that it lies in the correct range.</p>
<p>If the test is successful, a value of -1 (True) is returned, otherwise a zero (False) is given. For example:</p>
<p>B=%1010</p>
<p>Print Btst(3,B)</p>
<p>Print Btst(2,B)</p>
<p><b>BSET</b></p>
<p><i>instruction: set a bit to 1</i></p>
<p><b>Bset</b> position,value</p>
<p>The BSET command sets a bit to 1. Specify the bit by giving its position in a variable or an expression. </p>
<p>If an expression is used, it will be treated as an address of a value in the Amiga's memory. If the bit </p>
<p>number and the variable are given in the wrong order, your computer will crash!</p>
<p><b>BCHG</b></p>
<p><i>instruction: toggle a bit</i></p>
<p><b>Bchg</b> position,value</p>
<p>This instruction flips a binary bit from 0 to 1, or from 1 to 0, as appropriate.</p>
<p>14.A.10</p>
<p>C</p>
<p>O</p>
<p>D</p>
<p>E</p>
<h1 style="page-break-before:always; "></h1>
<p>Machine Code</p>
<p>As usual, the bit is specified by giving the number of its position, followed by either a variable or </p>
<p>expression. If the value is an expression, it is assumed to be an address, and great care should be </p>
<p>taken.</p>
<p><b>BCLR</b></p>
<p><i>instruction: clear a bit</i></p>
<p><b>Bclr</b> number,value</p>
<p>The BCLR command clears a bit by setting it to zero. The bit number can be from 0 to 31, and </p>
<p>pinpoints the single binary digit to be cleared. If the value is an expression, it will be used as an </p>
<p>address in memory.</p>
<p><b>Using assembly language</b></p>
<p>AMOS Professional exploits the most useful machine code routines and transforms them into simple </p>
<p>Basic commands. Even if you are an experienced machine code programmer, you will have to work </p>
<p>very hard to better the speed and range of AMOS Professional.</p>
<p>Even though assembly language is hazardous and you are best advised to avoid it, there are a few  </p>
<p>routines which could be improved by its use. So for this reason, you are provided with several </p>
<p>methods of accessing machine code directly from AMOS Professional Basic. These features are strictly </p>
<p>for experts, and should be ignored by anyone not familiar with assembly language.</p>
<p><b>Machine code procedures</b></p>
<p>The easiest option for exploiting assembly language is to install machine code directly into an AMOS </p>
<p>Professional procedure. These procedures can be saved and loaded using standard commands, and </p>
<p>then executed from the Basic program simply by typing their name! Apart from the fact that it cannot </p>
<p>be listed on screen, the only effective difference between a machine code procedure and its Basic </p>
<p>equivalent is speed.</p>
<p>Machine code procedures are completely compatible with the AMOS Compiler, which will not only </p>
<p>run most of your programs at double speed, but also compact them to a fraction of their original size. </p>
<p>This means that if you decide to compile your programs at a later date, you will not need to alter your </p>
<p>assembly language at all. The following points should be noted before using an assembler:</p>
<p>•</p>
<p>Routines should be re-locatable, able to run under CLI and should end with a simple RTS </p>
<p>instruction.</p>
<p>•</p>
<p>The only limit to the size of the machine code is the amount of available memory. However, </p>
<p>only the <b>first</b> CODE segment should be used for programs. The contents of any other segment </p>
<p>will be completely ignored!</p>
<p>•</p>
<p>If   memory   is   reserved   using   the  Amiga   system   functions,   remember   to   return   reserved </p>
<p>memory to the memory pool after use. AMOS Professional cannot be expected to know or care </p>
<p>what you are doing!</p>
<p>•</p>
<p>A procedure <b>will be moved</b> in memory every time a line is entered via the Editor. This means </p>
<p>that if an interrupt is attached to the routine, it <b>must</b> be removed before anything in the Basic </p>
<p>program is changed, otherwise the Amiga will crash!</p>
<p>14.A.11</p>
<p>C</p>
<p>O</p>
<p>D</p>
<p>E</p>
<h1 style="page-break-before:always; "></h1>
<p>Machine Code</p>
<p>•</p>
<p>When   the   routine   i's   called   from  AMOS   Professional   Basic,   certain   registers   will   contain </p>
<p>valuable information. Register  <b>A3</b>  will hold the parameter list. Register A5 will contain the </p>
<p>AMOS Professional data zone, which allows access to many internal functions directly from </p>
<p>the machine code program.</p>
<p>•</p>
<p>Although routines can alter any register, the <b>A7</b> stack should be left unchanged. Also note that </p>
<p>registers A3 to A6 will not be returned in AREG functions.</p>
<p><b>Creating a machine code language procedure</b></p>
<p>Machine code procedures are installed using the [Inset Program] option from the [Editor/Procedures] </p>
<p>menu. The following steps should be followed:</p>
<p>Create a dummy procedure from the AMOS Professional Editor, like this:</p>
<p>Procedure _MACHINE[A,A$]</p>
<p>End Proc</p>
<p>Existing closed procedures may also be used for this purpose, and it is perfectly legal to update a </p>
<p>routine after the machine code program has been re-assembled.</p>
<p>•</p>
<p>Position the text cursor inside the empty procedure.</p>
<p>•</p>
<p>Select [Insert Program] from the menu. You will now be prompted with a standard AMOS </p>
<p>Professional file selector.</p>
<p>•</p>
<p>Select the machine language program from the disc. It must be a normally assembled machine </p>
<p>language  which  be  run  under   CLI.  A  Workbench   program   or   other   commercial   program </p>
<p>cannot be inserted into a procedure. If this advice is ignored, your Amiga will crash when such </p>
<p>a program is executed! The code must be PC relative, because AMOS Professional will ignore </p>
<p>any relocation information in the file. The code must use a single segment only, because AMOS </p>
<p>Professional will only load the first CODE segment into memory.</p>
<p>•</p>
<p>AMOS Professional will now close the procedure and insert the selected machine language </p>
<p>routine into memory. Any existing Basic instructions in the procedure will be removed!</p>
<p>Once the machine code is installed in this manner, it will be called automatically whenever the new </p>
<p>procedure is run from AMOS Professional Basic.</p>
<p><b>Communicating with a machine code procedure</b></p>
<p>There are two methods of exchanging information with a machine code procedure.</p>
<p>With the first method, values are loaded into the appropriate Address and Data registers, before the </p>
<p>procedure is called using the AREG and DREG functions. For example:</p>
<p>Dreg(0)=1 : Dreg(1)=Varptr(A$) : _MACHINE</p>
<p>Procedure _MACHINE</p>
<p>14.A.12</p>
<p>C</p>
<p>O</p>
<p>D</p>
<p>E</p>
<h1 style="page-break-before:always; "></h1>
<p>Machine Code</p>
<p>Note that AREG(3) to AREG(6) will  <b>not</b>  be transferred to the routine. These registers cannot be </p>
<p>changed,   as   they   are   used   to   store   important   system   information.   To   return   values   to   AMOS </p>
<p>Professional Basic, AREG and DREG can be used to read the contents of the Address and Data </p>
<p>registers, after the procedure has been called.</p>
<p>The second alternative method is much neater. Values are entered using normal parameters. As usual, </p>
<p>a list of parameters is specified as part of the procedure definition, like this:</p>
<p>Rem Use no parameters but take info directly from AREG and DREG </p>
<p>values</p>
<p>Procedure _MACHINE0</p>
<p>Procedure _MACHINE1[A] : Rem Enter one integer into procedure</p>
<p>Procedure _MACH1NE2[A,B,C$] : Rem Get two integers and one string</p>
<p>The   values   of   the   parameters   are   pushed   onto   the   Parameter   stack,   pointed   to   by   A3.   These </p>
<p>parameters are stored in reverse order, and are four bytes in length.</p>
<p>_MACHINE1 will grab the parameters like this:</p>
<p>Move.l (a3)+,d0</p>
<p>_MACHINE2 will grab the parameters as follows:</p>
<p>; Grab the string. Each string is stored at an EVEN address,</p>
<p>; starting with the length of the string, and then the string itself</p>
<p>Move.l (a3)+,a2</p>
<p>* Address of the string</p>
<p>Move.w (a2)+,d2</p>
<p>* Length of the string</p>
<p>; A2 now points to the first character</p>
<p>; Grab the two integers</p>
<p>Move.l (a3)+,d1</p>
<p>* Grab “B”</p>
<p>Move.l (a3)+,d0</p>
<p>* Grab “A”</p>
<p>The AMOS Professional stack works in the same way as a conventional stack, so although anything </p>
<p><b>below</b> can be changed, do not touch any values above the base address contained in A3. Also note </p>
<p>that the space available for the routine depends on the level of the procedure, so if it is called from the  </p>
<p>main program approximately 3k is available. This can be increased by a call to the SET STACK </p>
<p>command from AMOS Professional Basic.</p>
<p>To return values to AMOS Professional Basic, the value of DO is available from the PARAM function </p>
<p>automatically.</p>
<p><b>Calling machine code from an address or bank</b></p>
<p>There is another option for calling machine code directly from a memory bank or an </p>
<p>address.</p>
<p>14.A.13</p>
<p>C</p>
<p>O</p>
<p>D</p>
<p>E</p>
<h1 style="page-break-before:always; "></h1>
<p>Machine Code</p>
<p><b>PLOAD</b></p>
<p><i>instruction: load machine code directly into memory</i></p>
<p><b>Pload</b> “filename”,bank number</p>
<p>The PLOAD command reserves a memory bank and loads some machine code into it from disc. </p>
<p>Specify the filename that contains the machine code file on disc, followed by the number of a new  </p>
<p>memory bank to be reserved for the program. If the bank number is negative, the number will be </p>
<p>multiplied by -1, and the bank will be allocated using Chip memory.</p>
<p>Once machine code is loaded in this way, it is installed as a permanent memory bank, so whenever </p>
<p>the current program is saved, the machine code is stored too. Also note that the machine code file can </p>
<p>be saved onto disc as a standard “.Abk” file, then loaded directly into AMOS Professional Basic. After </p>
<p>PLOAD has performed its work, the memory bank can be executed immediately! The following </p>
<p>factors should be noted:</p>
<p>•</p>
<p>This file must consist of a standard piece of machine code, that can be run under CLI.</p>
<p>•</p>
<p>The program must be terminated by an RTS instruction.</p>
<p>•</p>
<p>Only the first CODE segment of the routine will be installed into memory.</p>
<p>•</p>
<p>Any attempt to load a commercial program using this technique will probably crash your </p>
<p>Amiga</p>
<p><b>CALL</b></p>
<p><i>instruction: execute a machine code program from memory</i></p>
<p><b>Call</b> address</p>
<p><b>Call</b> address,<i>parameters</i></p>
<p><b>Call</b> bank</p>
<p><b>Call</b> bank,<i>parameters</i></p>
<p>The CALL instruction is used to run a machine code program straight from the Amiga's memory. You </p>
<p>can specify either an absolute memory location or the number of a memory bank, previously installed </p>
<p>using the PLOAD command.</p>
<p>On entry to the program, registers D0 to D7 and A0 to A2 will be loaded from values stored in the  </p>
<p>DREG  and  AREG  functions.   The  assembly   language  program  can  change  any   68000  registers  it </p>
<p>chooses. At the start of the routine, register A3 will point to the optional parameter list, which is </p>
<p>explained next, and A5 will contain the address of the AMOS Professional data zone. When the </p>
<p>routine has completed its task, you can return to Basic with a RTS.</p>
<p>After the memory location or bank number, a list of optional parameters may be given in the form of </p>
<p>a list of values. These values will be taken from the AMOS Professional Basic program and pushed </p>
<p>onto the A3 stack by the CALL command. They must be removed in reverse order, so the last value in  </p>
<p>the list will be the first on the stack. The format of a parameter depends on what type of variable they  </p>
<p>are, as follows:</p>
<p>14.A.14</p>
<p>C</p>
<p>O</p>
<p>D</p>
<p>E</p>
<h1 style="page-break-before:always; "></h1>
<p>Machine Code</p>
<p><b>Integers.</b> The parameter holds a long word, containing a normal AMOS Professional number. It can </p>
<p>be grabbed with a line such as this:</p>
<p>Move.l (a3)+,d0</p>
<p><b>Single precision numbers.</b> These are stored in Fast Floating Point format, and are held in one long </p>
<p>word. To load such a number into register d0, use the following:</p>
<p>Move.l (a3)+,d0</p>
<p><b>Double precision numbers.</b> These are stored in IEEE double precision format, and are held as two </p>
<p>long words. To load a double precision variable into registers d0 and dl, you could use this:</p>
<p>Move.l (a3)+,d0</p>
<p> * Top half </p>
<p>Move.l (a3)+,d1</p>
<p>* Bottom half</p>
<p>Strings. The stack contains the Address of the string in memory. All strings begin with a single word  </p>
<p>that holds their length. For example:</p>
<p>; Grab the string. Each string is stored at an EVEN address,</p>
<p>; starting with the length of the string, and then the string itself</p>
<p>Move.l (a3)+,a2</p>
<p>* Address of the string</p>
<p>Move.w (a2)+,d2</p>
<p>* Length of the string</p>
<p><b>AREG</b></p>
<p><i>reserved variable: pass values to and from 68000 address register</i></p>
<p>a=<b>Areg</b>(number)</p>
<p><b>Areg</b>(number)=a</p>
<p>AREG is a special array which is used to pass values to and from any of the 68000 processor's address  </p>
<p>registers. Specify the number of the register from 0 to 6, selected from either of the following two </p>
<p>groups:</p>
<p><b>A0,   Al,   A2.</b>  These   registers   can   be   read   from   AMOS   Professional   Basic,   and   changed   at   will. </p>
<p>Whenever a machine code program is run,  any new values will be transferred straight into the </p>
<p>relevant address register. For example:</p>
<p>Areg(0)=Varptr(A$) : Rem Load the address of A$ into A0</p>
<p>Areg(1)=Varptr(B(0,0)) : Rem Load the address of B(0,0) into Al</p>
<p><b>A3, A4, A5, A6.</b>  These are read-only registers. Any attempt to change their current contents will </p>
<p>generate an “illegal function call” error message.</p>
<p><b>DREG</b></p>
<p><i>reserved variable: pass value into 68000 data register</i></p>
<p>d=<b>Dreg</b>(number)</p>
<p><b>Dreg</b>(number)=d</p>
<p>DREG can be used to move values back and forth between AMOS Professional Basic and the </p>
<p>68000's Data registers, by specifying the number of a data register from 0 to 7.</p>
<p>14.A.15</p>
<p>C</p>
<p>O</p>
<p>D</p>
<p>E</p>
<h1 style="page-break-before:always; "></h1>
<p>Machine Code</p>
<p>This function can be thought of as an array which holds an exact copy of registers DO to D7. This </p>
<p>array is automatically moved into the Data registers, either by the CALL command or whenever a </p>
<p>machine code procedure is run. Once the routine has ended, the new contents of DO to D7 is copied </p>
<p>directly into the array, so that the results may be read directly from AMOS Professional programs. For </p>
<p>example:</p>
<p>Dreg(0)=10 : Rem Save 10 into DO</p>
<p>Print Dreg(0) : Rem Print the contents of DO</p>
<p>14.A.16</p>
<p>C</p>
<p>O</p>
<p>D</p>
<p>E</p>
<h1 style="page-break-before:always; "></h1>
<p>App. B: AMOS Professional Run Time</p>
<p>AMOS Professional has no need for a different run-only version of the main AMOS Professional </p>
<p>system, and this Chapter explains the simplicity of creating run-only discs.</p>
<p>If   you   are   familiar   with   the   original  AMOS   system,   you   may   be   expecting   to   find   the  AMOS </p>
<p>Professional equivalent of the separate run-only version of AMOS, called RAMOS. This allows you to </p>
<p>run   AMOS   programs   completely   independently   from   the   AMOS   package,   but   with   AMOS </p>
<p>Professional there is no necessity for RAMOS at all!</p>
<p>AMOS Professional can be regarded as three interlinked programs, namely the Editor, the Monitor </p>
<p>and the Interpreter. Obviously, the main element is the Interpreter, “AMOSPro”. The Interpreter can </p>
<p>be called along with the name of a program, without the Editor or Monitor, like this:</p>
<p>The program will be loaded along with the Interpreter, and executed. When the program has been </p>
<p>run, AMOS Professional will look for the “AMOSPro.Editor” file in the APSystem folder. If it is found, </p>
<p>the Editor will be loaded into memory. If the file is not found, you will be brought back to the </p>
<p>Workbench.</p>
<p><b>Run-only discs</b></p>
<p>To create a run-only disc, simply copy your AMOSPro System disc, and remove the following files  </p>
<p>from the APSystem folder:</p>
<p>AMOSPro.Editor</p>
<p>AMOSPro.Editor_Config</p>
<p>AMOSPro.Monitor</p>
<p>AMOSPro.Monitor_Resource</p>
<p>Please note that when booting, if AMOS Professional finds the “Autoexec.AMOS” file in the current </p>
<p>directory, this program will be run before the Editor is loaded.</p>
<p>Because the Editor is a separate program, the Interpreter is not only able to work without it, but can </p>
<p>also load it when a program is over, if necessary.</p>
<p><b>KILL EDITOR</b></p>
<p><i>instruction: remove the AMOS Professional Editor from memory</i></p>
<p><b>Kill Editor</b></p>
<p>The KILL EDITOR command unloads the AMOS Professional Editor from memory.</p>
<p>14.B.01</p>
<p>R</p>
<p>U</p>
<p>N</p>
<p>T</p>
<p>I</p>
<p>M</p>
<p>E</p>
<h1 style="page-break-before:always; "></h1>
<p>AMOS Professional Run Time</p>
<p>In order for this command to operate, it must be enabled in the Interpreter configuration file. Also, </p>
<p>please note that the current program cannot be an accessory if KILL EDITOR is to work and the </p>
<p>program cannot be a program that has been PRUNed by another program. Otherwise, for all other </p>
<p>programs, the following operations are performed when KILL EDITOR is called:</p>
<p>•</p>
<p>A “warm start” procedure is executed, saving the configuration of all programs currently in </p>
<p>memory.</p>
<p>•</p>
<p>This configuration and the current program is left in memory, but all other programs are </p>
<p>erased.</p>
<p>•</p>
<p>All Editor buffers and Editor programs are also removed from memory, leaving a run-only </p>
<p>memory configuration.</p>
<p>•</p>
<p>When the program is over, AMOS Professional will re-load the Editor with all of the data </p>
<p>concerning the last session, which may take a little time, but which will return you to exactly </p>
<p>the same status as before KILL EDITOR was called!</p>
<p>Remember that Kill Editor must be enabled from the [Set Editor] option in the [Config] menu for it to  </p>
<p>work.</p>
<p>You are reminded that the PRG STATE function can be used to establish how a particular program </p>
<p>was run. PRG STATE returns the current status of a program in the form of one of three possible </p>
<p>values.</p>
<p><b>Value</b></p>
<p><b>Meaning</b></p>
<p>0</p>
<p>The program was run under the AMOS Professional Interpreter</p>
<p>1</p>
<p>The program was run under a run-time environment</p>
<p>-1</p>
<p>The program has been compiled</p>
<p>14.B.02</p>
<p>R</p>
<p>U</p>
<p>N</p>
<p>T</p>
<p>I</p>
<p>M</p>
<p>E</p>
<h1 style="page-break-before:always; "></h1>
<p>App. C: PAL and NTSC</p>
<p><b>International television standard systems</b></p>
<p>With millions of Amigas is use all over the world, it is vital to ensure that programs written with the  </p>
<p>AMOS Professional system can operate in as many territories as possible. For historical reasons, </p>
<p>different standards of television systems have evolved in different territories, which creates a major </p>
<p>problem for computer programmers. For example, a “British” television set will work perfectly well </p>
<p>in Hong Kong and Ireland, but will fail to operate anywhere else in the world! That is because the UK </p>
<p>has adopted the PAL (I) standard, a third of the planet has adopted other PAL standards, half the </p>
<p>world uses the NTSC system, and the rest use another system called SECAM! Luckily the SECAM  </p>
<p>system is identical to PAL as far as AMOS Professional is concerned, so you need only be concerned  </p>
<p>with the differences between PAL and NTSC.</p>
<p>Fortunately, AMOS Professional is an international language, and is designed to work automatically </p>
<p>under the two major television standards that exist where the Amiga is marketed, namely PAL (all </p>
<p>standards) and NTSC. If you are serious about designing your programs for specific territories, there </p>
<p>is a list of world-wide standards at the end of this Appendix. Otherwise, rest assured that AMOS </p>
<p>Professional will take care of most Amiga users on this planet!</p>
<p>When AMOS Professional code is run on a system that differs from the one used by the original  </p>
<p>author of the program, it undergoes two obvious changes. These are the size of the screen display and </p>
<p>the speed at which the program runs. Here are the crucial differences between the two systems.</p>
<p><b>PAL versus NTSC</b></p>
<p>PAL updates images 50 times a second, and can theoretically display up to 312 lines on screen. The </p>
<p>actual limit will vary depending on your TV set or monitor, but it is likely to be about 270 lines.</p>
<p>NTSC  updates   images   60  times   a  second,   but   only   displays   a   maximum   of   256   lines,   which   is </p>
<p>normally restricted to 220 horizontal lines. This maximum restriction of 220 lines is also imposed on </p>
<p>the height of Sprites.</p>
<p>It might seem that PAL has a clear advantage over the NTSC system, but this is not necessarily so. </p>
<p>Although NTSC screens are about one fifth shorter than their PAL cousins, their faster updating time </p>
<p>provides a higher quality picture, which is brighter, more stable and more restful for the eyes. Here is </p>
<p>a synopsis of the compatibility problems between the two systems.</p>
<p><b>The display size</b></p>
<p>Supposing you have created a 320 wide by 256 high screen. Under the PAL system, the picture </p>
<p>occupies the entire display, but on NTSC, the bottom section of the screen is hidden from view. Any </p>
<p>error messages are not visible and wandering Objects are likely to fall from view, through the bottom  </p>
<p>of the screen. Fortunately, AMOS Professional provides a function to assess the situation.</p>
<p><b>DISPLAY HEIGHT</b></p>
<p><i>function: report maximum available screen height</i></p>
<p>height=<b>Display height</b></p>
<p>This function returns a value of 311 if you are in PAL mode, or 261 if an NTSC machine is  </p>
<p>being used.</p>
<p>14.C.01</p>
<p>P</p>
<p>A</p>
<p>L</p>
<p>/</p>
<p>N</p>
<p>T</p>
<p>S</p>
<p>C</p>
<h1 style="page-break-before:always; "></h1>
<p>PAL and NTSC</p>
<p>These   are   theoretical   maximum   heights,,   and   do   not   take   into   account   any   limitations   of   your </p>
<p>television or monitor. To be safe, 56 lines should be subtracted, giving the actual working screen </p>
<p>height. For example:</p>
<p>Screen Open 0,320,Display Height-56,16,Lowres</p>
<p>Print Display Height</p>
<p><b>Screen updating and running speeds</b></p>
<p>It   is   obviously   impossible   to   slow   down   an   NTSC   television,   just   for   the   benefit   of   AMOS </p>
<p>Professional! If you want your programs to work at the same speed in either mode, special action has </p>
<p>to be taken. Look at this routine:</p>
<p>For T=0 To 60*50</p>
<p>Wait Vbl</p>
<p>Next T</p>
<p>Accounting for the difference in updating speeds, that last example delays a program for exactly one </p>
<p>minute in PAL, but for only 50 seconds under NTSC. This is because the WAIT VBL command halts </p>
<p>the program for one fiftieth of a second on a PAL machine, but for only one sixtieth of a second for  </p>
<p>NTSC.</p>
<p>Because NTSC machines are faster,  <b>all</b>  AMOS Professional programs will speed up dramatically </p>
<p>when PAL versions are executed. Obviously this works the other way round as well, slowing down </p>
<p>NTSC programs when run under the PAL system.</p>
<p>Also, AMAL will run more quickly under NTSC, and there will be a noticeable increase in the speed  </p>
<p>of animation sequences.</p>
<p>The good news is that music speed is not affected by these alternative modes. The bad news is that </p>
<p>synchronised audio-visual sequences may well become out of step!</p>
<p>Even worse, what used to be a smoothly animated PAL display is likely to be transformed into a jerky </p>
<p>NTSC animation, that stops at random intervals. The cause of this is almost certainly the fact that you </p>
<p>are using loops for animation, graphic drawing, joystick tests, and so on, and that you assume they </p>
<p>will be completed at each turn of the loop. However, if there is only one sixtieth of a second to execute </p>
<p>the entire procedure instead of one fiftieth, the routine is overrunning its allotted time. This forces </p>
<p>AMOS Professional to wait for the next VBL, throwing your entire sequence out of synchronisation.</p>
<p>To cure such synchronisation problems, you must ensure that all routines can be accomplished within </p>
<p>the sixtieth of a second limit. This will guarantee that your program can run under either system, </p>
<p>albeit at slightly different speeds.</p>
<p>If you are moving Objects directly from AMOS Professional Basic, you should try using AMAL for </p>
<p>extra speed. Furthermore, if there are many Bobs on screen, replace the smaller, faster Bobs with </p>
<p>Sprites, and be prepared for some encouraging results!</p>
<p>14.C.02</p>
<p>P</p>
<p>A</p>
<p>L</p>
<p>/</p>
<p>N</p>
<p>T</p>
<p>S</p>
<p>C</p>
<h1 style="page-break-before:always; "></h1>
<p>PAL and NTSC</p>
<p><b>Restricting programs to a single mode</b></p>
<p>Many AMOS Professional programmers may decide to ignore these problems completely, satisfied </p>
<p>that their work will not be seen outside of their immediate circle of contacts, let alone outside of their  </p>
<p>country. However, this is not a professional attitude, and if you have any intention of reaching a </p>
<p>wider audience with your programming, there is nothing worse than allowing your work to fall apart </p>
<p>before the eyes of an unsuspecting user.</p>
<p>So, if compatibility problems are not to be ignored, they can at least be avoided. This is achieved by </p>
<p>adding a simple test at the start of a program, which will warn other users of potential problems, and </p>
<p>abort the program if it is run on an incompatible machine.</p>
<p><b>NTSC</b></p>
<p><i>function: identify NTSC or PAL machines</i></p>
<p>mode=<b>Ntsc</b></p>
<p>The NTSC function is provided to identify whether or not an NTSC machine is in use, and will return </p>
<p>a value of -1 (True) if this is so. Otherwise a value of zero (False) is given, when a PAL machine is  </p>
<p>identified. The following example gives an idea of its use, and similar routines are  <b>essential</b>  for </p>
<p>professional releases aimed at an international audience:</p>
<p>If Ntsc=0</p>
<p>Print “Sorry, PAL version only!”</p>
<p>Print “NTSC version coming soon!”</p>
<p>End</p>
<p>End If</p>
<p><b>Dual mode programs</b></p>
<p>Whereas synchronisation problems can be overcome, the difficulties caused by the two different sized </p>
<p>screens causes a bigger problem. The smaller working area of NTSC displays has to be taken into </p>
<p>account at the beginning of your program. To open a perfect screen in either display mode, you are </p>
<p>recommended to save the screen height and position as global variables, which may be set at the start </p>
<p>of a program, as follows:</p>
<p>Global YSIZE,YPOSITION</p>
<p>YSIZE=256 : YPOSITION=49</p>
<p>If Ntsc</p>
<p>YSIZE=200 : YPOSITION=55</p>
<p>End If</p>
<p>Screen Open 0,320,YSIZE,16,Lowres</p>
<p>Screen Display 0,,YPOSITION,,</p>
<p>NTSC users can easily provide their PAL cousins with a dormant screen area at the bottom of the  </p>
<p>display.</p>
<p>To   return   the   complement,   PAL  users   should   restrict   the   size   of   their   menus,   activity   buttons, </p>
<p>dialogue boxes, and similar features, to no more than a quarter of the total screen area.</p>
<p>14.C.03</p>
<p>P</p>
<p>A</p>
<p>L</p>
<p>/</p>
<p>N</p>
<p>T</p>
<p>S</p>
<p>C</p>
<h1 style="page-break-before:always; "></h1>
<p>PAL and NTSC</p>
<p>Even better practice is to use pull-down menus rather than dialogue boxes. Before “releasing” a </p>
<p>program, you should simulate an NTSC screen by changing a simple screen variable, and checking </p>
<p>that everything appears to be in order.</p>
<p>An examination of the Object Editor and <b>all</b> of the ready-made AMOS Professional HELP programs </p>
<p>will show how they adapt themselves to the current display mode automatically!</p>
<p>Certain   recent  Amiga   models   have   special   monitors   which   are   designed   to   accommodate   both </p>
<p>systems. For example, the A3000 can emulate both PAL and NTSC, and you should check your Amiga </p>
<p>manual for details. As far as</p>
<p>AMOS Professional is concerned, the current mode is dictated by the type of screen which occupies </p>
<p>the front of the display when the machine is booted. Supposing you have an A3000 in PAL mode, and </p>
<p>have set its preferences to NTSC. The Amiga will be in NTSC mode when the Workbench screen is the </p>
<p>front screen, but it will return to its default PAL mode as soon as another screen is brought forward.  </p>
<p>AMOS Professional relies on the current mode to establish the maximum display size, so if it is run  </p>
<p>from an NTSC Workbench, it will be in NTSC mode of 200 lines maximum, cycling at 60 hertz. </p>
<p>However, if you flip to Workbench by pressing [Amiga]+[A], and start another program which opens </p>
<p>a new screen, the A3000 will revert to PAL without informing AMOS Professional. This means that </p>
<p>when you return to AMOS Professional, the size of the display will be limited to 200 lines, but the </p>
<p>update frequency will be 50 hertz. A hybrid PAL/NTSC mode!</p>
<p>Nothing can prevent this, other than the purchase of a genuine NTSC machine!</p>
<p><b>International television standard systems</b></p>
<p>The following lists catalogue the different standard systems adopted in various territories around the </p>
<p>world.</p>
<p><b>PAL(I)</b></p>
<p>Gibraltar, Hong Kong, Malvinas, Republic of Ireland, United Kingdom</p>
<p><b>PAL(B/G/H)</b></p>
<p>Afghanistan,   Algeria,   Australia,   Bahrain,   Bangladesh,   Belgium,   Bosnia,   Brunei,   Central   African </p>
<p>Republic,   Denmark,   Equatorial   Guinea,   Ethiopia,   Finland,   Germany,   Ghana,   Greenland,   Iceland, </p>
<p>India,   Indonesia,   Jordan,   Kenya,   Kuwait,   Liberia,   Luxembourg,   Malaysia,   Maldives,   Malta, </p>
<p>Mozambique, Netherlands, New Zealand, Nigeria, Norway, Oman, Pakistan, Portugal, Qatar, Serbia, </p>
<p>Seychelles,   Sierra   Leone,   Singapore,   Spain,   Sri   Lanka,   Sudan,   Swaziland,   Sweden,   Switzerland, </p>
<p>Tanzania,   Thailand,   Yemen   Arab   Republic,   Turkey,   United   Arab   Emirates,   former   Yugoslavian </p>
<p>territories, Zambia.</p>
<p><b>NTSC(M)</b></p>
<p>Antigua   and   Barbuda,   Bahamas,   Barbados,   Belize,   Bermuda,   Bolivia,   Burma,   Canada,   Chile, </p>
<p>Colombia, Costa Rica, Cuba, Dominican Republic, Ecuador, Guatemala, Haiti, Honduras, Jamaica, </p>
<p>Japan, Kampuchea, Mexico, Micronesia, Nicaragua, Panama, Peru, Philippines, Puerto Rico, Saint </p>
<p>Christopher and Nevis, Saint Lucia, Samoa, South Korea, Surinam, Taiwan, Trinidad and Tobago, </p>
<p>United States of America, Venezuela.</p>
<p>14.C.04</p>
<p>P</p>
<p>A</p>
<p>L</p>
<p>/</p>
<p>N</p>
<p>T</p>
<p>S</p>
<p>C</p>
<h1 style="page-break-before:always; "></h1>
<p>PAL and NTSC</p>
<p><b>SECAM</b> </p>
<p>systems   that   are   immediately   compatible   with   the   built-in   PAL   setting   of   the  AMOS </p>
<p>Professional   facilities   have   been   adopted   by   France,   People's   Republic   of   China,   most   African </p>
<p>territories not listed above, most areas of the Commonwealth of Independent States (formally USSR) </p>
<p>and former Soviet satellite nations.</p>
<p>14.C.05</p>
<p>P</p>
<p>A</p>
<p>L</p>
<p>/</p>
<p>N</p>
<p>T</p>
<p>S</p>
<p>C</p>
<h1 style="page-break-before:always; "></h1>
<p>App. D: Extensions</p>
<p>With   over   six   hundred   powerful   instructions   in   the  AMOS   Professional   repertoire,   the   system </p>
<p>provides everything needed to produce commercial quality programs for the Amiga.</p>
<p>AMOS Professional programmers are able to exploit the system to its limits, but it is impossible to </p>
<p>predict the needs of every programmer for every occasion. In order to allow the system to evolve, and  </p>
<p>cater   for   every   possible   requirement,  AMOS   Professional   has   the   unique   ability   to   accept   extra </p>
<p>commands and integrate them into the existing system.</p>
<p>These additional features are called “extensions”, they are written in machine code, and they can be </p>
<p>permanently installed into AMOS Professional using [Set Editor Setup] from the Configuration Menu. </p>
<p>Once loaded,  they extend the power of the system even further, providing any number of new </p>
<p>instructions for the use of the professional programmer.</p>
<p>Extension commands are treated in exactly the same way as any of the built-in AMOS Professional </p>
<p>instructions, and they can return values, enter parameters and access the screen as normal.</p>
<p>You   have   undoubtedly   used   extension   commands   already.   For   example,   type   in   this   simple </p>
<p>instruction from Direct mode:</p>
<p>Bell</p>
<p>BELL is <b>not</b> a built-in command at all! In actual fact, it is part of a separate MUSIC extension, which </p>
<p>contains all of the music, sound and sample commands used by AMOS Professional. The full source </p>
<p>code for these instructions can be examined in the “AMOSPro_Tutorial:Extensions/Music.s” file.</p>
<p>The publishers have already produced a number of extremely powerful extension packages, such as </p>
<p>the  <i>AMOS Compiler</i>  and AMOS-3D, and expanded versions of these programs will enhance your </p>
<p>AMOS Professional program seven further!</p>
<p>Extension programming is well within the reach of most assembly language programmers, and help </p>
<p>is readily available to overcome most problems via the AMOS User group, details of which can be </p>
<p>found at the end of this User Guide.</p>
<p>For newcomers to assembly language programming, machine code procedures may provide easier </p>
<p>access to expanding the system, because these allow you to develop routines with the minimum of </p>
<p>effort and then use them immediately in AMOS Professional programs. After a little experience, you </p>
<p>should be able to expand these routines into fully working extensions.</p>
<p>AMOS has a very impressive history, and now AMOS Professional looks forward to an exciting </p>
<p>future. Writing original extensions will make you an important part of this development, and the time </p>
<p>to create the future is now!</p>
<p>14.D.01</p>
<p>E</p>
<p>X</p>
<p>T</p>
<p>E</p>
<p>N</p>
<p>S</p>
<p>I</p>
<p>O</p>
<p>N</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>App. E: Memory Bank Structures</p>
<p>The AMOS Professional package comes complete with an invaluable range of accessory programs, </p>
<p>allowing the serious programmer to generate all of the requirements needed to produce commercial </p>
<p>quality products. We have provided as much material as is possible on disc, but there is a finite limit </p>
<p>to the disc space  available.  To  be  blunt,  we  do  not  have  the  magnetic  resources  to cover   every </p>
<p>possibility   for   creative  AMOS   Professional   programming.   The   system   has   been   designed   to   be </p>
<p>infinitely accommodating, and it is our intention to expand and improve the core system to meet all </p>
<p>of your requirements.</p>
<p>After using AMOS Professional, you may well identify an area which has scope for a new accessory. </p>
<p>Perhaps you have a special interest in a music editor, or sound effects, or speech synthesis, graphic </p>
<p>tweening, DTP, in fact any aspects of enhancing the AMOS system. We are always <b>very</b> interested in </p>
<p>making contact with creative, innovative talent, that can take the AMOS Professional system to its </p>
<p>next phase of evolution. In other words, if you feel that you can create an important  <b> new</b>  AMOS </p>
<p>Professional accessory, you should submit it to us on disc, along with all relevant documentation.</p>
<p>But...</p>
<p>Before you can create such a vital accessory, you must understand the internal structure of the various </p>
<p>AMOS Professional memory banks. This will allow you to generate such banks  <b>directly</b> from your </p>
<p>AMOS Professional programs.</p>
<p>Much of the information in this Appendix is very technical, and it is likely to prove heavy going for </p>
<p>anyone who is not an experienced programmer. In order to exploit it successfully, you are going to </p>
<p>have to explore the Amiga's memory very carefully. There will only be one major  <b>warning</b>  in this </p>
<p>Appendix: if you make a mistake in the realms of memory bank manipulation, you will crash your </p>
<p>computer!</p>
<p>For   those   genuine   professional   programmers   who   are   about   to   persevere   with   innovation   and </p>
<p>exploitation   of   the   AMOS   Professional   system,   you   should   be   able   to   generate   some   amazing </p>
<p>accessories by analysing this information. Go ahead. Make our day!</p>
<p><b>General Information</b></p>
<p>Each AMOS Professional program can have its own unique list of associated memory banks.</p>
<p>All banks are introduced by a standard memory header.</p>
<p>In the original AMOS package, the memory banks were represented using an internal array of just </p>
<p>fifteen addresses. These were used to hold the current memory location of each bank assigned to a  </p>
<p>standard  AMOS   program.   The   evolved  AMOS   Professional   package   uses   a   much   more   flexible </p>
<p>system, allowing as many memory banks as you need.</p>
<p>Memory banks are now stored using a “linked list”, which works like a chain, with each header  </p>
<p>containing a “pointer” to the next header in the Amiga's memory. AMOS Professional is able to search </p>
<p>through this list of headers to find the address of any bank in memory. It starts from the top, and </p>
<p>works downwards until it finds the required bank number. At the end of the chain, the address is </p>
<p>terminated with a value of <b>zero</b>.</p>
<p>14.E.01</p>
<p>B</p>
<p>A</p>
<p>N</p>
<p>K</p>
<p> </p>
<p>S</p>
<p>T</p>
<p>R</p>
<p>U</p>
<p>C</p>
<p>T</p>
<h1 style="page-break-before:always; "></h1>
<p>Memory Bank Structures</p>
<p>As well as this superb new memory pointer, the header contains special flags which tell AMOS </p>
<p>Professional the type of current bank under surveillance. For mere mortals, a name is supplied in </p>
<p>simple ASCII format as well!</p>
<p>Here is a list of currently allowable bank names:</p>
<p>Sprites</p>
<p>Icon</p>
<p>Music</p>
<p>Amal</p>
<p>Menu</p>
<p>Samples</p>
<p>Pic.Pac</p>
<p>Resource</p>
<p>Code</p>
<p>Tracker</p>
<p>Data</p>
<p>Work</p>
<p>Chip</p>
<p>Fast</p>
<p>You are more than welcome to add your own bank definitions to this list.</p>
<p><b>Memory bank headers</b></p>
<p>The header is stored in the following format:</p>
<p>Header</p>
<p>dc.l</p>
<p>Address_Of_Next_Bank</p>
<p>* Start-24</p>
<p>dc.l </p>
<p>Length_Of_Bank + 16 </p>
<p>* Start-20</p>
<p>dc.l</p>
<p>Number_Of_The_Bank </p>
<p>* Start-16</p>
<p>dc.w</p>
<p>Flags</p>
<p>* Start-12</p>
<p>dc.w</p>
<p>Free_For_Future</p>
<p>dc.b</p>
<p>“Namebank”</p>
<p>* Start-8</p>
<p>Start</p>
<p>*</p>
<p>Data goes here</p>
<p>* Returned by START function</p>
<p>There now follows an explanation of each of the above Header components.</p>
<p><b>Address_Of_Next_Bank</b></p>
<p>This is the address of the next bank in the memory chain. The list is terminated with a value of zero.  </p>
<p>Note that each new bank is added to the <b>top</b> of the list so the last bank that has been reserved will be </p>
<p>the first bank in the chain.</p>
<p>These pointers are swapped around whenever the BANK SWAP command is called from AMOS </p>
<p>Professional Basic.</p>
<p>14.E.02</p>
<p>B</p>
<p>A</p>
<p>N</p>
<p>K</p>
<p> </p>
<p>S</p>
<p>T</p>
<p>R</p>
<p>U</p>
<p>C</p>
<p>T</p>
<h1 style="page-break-before:always; "></h1>
<p>Memory Bank Structures</p>
<p><b>Length_Of_Bank+16</b></p>
<p>For Sprite and Icon banks, this refers to the size of the pointer/palette list. Otherwise the length of the </p>
<p>bank is in bytes.</p>
<p><b>Number_Of_The_Bank</b></p>
<p>The number of the bank is held as a standard AMOS Professional integer in four bytes, but RESERVE </p>
<p>and ERASE will only make use of the lower two locations (Start-14). So although there can be a </p>
<p>theoretical   maximum   of   2,147,483,647   banks,   AMOS   Professional   will   only   manipulate   banks </p>
<p>numbered from 1 to 65535.</p>
<p>Please note that if you poke in a number above 65535, this bank may only be deleted with an ERASE </p>
<p>ALL command.</p>
<p><b>Flags</b></p>
<p>The flags are stored as individual binary bits, and have the following meaning:</p>
<p>Bit #0: 1 = &gt;</p>
<p>This sets a permanent DATA Bank which will be saved with an AMOS </p>
<p>Professional program.</p>
<p>0 = &gt;</p>
<p>This is a temporary WORK Bank which will be erased by an ERASE </p>
<p>TEMP command, and discarded every time the program is run.</p>
<p>Bit #1: 1 = &gt;</p>
<p>CHIP memory bank, used for Objects which are to be displayed on the </p>
<p>screen, or items played through the Amiga's sound chips:</p>
<p>Sprites, Bobs, Icons, Samples and Music.</p>
<p>0 = &gt;</p>
<p>This is a FAST memory bank.</p>
<p>Please note that if there is no FAST memory available, all of the FAST banks will be stored in CHIP </p>
<p>RAM instead. This allows you to use the same definitions on any Amiga!</p>
<p>Bit #2: 1 = &gt;</p>
<p>Object bank (list of pointers)</p>
<p>0 = &gt;</p>
<p>Normal, one-section bank</p>
<p>Bit #3: 1 = &gt;</p>
<p>Icon bank (list of pointers)</p>
<p>0 = &gt;</p>
<p>Normal, one-section bank</p>
<p>DATA and WORK bits can be changed as much as necessary, but you should <b>never</b> alter ICON, BOB, </p>
<p>CHIP or FAST flags. Doing so is absolutely guaranteed to crash the Amiga the next time a bank is  </p>
<p>reserved or erased.</p>
<p>Although you can have more than one Sprite bank in memory, only bank number 1 will be used to  </p>
<p>display Sprites and Bobs. Similarly, only bank number 2 can be used for Icons.</p>
<p>If you need to use several Object banks, images can be placed into any bank you wish, and </p>
<p>these banks can be switched using the BANK SWAP command, before they are </p>
<p>displayed.</p>
<p>14.E.03</p>
<p>B</p>
<p>A</p>
<p>N</p>
<p>K</p>
<p> </p>
<p>S</p>
<p>T</p>
<p>R</p>
<p>U</p>
<p>C</p>
<p>T</p>
<h1 style="page-break-before:always; "></h1>
<p>Memory Bank Structures</p>
<p>For example:</p>
<p>Bank Swap 1,10: Rem Swap over banks 10 and 1, bank 10 is the new </p>
<p>Sprite bank</p>
<p><b>Free For_Future</b></p>
<p>This bank is reserved for the future expansion of AMOS Professional. Use it at your peril!</p>
<p><b>“Namebank”</b></p>
<p>This holds the name of a bank. The name is simply a string of eight characters poked into memory,  it  </p>
<p>can be changed or altered at will. This makes it easy to create your own bank types for home-grown </p>
<p>accessories. Note that only printable characters should be used, with ASCII codes greater than 32.</p>
<p><b>Start</b></p>
<p>This is the address returned by the START function, and indicates the beginning of the actual data.</p>
<p><b>WORK BANKS and DATA BANKS</b></p>
<p>These are the backbone of many AMOS Professional programs, and are used to hold a variety of types </p>
<p>of information. They may be stored either in memory or on disc, as follows:</p>
<p><b>Work Banks and Data Banks stored in memory</b></p>
<p>WORK BANKS</p>
<p>Header</p>
<p>dc.l</p>
<p>Next_Bank</p>
<p>Start-24</p>
<p>dc.l</p>
<p>Length_Of_Bank + 16</p>
<p>Start-20</p>
<p>dc.l</p>
<p>Number_Of_The_Bank</p>
<p>Start-16</p>
<p>dc.w</p>
<p>Flag</p>
<p>Start-12 (2=Chip Work or 0=Fast Work)</p>
<p>dc.w</p>
<p>Free_For_Future</p>
<p>Start-10 (Do not touch!)</p>
<p>dc.b </p>
<p>“Work  ”</p>
<p>Start-8</p>
<p>Start</p>
<p>*</p>
<p>Data goes here</p>
<p>ds.b</p>
<p>Length_Of_Bank</p>
<p>DATA BANKS</p>
<p>Header</p>
<p>dc.l</p>
<p>Next_Bank</p>
<p>Start-24 </p>
<p>dc.l</p>
<p>Length_Of_Bank + 16</p>
<p>Start-20</p>
<p>dc.l</p>
<p>Number_Of_The Bank</p>
<p>Start-16</p>
<p>dc.w</p>
<p>Flag</p>
<p>Start-12 (3=Chip Data or 1=Fast Data)</p>
<p>dc.w</p>
<p>Free_For_Future</p>
<p>Start-10 (Do not touch!)</p>
<p>dc.b</p>
<p>“Data  ”</p>
<p>Start-8</p>
<p>Start</p>
<p>Returned by START function</p>
<p>*</p>
<p>Data goes here</p>
<p>ds.b</p>
<p>Length_Of_Bank</p>
<p>Returned by LENGTH function</p>
<p>14.E.04</p>
<p>B</p>
<p>A</p>
<p>N</p>
<p>K</p>
<p> </p>
<p>S</p>
<p>T</p>
<p>R</p>
<p>U</p>
<p>C</p>
<p>T</p>
<h1 style="page-break-before:always; "></h1>
<p>Memory Bank Structures</p>
<p><b>Work banks and data banks stored on disc</b></p>
<p>Before AMOS Professional saves your banks onto disc, the header is discarded and replaced by the </p>
<p>following:</p>
<p>dc.b</p>
<p>“AmBk”</p>
<p>dc.w</p>
<p>Number_Of_The_Bank</p>
<p>dc.w</p>
<p>Flag</p>
<p>dc.l</p>
<p>Length_Of_The_Bank + 8</p>
<p>dc.b</p>
<p>“NameBank”</p>
<p>* 8 bytes</p>
<p>ds.b</p>
<p>Length_Of_The_Bank</p>
<p>* the bank itself!</p>
<p>These files will normally end with “.abk” and can be loaded into AMOS Professional Basic using the </p>
<p>LOAD command.</p>
<p><b>Saving several Banks at once</b></p>
<p>AMOS Professional allows you to save a group of banks in a single “.abs” file. The format of these </p>
<p>files is as follows:</p>
<p>dc.b</p>
<p>“AmBs”</p>
<p>dc.w</p>
<p>Number_Of_Banks</p>
<p>The memory banks are then listed onto the appropriate disc, one after another.</p>
<p><b>Format of Object banks and Icon banks</b></p>
<p>As before, the manner in which Objects and Icons are stored in memory will be examined, followed </p>
<p>by an explanation of their storage on disc.</p>
<p><b>Object banks and Icon banks stored in memory</b></p>
<p>Icons and Objects are stored in a special way. Rather than hold the data in a single continuous </p>
<p>package, AMOS Professional splits these banks into a separate list of images. These images are stored </p>
<p>in their own independent memory locations, and are scattered through the Amiga's Chip Ram. This </p>
<p>makes it very easy to add or delete images, and avoids the problem of “garbage collection”.</p>
<p>However,   this   does   require   you   to   take   a   little   care   when   accessing   images   directly   from   your  </p>
<p>programs. <b>Never</b> try to FILL or COPY data directly to the Object or Icon bank. <b>Do not</b> try to load or </p>
<p>save your images with BLOAD or BSAVE, these commands will not work. Use LOAD and SAVE </p>
<p>instead.</p>
<p>The locations of the images are held in a list of pointers, which can be found immediately after the </p>
<p>header.</p>
<p>In order to remain compatible with the original AMOS system, Object banks are indicated by the </p>
<p>name “Sprites” rather than “Objects”, but they can be used to hold either Sprite or Bob images as </p>
<p>required.</p>
<p>14.E.05</p>
<p>B</p>
<p>A</p>
<p>N</p>
<p>K</p>
<p> </p>
<p>S</p>
<p>T</p>
<p>R</p>
<p>U</p>
<p>C</p>
<p>T</p>
<h1 style="page-break-before:always; "></h1>
<p>Memory Bank Structures</p>
<p>Header</p>
<p>dc.l</p>
<p>Address_Of_Next_Bank</p>
<p>Start-24</p>
<p>dc.l</p>
<p>Length_Of_Bank + 16</p>
<p>Start-20</p>
<p>dc.l</p>
<p>Number_Of_The_Bank</p>
<p>Start-16</p>
<p>dc.w</p>
<p>Flag</p>
<p>Start-12 (5=Objects or 9=lcons)</p>
<p>dc.w</p>
<p>Free_For_Future</p>
<p>Start-10 (Do not touch!)</p>
<p>dc.b</p>
<p>“Sprites  ”</p>
<p>Start-8 (or “Icons ”)</p>
<p>* Start of the bank</p>
<p>Returned by START function</p>
<p>Start </p>
<p>dc.w</p>
<p>Number_Of_Images</p>
<p>Returned by LENGTH function</p>
<p>* “.img” stands for the number of the image</p>
<p>* There is a separate pointer for each image in the bank</p>
<p>REPT</p>
<p>Number_Of_Images</p>
<p>For IMG=1 To No_Of_Images</p>
<p>* Store pointer values</p>
<p>dc.l</p>
<p>lmage_Address.img</p>
<p>Address of Image</p>
<p>dc.l</p>
<p>Mask_Address.img</p>
<p>Address of Mask (if defined)</p>
<p>ENDR</p>
<p>* Colour palette (32 words). This holds the colour values used by your images</p>
<p>dc.w 32</p>
<p><b>Image_Address.img</b></p>
<p>If you have created a blank image using INS BOB, the address of the image will be 0 (zero). In this </p>
<p>case, there is obviously no mask address either.</p>
<p><b>Mask_Address.img</b></p>
<p>This can have different values. If the value equals  <b>zero</b>, the mask is not yet calculated. It will be </p>
<p>created when the image is assigned to the Bob automatically. If the value is -1 the user has called the </p>
<p>NO MASK command, so AMOS Professional will not bother with the mask. If the Mask_Address.img </p>
<p>is <b>greater than zero</b>, it will hold the address of the mask in Chip memory.</p>
<p>Each image has a separate data area:</p>
<p>Image_Address.img</p>
<p>dc.w</p>
<p>X_Size</p>
<p>(Width in words = pixel size/16)</p>
<p>dc.w</p>
<p>V_Size</p>
<p>Height in lines</p>
<p>dc.w</p>
<p>Number_Of_Planes</p>
<p>Number of planes (1 to 6)</p>
<p>dc.w</p>
<p>Hot_Spot_X OR Flipping_Flags</p>
<p>Holds X control point + extra flags</p>
<p>dc.w</p>
<p>Hot_Spot_V</p>
<p>* Image data</p>
<p>REPT</p>
<p>Number_Of_Planes</p>
<p>dcb.w</p>
<p> X_Size * Y_Size</p>
<p>ENDR</p>
<p>The image definition is merely a small bitmap containing the actual picture. The planes are stored one </p>
<p>after another, starling from plane 0.</p>
<p>14.E.06</p>
<p>B</p>
<p>A</p>
<p>N</p>
<p>K</p>
<p> </p>
<p>S</p>
<p>T</p>
<p>R</p>
<p>U</p>
<p>C</p>
<p>T</p>
<h1 style="page-break-before:always; "></h1>
<p>Memory Bank Structures</p>
<p>X_Size</p>
<p>This holds the width of the image, divided by 16.</p>
<p>Y_Size</p>
<p>Stores the height of the image in screen lines.</p>
<p>Number_Of_Planes</p>
<p>A value from 1 to 6 which sets the number of colour planes.</p>
<p>X_Hot,Y_Hot</p>
<p>These set the position of the hot spot of the image</p>
<p>Flipping_Flags</p>
<p>This is used by the HREV, VREV and REV functions.</p>
<p>The Bob flip commands were added in AMOS V1.21 and rather than redefine the entire system, </p>
<p>François Lionet simply grabbed a couple of bits at the top of the HOT SPOT, and used them directly  </p>
<p>for the new options. The x-coordinate was truncated to 14 bits (signed), so you may now set HOT </p>
<p>SPOT values between -4096 and 4096, which is hardly a limitation!</p>
<p>Bit #15 indicates that the image has been flipped from left to right, and bit #14 informs AMOS </p>
<p>Professional that the image has been turned upside down.</p>
<p>If the mask has been defined, it only contains <b>one</b> bitplane. Bits with a value of zero are transparent, </p>
<p>allowing the background to be seen through them, and bits with a value of 1 are opaque.</p>
<p>Mask_Address:</p>
<p>dc.l</p>
<p>Size_Of_The_Mask In_Bytes</p>
<p>dcb.w</p>
<p>X_Size * Y_Size</p>
<p><b>Object banks and Icon banks stored on disc</b></p>
<p>An Object or Icon bank is stored very differently on disc, as all information relating to the pointer is </p>
<p>discarded.</p>
<p>* When saving a Sprite bank the header starts with:</p>
<p>dc.b</p>
<p>“AmSp”</p>
<p>* If it is an Icon bank:</p>
<p>dc.b</p>
<p>“Amlc”</p>
<p>* The rest of the header is common to both Objects and Icons:</p>
<p>dc.w</p>
<p>Number_Of_Objects</p>
<p>REPT</p>
<p>Number_Of_Objects</p>
<p>dc.w</p>
<p>X_Size</p>
<p>dc.w</p>
<p>Y_Size</p>
<p>dc.w</p>
<p>Number_Of_Planes</p>
<p>dc.w</p>
<p>X_Hot_Spot</p>
<p>dc.w</p>
<p>Y_Hot_Spot</p>
<p>REPT</p>
<p>Number_Of_Planes</p>
<p>* The actual image goes here</p>
<p>dcb.w X_Size * Y_Size</p>
<p>ENDR</p>
<p>ENDR</p>
<p>* 32 colour palette holding the image colours</p>
<p>dcb.w 32</p>
<p>14.E.07</p>
<p>B</p>
<p>A</p>
<p>N</p>
<p>K</p>
<p> </p>
<p>S</p>
<p>T</p>
<p>R</p>
<p>U</p>
<p>C</p>
<p>T</p>
<h1 style="page-break-before:always; "></h1>
<p>Memory Bank Structures</p>
<p>Please note the following three points:</p>
<p>If a Sprite or Icon is empty, AMOS Professional will only save this:</p>
<p>dc.w 0</p>
<p>dc.w 0</p>
<p>dc.w 0</p>
<p>dc.w 0</p>
<p>The mask is not saved by AMOS Professional!</p>
<p>All Objects or Icons are flipped back to their original state before they are saved, so the bits 14 and 15 </p>
<p>of the X Hot Spot are always <b>zero</b>.</p>
<p><b>MUSIC BANKS</b></p>
<p>In this section, music banks held in memory will be dealt with first, followed by an examination of  </p>
<p>music banks saved onto disc.</p>
<p><b>Music banks stored in memory</b></p>
<p>The AMOS Professional Music system is stored as an, extension, so it is completely separate from the </p>
<p>rest of the AMOS Professional language. The source code is available and can be changed or modified </p>
<p>to   your   own   needs.   This   means   that   the   system   will   not   be   made   redundant   by   any   future </p>
<p>developments in the world of Amiga music!</p>
<p>Internally,  AMOS  Professional  Music  is  totally  different  from  the  standard  Soundtracker   format. </p>
<p>Music is not coded in parallel, that is to say with all notes for all of the voices in 16 bytes, but in a  </p>
<p>more efficient “track” system. This system is also a little more complex.</p>
<p>Each   voice   has   its   own   individual   track,   and   the   delays   between   each   note   are  not   fixed   as   in </p>
<p><i>Soundtracker</i>, but coded in the note itself. Pauses are achieved by counting a delay value down to zero.</p>
<p>Labels are not stored as part of the notes, but are entered just before them, using two bytes. The </p>
<p>advantage of this technique is that up to 128 different labels may be employed, using a full byte for  </p>
<p>the parameter values. You can also insert several labels one after the other, and the effect will be heard </p>
<p>when the next note is played.</p>
<p>This   structure   makes   the   AMOS   Professional   music   player   very   versatile.   After   appropriate </p>
<p>conversion, it can play music like <i>Soundtracker</i> or IFF music files.</p>
<p>Music banks are completely re-locatable, and are structured in three, independent, main parts:</p>
<p><b>Instruments:</b> this holds the sample data for each instrument in the composition.</p>
<p><b>Musics:</b> this contains a list of pattern numbers to play in sequence.</p>
<p><b>Patterns:</b> this a simple list of notes.</p>
<p>14.E.08</p>
<p>B</p>
<p>A</p>
<p>N</p>
<p>K</p>
<p> </p>
<p>S</p>
<p>T</p>
<p>R</p>
<p>U</p>
<p>C</p>
<p>T</p>
<h1 style="page-break-before:always; "></h1>
<p>Memory Bank Structures</p>
<p>At the start of the music bank, AMOS Professional stores offsets to the various components of the  </p>
<p>music.</p>
<p>Header</p>
<p>dc.l</p>
<p>Next_Bank</p>
<p>dc.l</p>
<p>Length_Of_Bank + 16</p>
<p>dc.l</p>
<p>Number_Of_The_Bank</p>
<p>dc.w</p>
<p>Flag</p>
<p>dc.w</p>
<p>Free_For_Future</p>
<p>dc.b</p>
<p>“Music ”</p>
<p>* 8 Letters</p>
<p>Start:</p>
<p>dc.l</p>
<p>Instruments_Start</p>
<p>* Offset to first instrument</p>
<p>dc.l</p>
<p>Musics_Start</p>
<p>* Offset to first music </p>
<p>dc.l</p>
<p>Patterns_Start</p>
<p>* Offset to first pattern</p>
<p>dc.l</p>
<p>0</p>
<p>* Free for future!</p>
<p>* The Instrument part</p>
<p>Instruments:</p>
<p>dc.w</p>
<p>Number_Of_Instruments</p>
<p>* For each instrument (.inst represents the number of the instrument)</p>
<p>* Repeat</p>
<p>REPT</p>
<p>Number_Of_Instruments</p>
<p>* Offset to sample attack part</p>
<p>dc.l</p>
<p>Attack.inst_Instruments</p>
<p>* Offset to instrument loop. If there is no loop, this points to a null sample at the start</p>
<p>dc.l</p>
<p>Loop.inst Instruments</p>
<p>* Length of the samples, in words (ready to Doke into the circuitry)</p>
<p>dc.w</p>
<p>Attack_Length.inst</p>
<p>dc.w</p>
<p>Loop_Length.inst</p>
<p>* Volume level</p>
<p>dc.w</p>
<p>Volume.inst</p>
<p>dc.w</p>
<p>Total_length.inst</p>
<p>* Name of the instrument in Ascii</p>
<p>dc.b</p>
<p>Name_Of_Instrument_In_16_Bytes</p>
<p>ENDR</p>
<p>* Until Last instrument</p>
<p>* End of instrument definitions</p>
<p>* Now comes the null sample</p>
<p>dc.w</p>
<p>0,0</p>
<p>* And the sample data for each instrument, one after another</p>
<p>* Repeat for every instrument</p>
<p>REPT</p>
<p>Number_Of_Instruments</p>
<p>Attack.inst:</p>
<p>dcb.b</p>
<p>Sample ...</p>
<p>*Sample data for attack</p>
<p>* If a loop is defined:</p>
<p>Loop.inst:</p>
<p>dcb.b</p>
<p>Sample ...</p>
<p>* Loop sample goes here</p>
<p>ENDR</p>
<p>* Until Last Instrument</p>
<p>*</p>
<p>14.E.09</p>
<p>B</p>
<p>A</p>
<p>N</p>
<p>K</p>
<p> </p>
<p>S</p>
<p>T</p>
<p>R</p>
<p>U</p>
<p>C</p>
<p>T</p>
<h1 style="page-break-before:always; "></h1>
<p>Memory Bank Structures</p>
<p>* The Music part starts here, as a list of patterns to be played in sequence</p>
<p>Music:</p>
<p>dc.w</p>
<p>Number_Of_Musics</p>
<p>* “.mus” is the number of the music ...</p>
<p>* Repeat for each piece of music</p>
<p>REPT</p>
<p>Number_Of_Musics</p>
<p>dc.l</p>
<p>Music.mus_Music</p>
<p>* Offset to Pointer list</p>
<p>ENDR</p>
<p>* End repeat</p>
<p>* Repeat for each bit of music</p>
<p>REPT</p>
<p>Number_Of_Musics</p>
<p>Music.mus:</p>
<p>dc.w</p>
<p>Tempo</p>
<p>dc.w</p>
<p>List_patterns_voice_0 - Music.mus * Offset to Voice 0</p>
<p>dc.w</p>
<p>List_patterns_voice_1 - Music.mus * Offset to Voice 1</p>
<p>dc.w</p>
<p>List_patterns_voice_2 - Music.mus * Offset to Voice 2</p>
<p>dc.w</p>
<p>List_patterns_voice_3 - Music.mus * Offset to Voice 3</p>
<p>dc.w</p>
<p>0</p>
<p>*Free for extension</p>
<p>* We now add the list of the pattern numbers to play for each voice</p>
<p>List_patterns_voice_0:</p>
<p>dc.w</p>
<p>“”</p>
<p>* Patterns for voice 0</p>
<p>List_patterns_voice_1:</p>
<p>dc.w</p>
<p>“”</p>
<p>* Patterns for voice 1</p>
<p>List_patterns_voice_2:</p>
<p>dc.w</p>
<p>“”</p>
<p>* Patterns for voice 2</p>
<p>List_patterns_voice_3:</p>
<p>dc.w</p>
<p>“”</p>
<p>* Patterns for voice 3</p>
<p>ENDR</p>
<p>* End Repeat</p>
<p>* The last bit holds the pattern definition</p>
<p>* “.pat” stands for the number of the pattern</p>
<p>Patterns:</p>
<p>dc.w</p>
<p>Number_Of_Patterns</p>
<p>* Repeat for each pattern</p>
<p>REPT</p>
<p>Number_Of_Patterns</p>
<p>* Offsets to the note values for each voice</p>
<p>* Each individual pattern can be safely assigned to ANY voice</p>
<p>* Simply set the offsets accordingly</p>
<p>dc.w</p>
<p>Voice_0_Note_list.pat - Patterns</p>
<p>* Offset to voice 0 notes</p>
<p>dc.w</p>
<p>Voice_1_Note_list.pat - Patterns</p>
<p>* Offset to voice 1 notes</p>
<p>dc.w</p>
<p>Voice_2_Note_list.pat - Patterns</p>
<p>* Offset to voice 2 notes</p>
<p>dc.w</p>
<p>Voice_3_Note list.pat - Patterns </p>
<p>* Offset to voice 3 notes</p>
<p>ENDR</p>
<p>* End Repeat</p>
<p>* And now for the note list, one after the other ...</p>
<p>14.E.10</p>
<p>B</p>
<p>A</p>
<p>N</p>
<p>K</p>
<p> </p>
<p>S</p>
<p>T</p>
<p>R</p>
<p>U</p>
<p>C</p>
<p>T</p>
<h1 style="page-break-before:always; "></h1>
<p>Memory Bank Structures</p>
<p>* Repeat for each pattern</p>
<p>*</p>
<p>REPT</p>
<p>Number_of_patterns</p>
<p>* We will now define a separate note list for each voice</p>
<p>* This is NOT essential, as the notes are TOTALLY independent of the voice number</p>
<p>* So the same note list can be used for ANY of the four voices if required</p>
<p>*</p>
<p>Voice_0_Note_List.pat:</p>
<p>dc.w</p>
<p>“”</p>
<p>* All the notes for voice 0 go here</p>
<p>Voice_1_Note_List.pat:</p>
<p>dc.w</p>
<p>“”</p>
<p>* All the notes for voice 1 go here</p>
<p>Voice_2_Note_List.pat:</p>
<p>dc.w</p>
<p>“”</p>
<p>* All the notes for voice 2 go here</p>
<p>Voice_3_Note_List.pat:</p>
<p>dc.w</p>
<p>“”</p>
<p>* All the notes for voice 3 go here</p>
<p>ENDR</p>
<p>* End Repeat</p>
<p><b>The Patterns</b></p>
<p>Unlike  the  </p>
<p><i>Soundtracker</i></p>
<p>  system,  Patterns are held  as  a  simple list  of notes,  and they can be </p>
<p>assigned to any of the four voices independently. Providing that the correct offset values are set, you </p>
<p>can play the same pattern through all of the available voices simultaneously.</p>
<p>The AMOS Professional music format is closer to IFF music format than the standard  <i>Soundtracker </i></p>
<p>system. Each effect, every instrument and each note is defined by a specific label. Several labels can be </p>
<p>inserted in a sequence, and the AMOS Professional music routines will execute them one by one, until </p>
<p>it finds the actual note to be played through a loudspeaker.</p>
<p>The labels are stored as two-byte words, using the following system:</p>
<p>+ A normal note:</p>
<p>dc.w</p>
<p>%0000pppppppppppp</p>
<p>* pppppppppppp defines the “period” of the sample</p>
<p>* This will be poked directly into the Amiga's sound chips</p>
<p>* Please see your technical reference manual for more details</p>
<p>The note will be played immediately, using the current instrument assigned to the voice.</p>
<p>Labels are defined by setting bit 15 of the note to 1. The general format is as follows:</p>
<p>dc.w</p>
<p>%11111111 pppppppp</p>
<p>* 11111111: the number of the label</p>
<p>* pppppppp: a parameter value</p>
<p>Here is a full list of the possible label types:</p>
<p>+ PATTERN_END</p>
<p>label 0</p>
<p>dc.w</p>
<p>%10000000 00000000</p>
<p>+ SET_VOLUME</p>
<p>label 3(1 and 2 are presently unused)</p>
<p>dc.w</p>
<p>%10000011 vvvvvvvv</p>
<p>* vvvvvvvv : volume level from 0 to 63</p>
<p>14.E.11</p>
<p>B</p>
<p>A</p>
<p>N</p>
<p>K</p>
<p> </p>
<p>S</p>
<p>T</p>
<p>R</p>
<p>U</p>
<p>C</p>
<p>T</p>
<h1 style="page-break-before:always; "></h1>
<p>Memory Bank Structures</p>
<p>+ STOP_EFFECT</p>
<p>label 4</p>
<p>dc.w</p>
<p>%10000100 00000000</p>
<p>+ REPEAT</p>
<p>label 5</p>
<p>dc.w</p>
<p>%10000101 rrrrrrrr</p>
<p>* rrrrrrrr : number of times to repeat</p>
<p>+ LED_ON</p>
<p>label 6</p>
<p>dc.w</p>
<p>%10000110 00000000</p>
<p>+ LED_OFF</p>
<p>label 7</p>
<p>dc.w</p>
<p>%10000111 00000000</p>
<p>+ SET_TEMPO</p>
<p>label 8</p>
<p>dc.w</p>
<p>%10001000 tttttttt</p>
<p>* tttttttt : new tempo from 0 to 63</p>
<p>+ SET_INSTRUMENT</p>
<p>label 9</p>
<p>dc.w</p>
<p>%10001001 11111111</p>
<p>* iiiiiiii : number of the new instrument</p>
<p>+ SET_ARPEGGIO</p>
<p>label 10</p>
<p>dc.w</p>
<p>%10001010 aaaaaaaa</p>
<p>* aaaaaaaa : value of the arpeggio</p>
<p>+ SET_PORTAMENTO</p>
<p>label 11</p>
<p>dc.w</p>
<p>%10001011 pppppppp</p>
<p>* pppppppp : value of the portamento</p>
<p>+ SET_VIBRATO</p>
<p>label 12</p>
<p>dc.w</p>
<p>%10001100 vvvvvvvv</p>
<p>* vvvvvvvv : value of the vibrato</p>
<p>+ SET_VOLUME_SLIDE</p>
<p>label 13</p>
<p>dc.w</p>
<p>%10001101 ssssdddd</p>
<p>* ssss : step size</p>
<p>* dddd : duration</p>
<p>+ SLIDE_UP</p>
<p>label 14</p>
<p>dc.w</p>
<p>%10001110 ssssssss</p>
<p>* ssssssss : frequency shift</p>
<p>+ SLIDE_DOWN</p>
<p>label 15</p>
<p>dc.w</p>
<p>%10001111 ssssssss</p>
<p>* ssssssss : frequency shift</p>
<p>+ DELAY</p>
<p>label 16</p>
<p>dc.w</p>
<p>%10010000 dddddddd</p>
<p>* dddddddd : delay duration in 1/50th of a second</p>
<p>This label is normally used right after a note definition to pause</p>
<p>for a moment while the note is played</p>
<p>+ JUMP</p>
<p>label 17</p>
<p>dc.w</p>
<p>%10010001 pppppppp</p>
<p>*pppppppp : the number of a pattern you want to jump to</p>
<p>Please note the following comments:</p>
<p>•</p>
<p>Everything is relocatable.</p>
<p>14.E.12</p>
<p>B</p>
<p>A</p>
<p>N</p>
<p>K</p>
<p> </p>
<p>S</p>
<p>T</p>
<p>R</p>
<p>U</p>
<p>C</p>
<p>T</p>
<h1 style="page-break-before:always; "></h1>
<p>Memory Bank Structures</p>
<p>•</p>
<p>The AMOS Professional Music player does not modify anything in the bank before the music </p>
<p>is played, unlike Soundtracker.</p>
<p>•</p>
<p>The number of instruments is virtually unlimited, with a choice of 65536!</p>
<p>•</p>
<p>There is an unlimited number of patterns.</p>
<p>•</p>
<p>With a little work, you are able to save a lot of space. The same pattern can be re-used by </p>
<p>different songs, and may be repeated several times in your Soundtrack.</p>
<p><b>Music banks stored on disc</b></p>
<p>The AMOS Professional music banks are saved to disc “as is”, with only a simple header.</p>
<p>dc.b</p>
<p>“ AmBk”</p>
<p>dc.w</p>
<p>Number_Of_The_Bank</p>
<p>dc.l</p>
<p>$80000000 + Length_Of_The_Bank</p>
<p>Note that $80000000 indicates a CHIP memory bank.</p>
<p><b>SAMPLE BANKS</b></p>
<p>All sample banks are loaded in CHIP Ram.</p>
<p>dc.b</p>
<p>“Samples”</p>
<p>Start-8 Name of the bank</p>
<p>Start</p>
<p>dc.w</p>
<p>Number_Of_Samples</p>
<p>* First we store a list of pointers to the samples in memory</p>
<p>* These are held as offsets from the start of the bank</p>
<p>REPT</p>
<p>Number_Of_Samples</p>
<p>dc.l</p>
<p>Sample_XX-start</p>
<p>XX = number of the sample</p>
<p>ENDR</p>
<p>* Now we store the samples one after the other</p>
<p>* Repeat for each sample</p>
<p>REPT</p>
<p>Number_Of_Samples</p>
<p>Sample XX</p>
<p>dc.b</p>
<p>“Namesamp”</p>
<p>Name of the sample in 8 bytes</p>
<p>dc.w</p>
<p>Sampling_Frequency</p>
<p>In Hertz</p>
<p>dc.l</p>
<p>Sample_Length</p>
<p>In WORDS (real length/2)</p>
<p>dcb.b</p>
<p>... samples ...</p>
<p>The actual sample data</p>
<p>ENDR</p>
<p>On disc, the sample bank is saved directly in the above format. The disc header is exactly the same as </p>
<p>for a CHIP DATA bank.</p>
<p><b>AMAL BANKS</b></p>
<p>An AMAL bank can hold two separate types of information. Either a list of AMAL command strings, </p>
<p>or a recorded series of Object movements for use with the PLay instruction. The bank is therefore </p>
<p>divided into sections, as shown below:</p>
<p>The header</p>
<p>dc.b</p>
<p>“AMAL  ”</p>
<p>Start-8 Bank name, 8 bytes, ASCII</p>
<p>Start</p>
<p>dc.l</p>
<p>Strings-Start</p>
<p>Offset to the first command string in </p>
<p>memory</p>
<p>14.E.13</p>
<p>B</p>
<p>A</p>
<p>N</p>
<p>K</p>
<p> </p>
<p>S</p>
<p>T</p>
<p>R</p>
<p>U</p>
<p>C</p>
<p>T</p>
<h1 style="page-break-before:always; "></h1>
<p>Memory Bank Structures</p>
<p>The movement table</p>
<p>* We start with a list of the movement table used by the PLay command</p>
<p>* (NN= number of the move)</p>
<p>* For NN=1 To the Number of Recordings</p>
<p>Moves</p>
<p>dc.w</p>
<p>Number_Of_Movements</p>
<p>* Pointers to the list of X coordinates</p>
<p>REPT</p>
<p>Number_Of_Movements</p>
<p>dc.w</p>
<p>(XMove_NN-Moves)/2</p>
<p>Offset to the X coordinates /2</p>
<p>Or zero if they are not defined</p>
<p>ENDR</p>
<p>* Location of the Y coordinates</p>
<p>REPT</p>
<p>Number_Of_Movements</p>
<p>dc.w</p>
<p>(YMove_NN-Moves)/2</p>
<p>Offset to Y coordinates /2</p>
<p>Or zero if they are not defined</p>
<p>ENDR</p>
<p>* Stores an eight byte name for each movement table</p>
<p>REPT</p>
<p>Number_Of_Movements</p>
<p>dc.b</p>
<p>“MoveName”</p>
<p>8 Bytes per move</p>
<p>ENDR</p>
<p>* Finally here are the movement definitions themselves</p>
<p>*</p>
<p>REPT</p>
<p>Number_Of_Movements</p>
<p>XMove_NN</p>
<p>dc.w</p>
<p>Speed</p>
<p>Recording speed in 1/50 sec</p>
<p>dc.w</p>
<p>Length_Of_X_Move</p>
<p>Length of table in Bytes</p>
<p>dcb.b</p>
<p>... XMove definition ...</p>
<p>YMove_NN</p>
<p>dcb.b</p>
<p>... YMove definition ...</p>
<p>ENDR</p>
<p>The movements are stored in the following way. The movement table uses the same format for both X </p>
<p>and Y coordinates. It begins and ends with a value of zero, which terminates the list equally well if the </p>
<p>movement is being played forwards or backwards.</p>
<p>%00000000</p>
<p>End of the move</p>
<p>%0ddddddd</p>
<p>ddddddd holds the distance to be moved in pixels,</p>
<p>signed on 7 bits (-128 to +128)</p>
<p>This distance will be added to the current object</p>
<p>coordinate to get the new screen position</p>
<p>%1wwwwwww</p>
<p>specifies the number of</p>
<p>1/50 counts to wait until the next</p>
<p>movement</p>
<p><b>The AMAL programs</b></p>
<p>AMAL command strings are stored in normal ASCII format.</p>
<p>14.E.14</p>
<p>B</p>
<p>A</p>
<p>N</p>
<p>K</p>
<p> </p>
<p>S</p>
<p>T</p>
<p>R</p>
<p>U</p>
<p>C</p>
<p>T</p>
<h1 style="page-break-before:always; "></h1>
<p>Memory Bank Structures</p>
<p>Progs</p>
<p>dc.w</p>
<p>Number_Of_Programs</p>
<p>Holds  </p>
<p>the  </p>
<p>number</p>
<p> </p>
<p>of</p>
<p> </p>
<p>AMAL </p>
<p>programs</p>
<p>* Offset list</p>
<p>REPT</p>
<p>Number_Of_Programs</p>
<p>dc.w (Prog_NN-Progs)/2</p>
<p>Distance to the NN'th program</p>
<p>measured in WORDS</p>
<p>ENDR</p>
<p>* Programs</p>
<p>REPT</p>
<p>Number_Of_Programs</p>
<p>Prog_NN</p>
<p>dc.w</p>
<p>Length Of Prog_NN</p>
<p>dc.b</p>
<p>“The program in plain ASCII”</p>
<p>ENDR</p>
<p><b>THE RESOURCE BANK</b></p>
<p>The Resource bank is used to hold all the control buttons and icons used by the AMOS Professional </p>
<p>INTERFACE commands. The Resource bank is split into three main sections. There is one area for the </p>
<p>button definitions, another for the command strings and a third for messages.</p>
<p>dc.b</p>
<p>“Resource”</p>
<p>Start</p>
<p>dc.l</p>
<p>Images-Start</p>
<p>*   Offset   to   the   compressed   images </p>
<p>(optional)</p>
<p>dc.l</p>
<p>Texts-Start</p>
<p>* Offset to the message list (optional)</p>
<p>dc.l</p>
<p>DBL-Start</p>
<p>*  </p>
<p>Offset  </p>
<p>to  </p>
<p>the  </p>
<p>Interface  </p>
<p>program </p>
<p>(optional)</p>
<p>dc.l</p>
<p>0</p>
<p>* Reserved for future expansion</p>
<p>* The compressed images go here</p>
<p>* These are used by the UNpack, Line and BOx commands from the Interface</p>
<p>Images</p>
<p>dc.w</p>
<p>Number_Of_Images</p>
<p>Holds the number of parts</p>
<p>REPT</p>
<p>Number_Of_Images</p>
<p>dc.l</p>
<p>Image_NN-Images</p>
<p>Offset to the start of each part</p>
<p>ENDR</p>
<p>* We now enter full details of the screen from which the images were grabbed</p>
<p>dc.w</p>
<p>Number_Of_Colours</p>
<p>dc.w</p>
<p>Graphic_Mode</p>
<p>In the same format as SCREEN OPEN</p>
<p>(Lowres, Hires, Laced)</p>
<p>ds.w</p>
<p>32</p>
<p>Holds the colour palette for the images</p>
<p>dc.w</p>
<p>Length_Of_Name</p>
<p>Now the name of the source image</p>
<p>dc.b</p>
<p>“Full_Path_Name”</p>
<p>This is a name in simple ASCII format</p>
<p>dc.b</p>
<p>0</p>
<p>Pad out the byte, if not even</p>
<p>* Each image is a normal packed bitmap, in “pic.pac” format</p>
<p>* At this moment, there are only two possible image types</p>
<p>* Simple image</p>
<p>Image_NN:</p>
<p>dc.b</p>
<p>Packed_data</p>
<p>Internal to the screen packer!</p>
<p>* Alternatively, the data can be a BOx definition, a Line definition</p>
<p>* or comments on a specific image, entered in the resource bank_maker.</p>
<p>* in this case, a magic number, =$ABCD will be immediately BEFORE</p>
<p>14.E.15</p>
<p>B</p>
<p>A</p>
<p>N</p>
<p>K</p>
<p> </p>
<p>S</p>
<p>T</p>
<p>R</p>
<p>U</p>
<p>C</p>
<p>T</p>
<h1 style="page-break-before:always; "></h1>
<p>Memory Bank Structures</p>
<p>* the graphic data.</p>
<p>Res_NN:</p>
<p>dc.b</p>
<p>“name  ”</p>
<p>8 bytes, Ascii</p>
<p>dc.w</p>
<p>Number_Of_Images</p>
<p>A BOx needs 9 images, Lines need 3</p>
<p>and a simple image has only 1</p>
<p>dc.w</p>
<p>$ABCD</p>
<p>dcb.b</p>
<p>Packed_Data</p>
<p>* These types can be mixed in any order, so it is acceptable</p>
<p>* to put the comment line BEFORE the button definition</p>
<p>*</p>
<p>Texts:</p>
<p>* This is just a simple list of strings</p>
<p>* Each string can hold up to 255 characters, and it is terminated by a zero</p>
<p>* The length has been added at the start, to make it compatible with AMOS strings.</p>
<p>* Each string is referred to by its number, from an Interface program.</p>
<p>REPT</p>
<p>Number_Of_Strings</p>
<p>dc.b</p>
<p>0</p>
<p>dc.b</p>
<p>Length</p>
<p>dc.b</p>
<p>“The string in plain ASCII”</p>
<p>ENDR</p>
<p>dc.b</p>
<p>0</p>
<p>* Holds one or more Interface command strings in standard ASCII format</p>
<p>* Offset list</p>
<p>DBL:</p>
<p>dc.w</p>
<p>Number_Of Programs</p>
<p>REPT</p>
<p>Number_Of_Programs</p>
<p>Each program has own offset value</p>
<p>dc.l</p>
<p>Prog_N - DBL</p>
<p>Offset to the Interface program</p>
<p>ENDR</p>
<p>* Repeat for each program</p>
<p>REPT</p>
<p>Number_Of_Programs</p>
<p>Prog_N: </p>
<p> One of these for each program</p>
<p>dc.w</p>
<p>Prog_N_End - Prog_N</p>
<p>Length of Interface string in bytes</p>
<p>dc.b</p>
<p>“The text of the program, in ASCII”</p>
<p>dc.b</p>
<p>“with a ZERO at the end...”</p>
<p>dc.b</p>
<p>0</p>
<p>Prog_N_End:</p>
<p>ENDR</p>
<p><b>COMPRESSED PICTURES (PIC.PAC)</b></p>
<p>The internal structure of these pictures is very complex, and this explanation is limited to the header  </p>
<p>file. A full source listing of the compaction code is available from the extensions folder.</p>
<p>The packing process makes several attempts to provide the optimum compression ratio. It packs the </p>
<p>picture into small blocks which are several lines high and exactly one byte wide. The height of the </p>
<p>blocks is continually adjusted until the packer finds the most suitable value for the current data.</p>
<p>14.E.16</p>
<p>B</p>
<p>A</p>
<p>N</p>
<p>K</p>
<p> </p>
<p>S</p>
<p>T</p>
<p>R</p>
<p>U</p>
<p>C</p>
<p>T</p>
<h1 style="page-break-before:always; "></h1>
<p>Memory Bank Structures</p>
<p>There are two possible cases. Either a compressed bitmap created with the PACK command, or a  </p>
<p>packed screen created with the SPACK instruction. The compressed bitmap is examined first.</p>
<p>* Magic number for a packed bitmap (Happy Birthday Francois Lionet!)</p>
<p>Pkcode</p>
<p>dc.l</p>
<p>$06071963</p>
<p>* (Original X coordinate of the bitmap)/8 (in bytes)</p>
<p>Pkdx</p>
<p>dc.w</p>
<p>x</p>
<p>* Y coordinate of the original source data</p>
<p>Pkdy</p>
<p>dc.w</p>
<p>y</p>
<p>* Width of the bitmap in bytes (number of pixels/8)</p>
<p>Pktx</p>
<p>dc.w</p>
<p>width/8</p>
<p>* Height of the bitmap in blocks</p>
<p>Pkty</p>
<p>dc.w</p>
<p>height_in_y</p>
<p>* Height of each individual packing block</p>
<p>Pktcar</p>
<p>dc.w</p>
<p>height_in_lines</p>
<p>* The total height of the picture can be found by multiplying Pkty by Pktcar</p>
<p>* Number of colour planes</p>
<p>Pkplan</p>
<p>dc.w</p>
<p>planes</p>
<p>* Pointer to next data list</p>
<p>PkDatas2 dc.l</p>
<p>next_data</p>
<p>* Pointer to next data pointer</p>
<p>PkPoint2 dc.l</p>
<p>next_pointer</p>
<p>* the packed data goes here!</p>
<p>Finally, a packed screen created with the SPACK instruction is examined. This is identical to the </p>
<p>previous version, except for some extra information that comes before the header, as follows:</p>
<p>PsCode</p>
<p>dc.l </p>
<p>$12031990</p>
<p>Code for a packed screen</p>
<p>PsTx</p>
<p>dc.w</p>
<p>Width</p>
<p>Width of the screen</p>
<p>PsTy</p>
<p>dc.w</p>
<p>Height</p>
<p>Height of the screen </p>
<p>PsAWx</p>
<p>dc.w</p>
<p>Hard_X</p>
<p>X coordinate of screen in hardware format</p>
<p>PsAWy</p>
<p>dc.w</p>
<p>Hard_Y</p>
<p>Vertical position of screen</p>
<p>PsAWTx dc.w</p>
<p>Display_Width</p>
<p>Width of screen to area to be displayed</p>
<p>PsAWTy dc.w</p>
<p>Display_Height</p>
<p>Display Height (set by SCREEN DISPLAY)</p>
<p>PsAVx</p>
<p>dc.w</p>
<p>X_Offset</p>
<p>As set by SCREEN OFFSET</p>
<p>PsAVy</p>
<p>dc.w</p>
<p>Y_Offset</p>
<p>Coordinate of first line to be displayed</p>
<p>PsCon0</p>
<p>dc.w</p>
<p>mode</p>
<p>BPLCON0</p>
<p>PsNbCol</p>
<p>dc.w</p>
<p>cols</p>
<p>Number of colours</p>
<p>PsNPlan dc.w</p>
<p>planes</p>
<p>Number of bitplanes</p>
<p>PsPal</p>
<p>dcb.w</p>
<p>32</p>
<p>Holds the colour palette</p>
<p>14.E.17</p>
<p>B</p>
<p>A</p>
<p>N</p>
<p>K</p>
<p> </p>
<p>S</p>
<p>T</p>
<p>R</p>
<p>U</p>
<p>C</p>
<p>T</p>
<h1 style="page-break-before:always; "></h1>
<p>App. F: Copper Lists</p>
<p><b>The Amiga co-processor</b></p>
<p>While AMOS Professional allows you to harness the power of the Amiga with the greatest of ease, it </p>
<p>has to perform a great deal of work behind the scenes when manipulating entire screens at great </p>
<p>speed. The source of much of this power is a special hardware chip called the “co- processor”, or </p>
<p>copper.</p>
<p>The copper is in effect a simple micro-processor, with its own separate programs, and its own unique </p>
<p>memory registers. It supports only three instructions, MOVE, WAIT and SKIP, and these commands </p>
<p>insert values into the computer's hardware registers at certain points on the display, which change the </p>
<p>way pictures are drawn on the screen.</p>
<p>These hardware registers hold the values that determine the precise appearance of the display, such as </p>
<p>its size and position, as well as the number of colours. For example, all the colour values used by </p>
<p>AMOS Professional screens are held in the colour registers from $180 to $1BE. Because the appearance </p>
<p>of every line displayed on your screen is controlled by the copper, a massive number of special effects  </p>
<p>can be created by changing these registers during a program, using a list of instructions known as the </p>
<p>“copper list”.</p>
<p><b>The Copper List</b></p>
<p>The copper list is executed automatically, fifty times every second, at the same time that the screen is </p>
<p>re-drawn. This is how the AMOS Professional RAINBOW commands work, waiting for a rainbow </p>
<p>line to appear on screen and then immediately poking a new value into the selected colour register. </p>
<p>This causes dramatic colour changes, depending on the position of the line in the display.</p>
<p>Exactly   the   same   process   can   be  applied   to   the   rest   of  the   display   system,   and   by   placing   the </p>
<p>appropriate value into certain hardware registers at exactly the right moment, the position, type and </p>
<p>size of the display can be changed at will! Unfortunately, the copper list is notoriously difficult to </p>
<p>manipulate, and many competent programmers have failed to master its mysteries.</p>
<p>Although the copper is automatically managed by AMOS Professional, you cannot expect the system </p>
<p>to teach you everything about the inner workings of the Amiga's hardware. Indeed, François Lionet </p>
<p>has written AMOS Professional to save you the years of hard work and experience needed to gain </p>
<p>such expert knowledge. However, for those expert programmers who insist on meddling with the </p>
<p>copper   directly,  AMOS   Professional   includes   a   powerful   trap-   door   into   the   realms   of   the   co-</p>
<p>processor. This allows advanced programmers to generate astounding effects, and also allows novices </p>
<p>to send their displays berserk and crash their computers. You have been warned!</p>
<p><b>Accessing the Copper</b></p>
<p><b>COPPER OFF</b></p>
<p><i>instruction: turn off the standard copper list</i></p>
<p><b>Copper Off</b></p>
<p>If   you   ignore   the   warning   in   the   last   paragraph   and   use   this   instruction,   the   automatic   copper </p>
<p>generation that forms the backbone of the AMOS Professional system is turned off. From now on, you </p>
<p>are on your own!</p>
<p>14.F.01</p>
<p>C</p>
<p>O</p>
<p>P</p>
<p>P</p>
<p>E</p>
<p>R</p>
<h1 style="page-break-before:always; "></h1>
<p>Copper Lists</p>
<p>You should now understand that AMOS Professional actually holds two separate copper lists in </p>
<p>memory, and the principle is very similar to the logical and physical screens of the DOUBLE BUFFER </p>
<p>system.</p>
<p>The <b>logical</b> copper list is the list being created from AMOS Professional Basic, and it is completely </p>
<p>invisible. The <b>physical</b> list holds the copper instructions that are generating the current TV display. It </p>
<p>cannot be accessed from AMOS Professional at all, as this would corrupt the display completely. As a </p>
<p>default, these copper lists are limited to 12k in length, which is the equivalent to approximately six </p>
<p>thousand   instructions.   This   limit   may   be   increased   using   an   option   from   the   Interpreter   set-up </p>
<p>dialogue box.</p>
<p>Copper lists can be defined in one of three ways:</p>
<p>The first method is to enter the copper list using a combination of the COP MOVE and COP WAIT </p>
<p>instructions, from AMOS Professional Basic.</p>
<p>The second way is to find the address of the logical copper list, using COP LOGIC. This can then be </p>
<p>manipulated   directly   using   DEEK   and   DOKE,   allowing   minor   modifications   to   be   made   to   the </p>
<p>existing screen without having to generate a completely new copper list at all. This is perfect for the </p>
<p>creation of rainbow effects.</p>
<p>The third alternative is for assembly language buffs. Copper lists can be generated using machine </p>
<p>code, and as before, the current address is available via the COP LOGIC function. Note that this  </p>
<p>address will <b>change</b> during the course of a program, and it must be entered every time the machine </p>
<p>code routine is called.</p>
<p><b>Recommended Procedures</b></p>
<p>If you want to create copper lists from beginning to end, you must take personal control over the </p>
<p>hardware Sprites, the display positioning, the location of screens, and their sizes. You must then </p>
<p>ensure that the resulting screens have the correct amount of memory, before loading the appropriate </p>
<p>registers   with   the   addresses   of   the   required   bitmaps.   This   can  be  achieved   with   the   LOGBASE </p>
<p>function.</p>
<p>Additionally, if you intend to use DOUBLE BUFFER, a separate copper list must be produced for both </p>
<p>the logical and physical screens. Here is the procedure:</p>
<p>•</p>
<p>Define the copper list for the first screen.</p>
<p>•</p>
<p>Switch copper lists using the COP SWAP command.</p>
<p>•</p>
<p>Swap between the logical and physical screens with SCREEN SWAP.</p>
<p>•</p>
<p>Define a copper list for the second screen.</p>
<p>Providing that all is well, you may access your screens using -all of the normal AMOS Professional </p>
<p>drawing commands, including SCREEN COPY, DRAW, PRINT and PLOT. As well as this, there </p>
<p>should be no problems using Blitter Objects.</p>
<p>14.F.02</p>
<p>C</p>
<p>O</p>
<p>P</p>
<p>P</p>
<p>E</p>
<p>R</p>
<h1 style="page-break-before:always; "></h1>
<p>Copper Lists</p>
<p>However,   multiple   screens   and   Sprites   are   only   supported   by   the   standard  AMOS   Professional </p>
<p>copper system, so you cannot use SCREEN OPEN, SCREEN DISPLAY, RAINBOWS or any of the </p>
<p>SPRITE commands. If you need to generate such effects, you will have to program them for yourself! </p>
<p>For those of you who wish to give up now, the following command may be useful.</p>
<p><b>COPPER ON</b></p>
<p><i>instruction: re-start automatic copper generation</i></p>
<p><b>Copper On</b></p>
<p>The   COPPER   ON   command   re-starts   all   standard   copper   calculations,   and   returns   AMOS </p>
<p>Professional back to normal. The experts (and foolhardy) may now continue.</p>
<p><b>COP MOVE</b></p>
<p><i>instruction: write a MOVE instruction to current copper list</i></p>
<p><b>Cop Move</b> address,value</p>
<p>MOVE is an internal instruction used by the copper, and it is very similar to the AMOS Professional  </p>
<p>DOKE command. It inserts a MOVE command into the current logical copper list, by copying a value </p>
<p>from 0 to 65535 into the selected register address. The address refers to a copper register from $7F to </p>
<p>$1BE.</p>
<p><b>COP MOVEL</b></p>
<p><i>instruction: write a long MOVE instruction to copper list</i></p>
<p><b>Cop Movel</b> address,value</p>
<p>This is a special option from AMOS Professional Basic, which generates a matched pair of MOVE </p>
<p>commands in the new copper list. These load a 32-bit (long word) value into the selected address, </p>
<p>exactly like a normal LOKE instruction.</p>
<p><b>COP WAIT</b></p>
<p><i>instruction: insert a WAIT instruction into copper list</i></p>
<p><b>Cop Wait</b> x,y</p>
<p><b>Cop Wait</b> x,y,<i>xmask,ymask</i></p>
<p>The COP WAIT command enters a WAIT instruction at the current position in the copper list. WAIT </p>
<p>forces the copper to stop in its tracks until the screen has been drawn at the specified hardware </p>
<p>coordinates x,y. The copper then continues from the next instruction in the copper list.</p>
<p>WAIT is usually called immediately before a MOVE command, creating a pause until the display </p>
<p>reaches a specific screen line. The MOVE instruction is then used to change the attributes of the screen </p>
<p>area below this line. Rainbows are an excellent example of this technique, with each line of the </p>
<p>rainbow generated with a pair of commands like this:</p>
<p>Cop Wait 0,Y : Rem Y is starting coordinate of next colour shift</p>
<p>Cop Move $180,$777 : Rem $180 is address of colour 0 and $777 is new colour</p>
<p>14.F.03</p>
<p>C</p>
<p>O</p>
<p>P</p>
<p>P</p>
<p>E</p>
<p>R</p>
<h1 style="page-break-before:always; "></h1>
<p>Copper Lists</p>
<p>The   x-coordinate   is   a   hardware   coordinate   from   0   to   448.   Since   the  Amiga   is   only   capable   of  </p>
<p>performing this test every four screen points, this coordinate is rounded to the nearest multiple of </p>
<p>four.</p>
<p>The y-coordinate can be any value from 0 to 312. Normally, coordinates from 256 to 312 require </p>
<p>special programming, but AMOS Professional generates the correct instructions automatically, so </p>
<p>there is no need for concern! Here are some examples:</p>
<p>Cop Wait 0,130: Rem Wait for screen to reach hardware coords 0,100</p>
<p>Cop Wait 0,300: Rem Wait for line 300</p>
<p>Cop Wait 12,10: Rem Wait for coordinates 12,10 to arrive</p>
<p>The optional xmask and ymask parameters are bit-mask values which allow for a pause until the </p>
<p>screen coordinates satisfy a specific combination of bits. The default value is $1FF. For example:</p>
<p>Cop Wait 0,2,$1FF,%11 : Rem Await next EVEN scan line</p>
<p><b>COP RESET</b></p>
<p><i>instruction: re-set copper list pointer</i></p>
<p><b>Cop Reset</b></p>
<p>This command is used to add a pair of MOVE commands, forcing the copper list to re-start from the  </p>
<p>very first instruction. This may be used to generate simple loops.</p>
<p><b>COP SWAP</b></p>
<p><i>instruction: swap logical and physical copper lists</i></p>
<p><b>Cop Swap</b></p>
<p>The COP SWAP command switches over the logical and physical copper lists. The new copper list </p>
<p>will now be flicked into place, and the results will be shown after the next vertical blank period. For </p>
<p>example:</p>
<p>Cop Swap : Wait Vbl</p>
<p><b>COP LOGIC</b></p>
<p><i>instruction: give address of logical copper list</i></p>
<p>address=<b>Cop Logic</b></p>
<p>This command returns the absolute address of the logical copper list in memory. It can be used to </p>
<p>manipulate the copper list directly from AMOS Professional Basic. Lists can also be generated by </p>
<p>using assembly language.</p>
<p>14.F.04</p>
<p>C</p>
<p>O</p>
<p>P</p>
<p>P</p>
<p>E</p>
<p>R</p>
<h1 style="page-break-before:always; "></h1>
<p>App. G: Command Index</p>
<p>This Command Index may well be one of the most useful sections of the User Guide for genuine </p>
<p>AMOS Professional programmers. For on-line explanations and examples of all keywords, the [Help] </p>
<p>facility is invaluable, but this Appendix is the <b>only</b> facility which provides a complete overview of <b>all </b></p>
<p>of the AMOS Professional commands. Experienced users can scan this Index to embrace everything </p>
<p>that the system has to offer.</p>
<p>The   Command   Index   includes   every   instruction,   function,   structure   and   reserved   variable   in </p>
<p>alphabetical   order,   along   with   a   synopsis   of  usage.   Every  embedded   Menu   command,   Interface </p>
<p>instruction and AMAL keyword is also included.</p>
<p>The page references refer to the  <b>main</b>  explanation of each keyword that can be found in this User </p>
<p>Guide. Page references are shown using the following protocol: Section.Chapter.Page. For example, a </p>
<p>keyword which is referenced as <b>5.3.01</b> means that full details can be found in Section 5, Chapter 3, </p>
<p>Page 01 of this User Guide. For associated items, cross-references and general topics, please refer to </p>
<p>the Main Index at the end of this User Guide.</p>
<p>ABS <i>Function: give an absolute value</i> ......................................................................................................... 5.3.04</p>
<p>ACOS <i>Function: give arc cosine</i> ................................................................................................................. 5.3.09</p>
<p>ADD <i>Instruction: perform fast integer addition</i> ......................................................................................... 5.3.02</p>
<p>AL <i>Interface Instruction: display an active list window</i> .............................................................................. 9.3.10</p>
<p>AMAL <i>Instruction: call an AMAL program</i> .............................................................................................. 7.6.11</p>
<p>AMAL FREEZE <i>Instruction: suspend AMAL programs</i> ........................................................................... 7.6.18</p>
<p>AMAL OFF <i>Instruction: stop all AMAL programs</i> ................................................................................... 7.6.17</p>
<p>AMAL ON <i>Instruction: activate all AMAL programs</i> ............................................................................... 7.6.17</p>
<p>AMALERR <i>Function: give the position of an AMAL error</i> ........................................................................ 7.6.20</p>
<p>AMOS HERE <i>Function: report if AMOS Pro is at front of display</i> ......................................................... 11.4.02</p>
<p>AMOS LOCK <i>Instruction: disable [Amiga]+[A] toggle facility</i> ............................................................... 11.4.01</p>
<p>AMOS TO BACK <i>Instruction: hide AMOS Professional and reveal Workbench</i> .................................... 11.4.01</p>
<p>AMOS TO FRONT <i>Instruction: hide Workbench and reveal AMOS Professional</i> .................................. 11.4.01</p>
<p>AMOS UNLOCK <i>Instruction: re-activate AMOS Professional/Workbench toggle</i> ................................. 11.4.02</p>
<p>AMPLAY <i>Instruction: control animation produced by PLay</i> ..................................................................... 7.6.18</p>
<p>AM REG <i>Reserved Variable: give the value of an AMAL register</i> .............................................................. 7.6.18</p>
<p>AND <i>Structure: qualify a condition</i> ........................................................................................................... 5.4.03</p>
<p>ANIM <i>Instruction: animate an Object</i> ....................................................................................................... 7.6.24</p>
<p>ANIM FREEZE <i>Instruction: freeze an animation</i> ...................................................................................... 7.6.25</p>
<p>ANIM OFF <i>Instruction: toggle animations off</i> ........................................................................................... 7.6.24</p>
<p>ANIM ON <i>Instruction: toggle animations on</i> ............................................................................................ 7.6.24</p>
<p>Anim <i>AMAL Instruction: animate an Object</i> ............................................................................................ 7.6.03</p>
<p>APPEAR <i>Instruction: fade between two screens</i> ......................................................................................... 6.3.01</p>
<p>APPEND <i>Instruction: add data to an existing file</i> .................................................................................... 10.2.11</p>
<p>AR <i>Interface Instruction: read an element from an array</i> ............................................................................ 9.3.09</p>
<p>AREG <i>Reserved Variable: pass values to and from an address register</i> .................................................... 14.A.15</p>
<p>AREXX <i>Function: check for a message from an AREXX program</i> ............................................................ 10.6.03</p>
<p>AREXX ANSWER <i>Instruction: answer a message from an AREXX program</i> ........................................ 10.6.04</p>
<p>14.G.01</p>
<p>C</p>
<p>O</p>
<p>M</p>
<p>M</p>
<p>A</p>
<p>N</p>
<p>D</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Command Index</p>
<p>AREXX CLOSE <i>Instruction: close a communications port</i> ...................................................................... 10.6.02</p>
<p>AREXX EXIST <i>Function: check the availability of a communications port</i> ................................................ 0.6.02</p>
<p>AREXX OPEN <i>Instruction: open an AREXX communications port</i> ....................................................... 10.6.02</p>
<p>AREXX$ <i>Function: get a message from an AREXX program</i> ................................................................... 10.6.03</p>
<p>AREXX WAIT <i>Instruction: wait for a message from an AREXX program</i> .............................................. 10.6.03</p>
<p>ARRAY <i>Function: load the address of an array into a program</i> .................................................................. 9.3.09</p>
<p>AS <i>Instruction: please see RESERVE</i> .......................................................................................................... 5.9.02</p>
<p>AS <i>Interface Instruction: return the size of an array</i> ................................................................................... 9.3.10</p>
<p>ASC <i>Function: give the ASCII code of a character</i> ...................................................................................... 5.2.05</p>
<p>ASIN <i>Function: give arc sine</i> ...................................................................................................................... 5.3.09</p>
<p>ASK EDITOR <i>Instruction: return params from Editor to an accessory program</i> ..................................... 13.1.02</p>
<p>ASSIGN <i>Instruction: assign a name to a path or device</i> ........................................................................... 10.2.06</p>
<p>AT <i>Function: return a string to position the text cursor</i> ............................................................................. 5.6.06</p>
<p>ATAN <i>Function: give arc tangent</i> .............................................................................................................. 5.3.09</p>
<p>AUTO VIEW OFF <i>Instruction: toggle viewing mode off</i> ........................................................................... 6.1.03</p>
<p>AUTO VIEW ON <i>Instruction: toggle viewing mode on</i> ............................................................................ 6.1.03</p>
<p>AUTOBACK <i>Instruction: set the graphics mode on double buffered screen</i> ............................................... 7.3.06</p>
<p>AUtotest <i>AMAL Instruction: activate AMAL Autotest system</i> ................................................................ 7.6.06</p>
<p>BA <i>Interface Instruction: set coordinate base for dialogue box</i> .................................................................... 9.1.07</p>
<p>BANK SHRINK <i>Instruction: reduce the size of a memory bank</i> ................................................................ 5.9.07</p>
<p>BANK SWAP <i>Instruction: swap over two memory banks</i> .......................................................................... 5.9.07</p>
<p>BANK TO MENU <i>Instruction: restore menu definition saved in menu, bank</i> .......................................... 6.5.06</p>
<p>BAR <i>Instruction: draw a filled rectangle</i> ..................................................................................................... 6.4.08</p>
<p>BAr <i>Embedded Menu Command: draw a bar</i> .............................................................................................. 6.5.15</p>
<p>BC <i>AMAL Function: check for Bob collision</i> ............................................................................................... 7.6.08</p>
<p>BC <i>Interface Instruction: change the setting of any active button</i> ............................................................... 9.1.13</p>
<p>BCHG <i>Instruction: toggle a bit</i> ................................................................................................................ 14.A.10</p>
<p>BCLR <i>Instruction: clear a bit</i> ................................................................................................................... 14.A.11</p>
<p>BELL Instruction: generate a pure audio tone ....................................................................................... 8.1.01</p>
<p>BGRAB <i>Instruction: grab a memory bank from previous program</i> ............................................................. 5.9.10</p>
<p>BIN$ <i>Function: convert a decimal value to binary number</i> ...................................................................... 14.A.02</p>
<p>BLENGTH <i>Function: give the length of a memory bank from previous program</i> ....................................... 5.9.09</p>
<p>BLOAD <i>Instruction: load block of binary data into a bank or an address</i> ................................................... 5.9.05</p>
<p>BO <i>Interface Instruction: draw a box from Resource Bank image components</i> ............................................ 9.4.02</p>
<p>BOb <i>Embedded Menu Command: draw a Bob</i> ............................................................................................ 6.5.14</p>
<p>BOB <i>Instruction: display a Bob on screen</i> ................................................................................................... 7.2.01</p>
<p>BOB CLEAR <i>Instruction: clear all Bobs from the screen</i> ...........................................................................  7.3.05</p>
<p>BOB COL <i>Function: test for collision between Bobs</i> ................................................................................... 7.4.03</p>
<p>BOB DRAW <i>Instruction: re-draw all Bobs on screen</i> ................................................................................. 7.3.05</p>
<p>BOB OFF <i>Instruction: remove a Bob from display</i> ...................................................................................... 7.2.03</p>
<p>BOB UPDATE <i>Instruction: move several Bobs simultaneously</i> ................................................................. 7.3.03</p>
<p>BOB UPDATE OFF <i>Instruction: turn off automatic Bob update system</i> ................................................... 7.3.03</p>
<p>BOB UPDATE ON <i>Instruction: turn on automatic Bob update system</i> .................................................... 7.3.03</p>
<p>14.G.02</p>
<p>C</p>
<p>O</p>
<p>M</p>
<p>M</p>
<p>A</p>
<p>N</p>
<p>D</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Command Index</p>
<p>BOBSPRITE COL <i>Function: test for collision between Bob and Sprites</i> .................................................... 7.4.04</p>
<p>BOOM <i>Instruction: generate explosive sound effect</i> ................................................................................... 8.1.01</p>
<p>BORDER <i>Instruction: change window border</i> ............................................................................................ 5.7.02</p>
<p>BORDER$ <i>Function: create a border around text</i> ....................................................................................... 5.6.11</p>
<p>BOX <i>Instruction: draw a rectangular outline</i> ............................................................................................. 6.4.03</p>
<p>BP <i>Interface Function: return the setting inside a button definition</i> ........................................................... 9.1.12</p>
<p>BQ <i>Interface Instruction: trigger an exit button</i> ......................................................................................... 9.1.11</p>
<p>BR <i>Interface Instruction: change the setting of a button</i> ............................................................................. 9.1.13</p>
<p>BREAK OFF <i>Instruction: toggle off program break keys</i> ............................................................................ 5.1.08</p>
<p>BREAK ON <i>Instruction: toggle on program break keys</i> ............................................................................. 5.1.08</p>
<p>BSAVE <i>Instruction: save unformatted memory bank</i> .................................................................................. 5.9.05</p>
<p>BSEND <i>Instruction: send a memory bank to previous program</i> ................................................................. 5.9.10</p>
<p>BSET <i>Instruction: set a bit to 1</i> ................................................................................................................ 14.A.10</p>
<p>BSTART <i>Function: give address of a memory bank from a previous program</i> ............................................. 5.9.10</p>
<p>BTST <i>Function: test a bit</i> ......................................................................................................................... 14.A.10</p>
<p>BU <i>Interface Instruction: define an Interface button</i> ................................................................................... 9.1.09</p>
<p>BX <i>Interface Function: get the x-coordinate base location</i> ........................................................................... 9.2.01</p>
<p>BY <i>Interface Function: get the y-coordinate base location</i> ........................................................................... 9.2.01</p>
<p>C AMAL <i>Function: give collision status of an Object</i> ................................................................................ 7.6.09</p>
<p>CALL <i>Instruction: execute a machine code program</i> ............................................................................... 14.A.14</p>
<p>CALL EDITOR <i>Instruction: send instructions to Editor from an accessory program</i> .............................. 13.1.01</p>
<p>CAll <i>Interface Instruction: call a machine code extension</i> ........................................................................... 9.2.10</p>
<p>CDOWN <i>Instruction: move the text cursor down</i> ...................................................................................... 5.6.08</p>
<p>CDOWN$ <i>Function: return control character to move text cursor down</i> .................................................. 5.6.08</p>
<p>CENTRE <i>Instruction: print text at centre of current line</i> ........................................................................... 5.6.07</p>
<p>CHANAN <i>Function: test a channel for an active animation</i> ..................................................................... 7.6.19</p>
<p>CHANGE MOUSE <i>Instruction: change the shape of the mouse pointer</i> ................................................... 5.8.03</p>
<p>CHANMV <i>Function: test channel for an active Object</i> .............................................................................. 7.6.19</p>
<p>CHANNEL <i>Instruction: assign an Object to an AMAL channel</i> ............................................................... 7.6.12</p>
<p>CHIP FREE <i>Function: give remaining Chip memory</i> ................................................................................. 3.1.05</p>
<p>CHOICE <i>Function: read a menu</i> ................................................................................................................ 6.5.02</p>
<p>CHR$ <i>Function: give a character with a given ASCII code</i> ........................................................................ 5.2.05</p>
<p>CIRCLE <i>Instruction: draw a circular outline</i> ............................................................................................. 6.4.03</p>
<p>CLEAR KEY <i>Instruction: re-set the keyboard buffer</i> ................................................................................ 10.1.03</p>
<p>CLEFT <i>Instruction: move text cursor one character to the left</i> ................................................................... 5.6.08</p>
<p>CLEFT$ <i>Function: move cursor 1 character to the left</i> ............................................................................... 5.6.09</p>
<p>CLINE <i>Instruction: clear text on the current cursor line</i> ............................................................................ 5.6.09</p>
<p>CLIP <i>Instruction: restrict drawing to a limited screen area</i> ........................................................................ 6.4.04</p>
<p>CLOSE <i>Instruction: close a file</i> ................................................................................................................. 10.2.12</p>
<p>CLOSE EDITOR <i>Instruction: close the AMOS Professional editor</i> ......................................................... 13.1.07</p>
<p>CLOSE WORKBENCH <i>Instruction: close the Workbench</i> ...................................................................... 13.1.07</p>
<p>CLS <i>Instruction: clear the current screen</i> .................................................................................................... 6.1.07</p>
<p>CLW <i>Instruction: clear the current window</i> ............................................................................................... 5.7.04</p>
<p>14.G.03</p>
<p>C</p>
<p>O</p>
<p>M</p>
<p>M</p>
<p>A</p>
<p>N</p>
<p>D</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Command Index</p>
<p>CMOVE <i>Instruction: move the text cursor</i> ................................................................................................. 5.6.06</p>
<p>CMOVE$ <i>Function: return control string to position text cursor</i> .............................................................. 5.6.06</p>
<p>COL <i>Function: test status of Object after collision detect routine</i> ............................................................... 7.4.04</p>
<p>COLOUR <i>Function: read the colour assignment</i> ........................................................................................ 6.4.05</p>
<p>COLOUR <i>Instruction: assign colour to an index</i> ....................................................................................... 6.4.06</p>
<p>COLOUR BACK <i>Instruction: assign colour to screen background</i> ............................................................ 6.4.06</p>
<p>COMMAND LINE$ <i>Reserved Variable: transfer parameters between programs</i> .................................... 10.2.09</p>
<p>COP LOGIC <i>Function: give address of logical copper list</i> ........................................................................ 14.F.04</p>
<p>COP MOVE <i>Instruction: write a Move instruction to the copper list</i> ...................................................... 14.F.03</p>
<p>COP MOVEL <i>Instruction: write lone Move instruction to the copper list</i> ............................................... 14.F.03</p>
<p>COP RESET <i>Instruction: re-set copper list pointer</i> ................................................................................... 14.F.04</p>
<p>COP SWAP <i>Instruction: swap over the logical and physical copper lists</i> ................................................. 14.F.04</p>
<p>COP WAIT <i>Instruction: insert a Wait instruction into copper list</i> .......................................................... 14.F.03</p>
<p>COPPER OFF <i>Instruction: turn off standard copper list</i> .......................................................................... 14.F.01</p>
<p>COPPER ON <i>Instruction: re-start automatic copper generation</i> ............................................................. 14.F.03</p>
<p>COPY <i>Instruction: copy a memory block</i> ................................................................................................. 14.A.05</p>
<p>COS <i>Function: give cosine of an angle</i> ........................................................................................................ 5.3.08</p>
<p>CRIGHT <i>Instruction: move the text cursor one character to the right</i> ........................................................ 5.6.08</p>
<p>CRIGHT$ <i>Function: move cursor one character right</i> ................................................................................ 5.6.09</p>
<p>CUP <i>Instruction: move the text cursor up one line</i> ..................................................................................... 5.6.08</p>
<p>CUP$ <i>Function: return control character to move cursor up one line</i> ......................................................... 5.6.09</p>
<p>CURS OFF <i>Instruction: toggle the text cursor off</i> ...................................................................................... 5.6.11</p>
<p>CURS ON <i>Instruction: toggle the text cursor on</i> ....................................................................................... 5.6.11</p>
<p>CURS PEN <i>Instruction: select colour of the text cursor</i> ............................................................................. 5.6.10</p>
<p>CX <i>Interface Function: centre text in the display</i> ........................................................................................ 9.2.05</p>
<p>DATA <i>Structure: place a list of data items in a program</i> ............................................................................. 5.4.12</p>
<p>DEC <i>Instruction: decrement an integer variable by one unit</i> ...................................................................... 5.3.02</p>
<p>DEEK <i>Function: read two bytes from an even address</i> ............................................................................. 14.A.04</p>
<p>DEF FN <i>Structure: create a user-defined function</i> ...................................................................................... 5.1.06</p>
<p>DEF SCROLL <i>Instruction: define a scrolling screen zone</i> .......................................................................... 6.2.02</p>
<p>DEFAULT <i>Instruction: re-set to the default screen</i> .................................................................................... 6.1.03</p>
<p>DEFAULT PALETTE <i>Instruction: define standard palette</i> ........................................................................ 6.1.09</p>
<p>DEGREE <i>Instruction: use degrees</i> .............................................................................................................. 5.3.08</p>
<p>DEL BLOCK <i>Instruction: delete a screen block</i> .......................................................................................... 7.7.04</p>
<p>DEL BOB <i>Instruction: delete an image from the Object bank</i> ..................................................................... 7.2.09</p>
<p>DEL CBLOCK <i>Instruction: delete compacted screen block</i> ......................................................................... 7.7.05</p>
<p>DEL ICON <i>Instruction: delete image from the Icon bank</i> ........................................................................... 7.7.02</p>
<p>DEL SPRITE <i>Instruction: delete an image from the Object bank</i> ................................................................ 7.1.05</p>
<p>DEL WAVE <i>Instruction: delete an audio wave</i> ........................................................................................... 8.1.07</p>
<p>DEV ABORT <i>Instruction: abort an IO operation</i> ..................................................................................... 11.5.08</p>
<p>DEV BASE <i>Function: get base address of an IO structure</i> ....................................................................... 11.5.08</p>
<p>DEV CHECK <i>Function: check status of a device with CheckIO</i> ............................................................... 11.5.08</p>
<p>DEV CLOSE <i>Instruction: close one or more devices</i> ................................................................................. 11.5.07</p>
<p>14.G.04</p>
<p>C</p>
<p>O</p>
<p>M</p>
<p>M</p>
<p>A</p>
<p>N</p>
<p>D</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Command Index</p>
<p>DEV DO <i>Instruction: call a command using DoIO</i> .................................................................................. 11.5.08</p>
<p>DEV FIRST$ <i>Function: get the first device from the current device list</i> ................................................... 11.5.06</p>
<p>DEV NEXT$ <i>Function: get the next device in the current search path</i> ..................................................... 11.5.07</p>
<p>DEV OPEN <i>Instruction: open a device</i> ..................................................................................................... 11.5.07</p>
<p>DEV SEND <i>Instruction: call a command using SendIO</i> .......................................................................... 11.5.08</p>
<p>DFREE <i>Function: report amount of free space on disc</i> .............................................................................. 10.2.10</p>
<p>DI <i>Interface Instruction: create a numeric editing zone</i> .............................................................................. 9.3.07</p>
<p>DIALOG <i>Function: return the status of an open dialogue box</i> ................................................................... 9.3.03</p>
<p>DIALOG BOX <i>Function: display dialogue box on the screen</i> ..................................................................... 9.1.06</p>
<p>DIALOG CLOSE <i>Instruction: close one or more dialogue channels</i> .......................................................... 9.3.02</p>
<p>DIALOG CLR <i>Instruction: clear a dialogue box</i> ........................................................................................ 9.3.15</p>
<p>DIALOG FREEZE <i>Instruction: stop dialogue channel input</i> .................................................................... 9.3.15</p>
<p>DIALOG OPEN <i>Instruction: open a channel to an Interface program</i> ...................................................... 9.3.01</p>
<p>DIALOG RUN <i>Function: run a dialogue box from an open channel</i> ......................................................... 9.3.02</p>
<p>DIALOG UNFREEZE <i>Instruction: re-activate a frozen dialogue channel</i> ................................................ 9.3.15</p>
<p>DIALOG UPDATE <i>Instruction: update a dialogue zone</i> ........................................................................... 9.3.14</p>
<p>DIM <i>Instruction: dimension an array</i> ......................................................................................................... 5.1.04</p>
<p>DIR <i>Instruction: print directory of the current disc</i> .................................................................................. 10.2.02</p>
<p>DIR FIRST$ <i>Function: get the first file that satisfies a path name</i> ............................................................ 10.2.07</p>
<p>DIR NEXT$ <i>Function: get the next file that satisfies path name</i> .............................................................. 10.2.07</p>
<p>DIR$ <i>Reserved Variable: change the current directory</i> .............................................................................. 10.2.05</p>
<p>DIR/W <i>Instruction: print directory in two columns</i> ................................................................................. 10.2.02</p>
<p>DIRECT <i>Instruction: return to Direct Mode</i> .............................................................................................. 5.1.08</p>
<p>Direct <i>AMAL Instruction: change resumption point of main program</i> ...................................................... 7.6.06</p>
<p>DISC INFO$ <i>Function: report free space of named file or directory</i> ......................................................... 10.2.10</p>
<p>DISPLAY HEIGHT <i>Function: give the maximum available screen height</i> .............................................. 14.C.01</p>
<p>DO <i>Structure: mark the beginning of a loop</i> ............................................................................................... 5.4.06</p>
<p>DOKE <i>Instruction: change two-byte word at an even address</i> ................................................................. 14.A.04</p>
<p>DOSCALL <i>Function: execute function from the DOS library</i> .................................................................. 11.5.02</p>
<p>DOUBLE BUFFER <i>Instruction: activate the double buffering system</i> ....................................................... 7.2.06</p>
<p>DRAW <i>Instruction: draw a line</i> .................................................................................................................. 6.4.02</p>
<p>DRAW TO <i>Instruction: draw a line from the last coordinates</i> .................................................................... 6.4.02</p>
<p>DREG <i>Reserved Variable: pass a value into 68000 data register</i> .............................................................. 14.A.15</p>
<p>DUAL PLAYFIELD <i>Instruction: combine two screens</i> .............................................................................. 6.1.06</p>
<p>DUAL PRIORITY <i>Instruction: reverse the order of dual playfield screens</i> ................................................ 6.1.07</p>
<p>ED Interface <i>Instruction: create a text edit zone</i> ........................................................................................ 9.3.05</p>
<p>EDIALOG <i>Function: find an error in an Interface program</i> ....................................................................... 9.3.03</p>
<p>EDIT <i>Instruction: return to the Edit Screen</i> ............................................................................................... 5.1.08</p>
<p>ELLIPSE <i>Instruction: draw an elliptical outline</i> ......................................................................................... 6.4.04</p>
<p>ELipse <i>Embedded Menu Command: draw an ellipse</i> .................................................................................. 6.5.16</p>
<p>ELSE <i>Structure :qualify a condition</i> ............................................................................................................ 5.4.04</p>
<p>ELSE IF <i>Structure: qualify a condition</i> ....................................................................................................... 5.4.05</p>
<p>END <i>Instruction: stop the current program</i> ............................................................................................... 5.1.07</p>
<p>14.G.05</p>
<p>C</p>
<p>O</p>
<p>M</p>
<p>M</p>
<p>A</p>
<p>N</p>
<p>D</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Command Index</p>
<p>End <i>AMAL Instruction: terminate an AMAL program</i> ............................................................................. 7.6.06</p>
<p>END IF <i>Structure: terminate a structured test</i> ........................................................................................... 5.4.04</p>
<p>END PROC <i>Structure: end a procedure</i> ..................................................................................................... 5.5.01</p>
<p>EOF <i>Function: test for end of file</i> .............................................................................................................. 10.2.13</p>
<p>EQU <i>Function: get an equate used by Amiga system library</i> .................................................................... 11.5.04</p>
<p>ERASE <i>Instruction: clear a single memory bank</i> ........................................................................................ 5.9.06</p>
<p>ERASE ALL <i>Instruction: clear all current memory banks</i> .......................................................................... 5.9.06</p>
<p>ERASE TEMP <i>Instruction: clear temporary memory banks</i> ....................................................................... 5.9.07</p>
<p>ERRN <i>Function: give error code number of error</i> ..................................................................................... 12.2.03</p>
<p>ERROR <i>Instruction: generate an error</i> ..................................................................................................... 12.2.03</p>
<p>ERR$ <i>Function: return an error message string</i> ....................................................................................... 12.2.04</p>
<p>ERRTRAP <i>Function: return an error code number after a Trap command</i> ............................................... 12.2.04</p>
<p>EVERY <i>Instruction: call a sub-routine or a procedure at regular intervals</i> ................................................. 5.4.11</p>
<p>EVERY OFF <i>Instruction: toggle regular calls off</i> ........................................................................................ 5.4.12</p>
<p>EVERY ON <i>Instruction: toggle regular calls on</i> ......................................................................................... 5.4.12</p>
<p>EX Interface <i>Instruction: exit from Interface and return to main program</i> ................................................ 9.1.03</p>
<p>EXEC <i>Instruction: send a CLI command to a device</i> ................................................................................. 11.4.04</p>
<p>EXECALL <i>Function: call EXEC library</i> ................................................................................................... 11.5.02</p>
<p>EXIST <i>Function: check if specified file exists</i> ............................................................................................. 10.2.06</p>
<p>EXIT <i>Structure: break out of a loop</i> ............................................................................................................. 7.6.16</p>
<p>eXit <i>AMAL Instruction: leave Autotest and return to main program</i> ........................................................ 7.6.06</p>
<p>EXIT IF <i>Structure: break out of a loop depending on a test</i> ......................................................................... 5.4.07</p>
<p>EXP <i>Function: calculate an exponential number</i> ......................................................................................... 5.3.06</p>
<p>FADE <i>Instruction: blend colours to new values</i> .......................................................................................... 6.3.01</p>
<p>FALSE <i>Function: hold a value of zero if a condition is false</i> ........................................................................ 5.4.06</p>
<p>FAST FREE <i>Function: return amount of Fast memory in bytes</i> ................................................................. 5.9.03</p>
<p>FIELD <i>Instruction: define a record structure</i> ............................................................................................ 10.2.14</p>
<p>FILL <i>Instruction: fill memory block with the contents of a variable</i> ......................................................... 14.A.05</p>
<p>FIRE <i>Function: test the status of joystick fire-button</i> .................................................................................. 5.8.02</p>
<p>FIX <i>Instruction: fix the precision of floating point</i> ...................................................................................... 5.3.05</p>
<p>FLASH <i>Instruction: set flashing colour sequence</i> ....................................................................................... 6.3.03</p>
<p>FLASH OFF <i>Instruction: turn off the flashing colour sequence</i> ................................................................. 6.3.03</p>
<p>FLIP$ <i>Function: invert a string</i> .................................................................................................................. 5.2.04</p>
<p>FN <i>Structure: call a user-defined function</i> .................................................................................................. 5.1.06</p>
<p>FONT$ <i>Function: return details of available fonts</i> ................................................................................... 11.1.02</p>
<p>FOR <i>Structure: mark the beginning of a loop</i> .............................................................................................. 5.4.09</p>
<p>For <i>AMAL Structure: mark beginning of a loop</i> ......................................................................................... 7.6.05</p>
<p>FRAME LENGTH <i>Function: give frame length in bytes</i> ........................................................................... 7.5.04</p>
<p>FRAME LOAD <i>Function: load frames into memory</i> .................................................................................. 7.5.04</p>
<p>FRAME PARAM <i>Function: give parameter after playing a frame</i> ............................................................. 7.5.06</p>
<p>FRAME PLAY <i>Function: play frames on screen</i> ........................................................................................ 7.5.05</p>
<p>FRAME SKIP <i>Function: skip past an animation frame</i> .............................................................................. 7.5.06</p>
<p>FREE <i>Function: give free memory available in variable area</i> ....................................................................... 5.1.05</p>
<p>14.G.06</p>
<p>C</p>
<p>O</p>
<p>M</p>
<p>M</p>
<p>A</p>
<p>N</p>
<p>D</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Command Index</p>
<p>FREEZE <i>Instruction: freeze the display</i> ...................................................................................................... 7.5.07</p>
<p>FSEL$ <i>Function: select a file</i> ..................................................................................................................... 10.2.07</p>
<p>GB <i>Interface Instruction: draw a graphic filled box</i> ..................................................................................... 9.2.02</p>
<p>GE <i>Interface Instruction: draw an ellipse or circle</i> ...................................................................................... 9.2.04</p>
<p>GET <i>Instruction: read a record from random access file</i> ............................................................................ 10.2.15</p>
<p>GET BLOCK <i>Instruction: grab a screen block into memory</i> ....................................................................... 7.7.03</p>
<p>GET BOB <i>Instruction: grab an image from part of the screen</i> ..................................................................... 7.2.07</p>
<p>GET BOB PALETTE <i>Instruction: load image colours to current screen</i> .................................................... 7.2.04</p>
<p>GET CBLOCK <i>Instruction: save and compact a screen block</i> ..................................................................... 7.7.04</p>
<p>GET DISC FONTS <i>Instruction: create a list of available fonts from current disc</i> .................................... 11.1.02</p>
<p>GET FONTS <i>Instruction: create a list of available fonts from Rom and disc</i> ............................................ 11.1.01</p>
<p>GET ICON <i>Instruction: create an icon</i> ....................................................................................................... 7.7.01</p>
<p>GET ICON PALETTE <i>Instruction: load icon colours into current screen</i> ................................................. 7.7.01</p>
<p>GET PALETTE <i>Instruction: copy palette from a screen</i> ............................................................................. 6.1.10</p>
<p>GET ROM FONTS <i>Instruction: create a list of available ROM fonts</i> ...................................................... 11.1.02</p>
<p>GET SPRITE <i>Instruction: grab screen image into Object bank</i> .................................................................. 7.1.07</p>
<p>GET SPRITE PALETTE <i>Instruction: grab Sprite colours into current screen</i> ........................................... 7.1.07</p>
<p>GFXCALL <i>Function: call Graphics library</i> .............................................................................................. 11.5.03</p>
<p>GL <i>Interface Instruction: draw a line on screen</i> .......................................................................................... 9.2.04</p>
<p>GLOBAL <i>Structure: declare list of global variables</i> .................................................................................... 5.5.06</p>
<p>GOSUB <i>Structure: jump to a sub-routine</i> .................................................................................................. 5.4.02</p>
<p>GOTO <i>Structure: jump to defined position in a program</i> ........................................................................... 5.4.01</p>
<p>GR LOCATE <i>Instruction: position the graphics cursor</i> .............................................................................. 6.4.01</p>
<p>GR WRITING <i>Instruction: set the graphic writing mode</i> .......................................................................... 6.4.10</p>
<p>GS <i>Interface Instruction: draw a graphic hollow rectangle</i> ......................................................................... 9.2.03</p>
<p>HARDCOL <i>Function: return collision status after a Set Hardcol instruction</i> ........................................... 7.4.05</p>
<p>HCOS <i>Function: give hyperbolic cosine</i> ..................................................................................................... 5.3.10</p>
<p>HEX$ <i>Function: convert decimal value to hexadecimal number</i> .............................................................. 14.A.02</p>
<p>HIDE <i>Instruction: remove the mouse pointer from the screen</i> .................................................................... 5.8.03</p>
<p>HIDE ON <i>Instruction: keep mouse pointer hidden from the screen</i> ............................................................ 5.8.03</p>
<p>HIRES <i>Function: set screen mode to 640 pixels wide</i> .................................................................................. 6.1.02</p>
<p>HOME <i>Instruction: force the text cursor home</i> ........................................................................................... 5.6.06</p>
<p>HOT SPOT <i>Instruction: set reference point for all coordinate calculations</i> ................................................ 7.1.11</p>
<p>HREV <i>Function: flip an image horizontally</i> ............................................................................................... 7.2.10</p>
<p>HREV BLOCK <i>Instruction: flip a block horizontally</i> ................................................................................. 7.7.04</p>
<p>HS <i>Interface Instruction: create an animated horizontal slider bar</i> ............................................................. 9.3.07</p>
<p>HSCROLL <i>Instruction: scroll text horizontally</i> ......................................................................................... 5.6.12</p>
<p>HSIN <i>Function: give hyperbolic sine</i> .......................................................................................................... 5.3.09</p>
<p>HSLIDER <i>Instruction: draw a horizontal slider bar</i> ................................................................................... 5.7.05</p>
<p>HT <i>Interface Instruction: open an interactive text window</i> ........................................................................ 9.3.15</p>
<p>HTAN <i>Function: give hyperbolic tangent</i> .................................................................................................. 5.3.10</p>
<p>HUNT <i>Function: find a string of characters in memory</i> .......................................................................... 14.A.06</p>
<p>14.G.07</p>
<p>C</p>
<p>O</p>
<p>M</p>
<p>M</p>
<p>A</p>
<p>N</p>
<p>D</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Command Index</p>
<p>HZONE <i>Function: give screen zone under hardware coordinates</i> .............................................................. 7.4.07</p>
<p>I BOB <i>Function: get image number used by a Bob</i> ...................................................................................... 7.2.04</p>
<p>I SPRITE <i>Function: get image number used by a Sprite</i> ............................................................................. 7.1.09</p>
<p>ICon <i>Embedded Menu Command: draw an icon</i> ........................................................................................ 6.5.14</p>
<p>ICON BASE <i>Function: get icon base</i> .......................................................................................................... 5.9.11</p>
<p>IF <i>Structure: choose between alternative statements</i> ................................................................................... 5.4.03</p>
<p>IF <i>Interface Structure: mark the start of a conditional test</i> .......................................................................... 9.2.07</p>
<p>If <i>AMAL Structure perform a test</i> ............................................................................................................... 7.6.05</p>
<p>IFF ANIM <i>Instruction: play an animation file</i> ........................................................................................... 7.5.03</p>
<p>IL <i>Interface Instruction: display an inactive list window</i> ............................................................................ 9.3.11</p>
<p>IN <i>Interface Instruction: set the current drawing colour</i> ............................................................................ 9.2.03</p>
<p>INC <i>Instruction: increment an integer variable by one unit</i> ....................................................................... 5.3.02</p>
<p>INCLUDE <i>Instruction: specify a file for inclusion when testing a program</i> ............................................. 10.2.16</p>
<p>Ink <i>Embedded Menu Command: set colour</i> ................................................................................................. 6.5.14</p>
<p>INK <i>Instruction: set drawing colour</i> ........................................................................................................... 6.4.05</p>
<p>INKEY$ <i>Function: check for a key press</i> ................................................................................................... 10.1.01</p>
<p>INPUT <i>Instruction: load a value into a variable</i> ....................................................................................... 10.1.04</p>
<p>INPUT$ <i>Function: anticipate characters to be input into a string</i> ............................................................ 10.1.04</p>
<p>INPUT# <i>Structure: input variables from a file or device</i> ........................................................................... 10.2.12</p>
<p>INS BOB <i>Instruction: insert blank Bob image into Object bank</i> ................................................................. 7.2.10</p>
<p>INS ICON <i>Instruction: insert a blank icon image into the Icon bank</i> ......................................................... 7.7.02</p>
<p>INS SPRITE <i>Instruction: insert a blank Sprite image into the Object bank</i> ................................................ 7.1.05</p>
<p>INSTR <i>Function: search for one string inside another string</i> ...................................................................... 5.2.02</p>
<p>INT <i>Function: convert a floating point number into an integer</i> .................................................................. 5.3.04</p>
<p>INTCALL <i>Function: call Intuition library</i> ............................................................................................... 11.5.03</p>
<p>INVERSE OFF <i>Instruction: toggle inverse text off</i> .................................................................................... 5.6.03</p>
<p>INVERSE ON <i>Instruction: toggle inverse text on</i> ...................................................................................... 5.6.03</p>
<p>J0 AMAL <i>Function: give status of right joystick</i> ........................................................................................ 7.6.09</p>
<p>J1 AMAL <i>Function: give status of left joystick</i> ........................................................................................... 7.6.09</p>
<p>JDOWN <i>Function: test joystick for downward movement</i> ......................................................................... 5.8.02</p>
<p>JLEFT <i>Function: test joystick for left movement</i> ......................................................................................... 5.8.01</p>
<p>JOY <i>Function: read status of the joystick</i> .................................................................................................... 5.8.01</p>
<p>JRIGHT <i>Function: test joystick for right movement</i> ................................................................................... 5.8.02</p>
<p>JS <i>Interface Instruction: call an Interface sub-routine</i> ................................................................................. 9.2.07</p>
<p>JP <i>Interface Instruction: jump to an Interface program label</i> ....................................................................... 9.2.06</p>
<p>Jump <i>AMAL Instruction: jump to a label</i> ................................................................................................... 7.6.03</p>
<p>JUP <i>Function: test joystick for upward movement</i> ...................................................................................... 5.8.02</p>
<p>K1 <i>AMAL Function: give status of left mouse key</i> ...................................................................................... 7.6.09</p>
<p>K2 <i>AMAL Function: give status of right mouse key</i> ................................................................................... 7.6.09</p>
<p>KEY SHIFT <i>Function: test status of shift keys</i> ......................................................................................... 10.1.03</p>
<p>KEY SPEED <i>Instruction: set key repeat speed</i> .......................................................................................... 10.1.06</p>
<p>14.G.08</p>
<p>C</p>
<p>O</p>
<p>M</p>
<p>M</p>
<p>A</p>
<p>N</p>
<p>D</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Command Index</p>
<p>KEY STATE <i>Function: test for a specific key state</i> .................................................................................... 10.1.02</p>
<p>KEY$ <i>Reserved Variable: define a keyboard macro</i> .................................................................................... 10.1.06</p>
<p>KILL <i>Instruction: erase a file from the current disc</i> ................................................................................... 10.2.10</p>
<p>KILL EDITOR <i>Instruction: remove the AMOS Professional Editor from memory</i> .................................. 14.B.01</p>
<p>KY <i>Interface Instruction: set a keyboard short-cut</i> ...................................................................................... 9.1.14</p>
<p>LA <i>Interface Instruction: create a simple label</i> ............................................................................................ 9.2.06</p>
<p>LACED <i>Function: give value linked to screen resolution</i> ........................................................................... 6.1.13</p>
<p>LDIR <i>Instruction: output directory of the current disc to a printer</i> .......................................................... 10.2.04</p>
<p>LDIR/W <i>Instruction: output directory of disc in 2 columns to printer</i> ..................................................... 10.2.04</p>
<p>LED OFF <i>Instruction: toggle audio filter off</i> ............................................................................................... 8.1.08</p>
<p>LED ON <i>Instruction: toggle audio filter on</i> ................................................................................................ 8.1.08</p>
<p>LEEK <i>Function: read four bytes from an even address</i> ............................................................................. 14.A.04</p>
<p>LEFT$ <i>Function: give the leftmost characters of a string</i> ............................................................................ 5.2.01</p>
<p>LEN <i>Function: give the length of a string</i> ................................................................................................... 5.2.05</p>
<p>LENGTH <i>Function: give the length of a memory bank</i> .............................................................................. 5.9.08</p>
<p>Let AMAL <i>Instruction: assign a value to a register</i> ................................................................................... 7.6.04</p>
<p>LIB BASE <i>System Function: get the base address of system library</i> ......................................................... 11.5.02</p>
<p>LIB CALL <i>System Function: call a function from a system library</i> .......................................................... 11.5.01</p>
<p>LIB CLOSE <i>System Function: close one or all currently open system libraries</i> ........................................ 11.5.01</p>
<p>LIB OPEN <i>Instruction: open a system library for use</i> .............................................................................. 11.5.01</p>
<p>LIMIT BOB <i>Instruction: limit Bob to part of the screen</i> ............................................................................. 7.2.06</p>
<p>LIMIT MOUSE <i>Instruction: limit the mouse pointer to part of the screen</i> ................................................. 5.8.06</p>
<p>LIne <i>Interface Instruction: draw a line of Resource Bank image components</i> ............................................. 9.4.02</p>
<p>LIne <i>Embedded Menu Command: draw a line</i> ............................................................................................ 6.5.15</p>
<p>LINE INPUT <i>Instruction: input a list of variables separated by [Return]</i> ............................................... 10.1.05</p>
<p>LINE INPUT# <i>Structure: input list of variables not separated by a comma</i> ............................................. 10.2.12</p>
<p>LIST BANK <i>Instruction: list all current banks in memory</i> ........................................................................ 5.9.08</p>
<p>LN <i>Function: give natural logarithm</i> .......................................................................................................... 5.3.06</p>
<p>LOAD <i>IFF Instruction: load an IFF screen from disc</i> ................................................................................. 6.1.11</p>
<p>LOAD <i>Instruction: load one or more banks into memory</i> ........................................................................... 5.9.04</p>
<p>LOcate <i>Embedded Menu Command: move graphics cursor</i> ........................................................................ 6.5.13</p>
<p>LOCATE <i>Instruction: position the text cursor</i> ........................................................................................... 5.6.05</p>
<p>LOF <i>Function: give the length of an open file</i> ........................................................................................... 10.2.13</p>
<p>LOG <i>Function: give logarithm</i> .................................................................................................................... 5.3.06</p>
<p>LOGBASE <i>Function: give the address of logical screen bit-plane</i> ............................................................... 6.2.04</p>
<p>LOGIC <i>Function: give number of the logical screen</i> ................................................................................... 6.2.04</p>
<p>LOKE <i>Instruction: change a four-byte word at an even address</i> .............................................................. 14.A.04</p>
<p>LOOP <i>Structure: mark the end of a loop</i> ..................................................................................................... 5.4.06</p>
<p>LOWER$ <i>Function: convert a string of text to lower case</i> .......................................................................... 5.2.03</p>
<p>LOWRES <i>Function: set screen resolution to 320 pixels wide</i> ..................................................................... 6.1.02</p>
<p>LPRINT <i>Instruction: output a list of variables to a printer</i> ........................................................................ 5.6.14</p>
<p>LVO <i>Function: get the Library Vector Offset</i> ............................................................................................ 11.5.04</p>
<p>14.G.09</p>
<p>C</p>
<p>O</p>
<p>M</p>
<p>M</p>
<p>A</p>
<p>N</p>
<p>D</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Command Index</p>
<p>MAKE ICON MASK <i>Instruction: set colour zero to transparent</i> .............................................................. 7.7.03</p>
<p>MAKE MASK <i>Instruction: mask an image for collision detection</i> ............................................................. 7.4.02</p>
<p>MASK IFF <i>Instruction: mask IFF picture data</i> ........................................................................................... 7.5.07</p>
<p>MATCH <i>Function: search an array for a value</i> ........................................................................................... 5.2.06</p>
<p>MAX <i>Function: give the maximum of two values</i> ....................................................................................... 5.3.03</p>
<p>ME <i>Interface Function: return a message from the Resource Bank</i> ............................................................. 9.4.01</p>
<p>MED CONT <i>Instruction: continue a Med module</i> ..................................................................................... 8.3.04</p>
<p>MED LOAD <i>Instruction: load a Med music module</i> .................................................................................. 8.3.03</p>
<p>MED MIDI ON <i>Instruction: access MIDI instructions in a Med module</i> ................................................. 8.3.04</p>
<p>MED PLAY <i>Instruction: play a Med module</i> ............................................................................................. 8.3.04</p>
<p>MED STOP <i>Instruction: stop the current Med module</i> .............................................................................. 8.3.04</p>
<p>MEMORIZE X <i>Instruction: save the x-coordinate of the text cursor</i> ......................................................... 5.6.09</p>
<p>MEMORIZE Y <i>Instruction: save the y-coordinate of the text cursor</i> ......................................................... 5.6.09</p>
<p>MENU ACTIVE <i>Instruction: activate a menu item</i> ................................................................................... 6.5.08</p>
<p>MENU BAR <i>Instruction: display menu items as a vertical bar</i> .................................................................. 6.5.07</p>
<p>MENU BASE <i>Instruction: move the starting position of a menu</i> ............................................................... 6.5.11</p>
<p>MENU CALC <i>Instruction: recalculate a menu</i> .......................................................................................... 6.5.06</p>
<p>MENU CALLED <i>Instruction: re-draw a menu item continually</i> .............................................................. 6.5.17</p>
<p>MENU DEL <i>Instruction: delete one or more menu items</i> ........................................................................... 6.5.06</p>
<p>MENU INACTIVE <i>Instruction: turn off a menu item</i> .............................................................................. 6.5.08</p>
<p>MENU ITEM MOVABLE <i>Instruction: move individual menu items</i> ....................................................... 6.5.09</p>
<p>MENU ITEM STATIC <i>Instruction: fix menu items in a static position</i> .................................................... 6.5.09</p>
<p>MENU KEY <i>Instruction: assign a key to a menu item</i> ............................................................................... 6.5.12</p>
<p>MENU LINE <i>Instruction: display menu options in a horizontal line</i> ........................................................ 6.5.07</p>
<p>MENU LINK <i>Instruction: link a list of menu items</i> .................................................................................. 6.5.10</p>
<p>MENU MOUSE OFF <i>Instruction: toggle off menu under the mouse pointer</i> ............................................ 6.5.11</p>
<p>MENU MOUSE ON <i>Instruction: toggle on menu under the mouse pointer</i> ............................................. 6.5.11</p>
<p>MENU MOVABLE <i>Instruction: activate automatic menu movement</i> ....................................................... 6.5.09</p>
<p>MENU OFF <i>Instruction: de-activate a menu</i> ............................................................................................. 6.5.05</p>
<p>MENU ON <i>Instruction: activate a menu</i> ................................................................................................... 6.5.05</p>
<p>MENU ONCE <i>Instruction: turn off automatic menu re-drawing</i> ............................................................. 6.5.18</p>
<p>MENU SEPARATE <i>Instruction: separate a list of menu items</i> .................................................................. 6.5.10</p>
<p>MENU STATIC <i>Instruction: fix menu in a static position</i> ......................................................................... 6.5.09</p>
<p>MENU TLINE <i>Instruction: display menu as a total line</i> ........................................................................... 6.5.07</p>
<p>MENU TO BANK <i>Instruction: save menu definitions to memory bank</i> .................................................... 6.5.06</p>
<p>MENU$ <i>Reserved Variable: define a menu title or an option</i> ...................................................................... 6.5.01</p>
<p>MENU$ <i>Instruction: define appearance of a single item in a menu</i> ............................................................ 6.5.03</p>
<p>MID$ <i>Function: give characters from the middle of a string</i> ....................................................................... 5.2.02</p>
<p>MIN <i>Function: give the minimum of two values</i> ........................................................................................ 5.3.03</p>
<p>MKDIR <i>Instruction: create a folder</i> .......................................................................................................... 10.2.08</p>
<p>MONITOR <i>Instruction: call the AMOS Professional Monitor</i> ................................................................ 12.1.01</p>
<p>MOUSE CLICK <i>Function: check for mouse button click</i> ........................................................................... 5.8.05</p>
<p>MOUSE KEY <i>Function: read the status of mouse buttons</i> ......................................................................... 5.8.05</p>
<p>MOUSE SCREEN <i>Function: check which screen the mouse pointer is in</i> .................................................. 5.8.06</p>
<p>14.G.10</p>
<p>C</p>
<p>O</p>
<p>M</p>
<p>M</p>
<p>A</p>
<p>N</p>
<p>D</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Command Index</p>
<p>MOUSE ZONE <i>Function: check if mouse pointer is in a zone</i> ................................................................... 7.4.07</p>
<p>MOUTH HEIGHT <i>Function: give height of the narrator mouth</i> ............................................................. 11.2.03</p>
<p>MOUTH READ <i>Function: read position of the narrator voice</i> ................................................................. 11.2.03</p>
<p>MOUTH WIDTH <i>Function: give width of the narrator mouth</i> ............................................................... 11.2.03</p>
<p>MOVE FREEZE <i>Instruction: suspend Object movement</i> ........................................................................... 7.6.24</p>
<p>MOVE OFF <i>Instruction: toggle movements off</i> .......................................................................................... 7.6.23</p>
<p>MOVE ON <i>Instruction: toggle movements on</i> ........................................................................................... 7.6.23</p>
<p>MOVE X <i>Instruction: move an Object horizontally</i> ................................................................................... 7.6.22</p>
<p>MOVE Y <i>Instruction: move an Object vertically</i> ........................................................................................ 7.6.23</p>
<p>Move <i>AMAL Instruction: move an Object</i> ................................................................................................. 7.6.02</p>
<p>MOVON <i>Function: give movement status</i> ................................................................................................. 7.6.23</p>
<p>MULTI WAIT <i>Instruction: force a multi-task Wait Vbl</i> ........................................................................... 11.4.01</p>
<p>MUSIC <i>Instruction: play a piece of AMOS Professional music</i> .................................................................. 8.3.01</p>
<p>MUSIC OFF <i>Instruction: turn off all music</i> ............................................................................................... 8.3.01</p>
<p>MUSIC STOP <i>Instruction: stop a single passage of music</i> ......................................................................... 8.3.01</p>
<p>MVOLUME <i>Instruction: set the volume of a piece of music</i> ...................................................................... 8.3.01</p>
<p>NEXT <i>Structure: match a For in a loop</i> ...................................................................................................... 5.4.09</p>
<p>Next <i>AMAL Structure: counter for a loop</i> .................................................................................................. 7.6.05</p>
<p>NO ICON MASK <i>Instruction: remove colour zero from Icon</i> .................................................................... 7.7.03</p>
<p>NO MASK <i>Instruction: remove colour zero mask from a Bob</i> .................................................................... 7.2.04</p>
<p>NOISE TO <i>Instruction: assign a noise wave to a sound channel</i> ................................................................ 8.1.07</p>
<p>NOT <i>Structure: logical NOT operation</i> ...................................................................................................... 5.4.06</p>
<p>NTSC <i>Function: identify an NTSC or PAL machine</i> ............................................................................... 14.C.03</p>
<p>NW <i>Interface Instruction: specify a quick-release button</i> ............................................................................ 9.1.14</p>
<p>ON <i>Structure: jump on recognising a variable</i> ........................................................................................... 5.4.10</p>
<p>On <i>AMAL Instruction: activate main program after Wait</i> ......................................................................... 7.6.06</p>
<p>ON BREAK PROC <i>Structure: jump to a procedure when break in program</i> ............................................. 5.5.04</p>
<p>ON ERROR <i>Structure: trap an error within a program</i> ........................................................................... 12.2.01</p>
<p>ON ERROR PROC <i>Structure: trap an error using a procedure</i> ............................................................... 12.2.02</p>
<p>ON MENU DEL <i>Instruction: delete labels and procedures used by On Menu</i> .......................................... 6.5.05</p>
<p>ON MENU GOSUB <i>Instruction: automatic menu selection</i> ..................................................................... 6.5.04</p>
<p>ON MENU GOTO <i>Instruction: automatic menu selection</i> ....................................................................... 6.5.05</p>
<p>ON MENU PROC <i>Instruction: automatic menu selection</i> ........................................................................ 6.5.04</p>
<p>ON MENU OFF <i>Instruction: toggle automatic menu selection off</i> ...........................................................  6.5.05</p>
<p>ON MENU ON <i>Instruction: toggle automatic menu selection on</i> ............................................................. 6.5.05</p>
<p>ON PROC <i>Structure: trigger a jump to a procedure</i> .................................................................................. 5.5.03</p>
<p>OPEN IN <i>Instruction: open a file for input</i> .............................................................................................. 10.2.11</p>
<p>OPEN OUT <i>Instruction: open a file for output</i> ........................................................................................ 10.2.11</p>
<p>OPEN PORT <i>Instruction: open a channel to an IO port</i> .......................................................................... 10.3.06</p>
<p>OPEN RANDOM <i>Instruction: open a channel to a random access file</i> ................................................... 10.2.14</p>
<p>OR <i>Structure: qualify a condition</i> ............................................................................................................... 5.4.03</p>
<p>OUtline <i>Embedded Menu Command: enclose a bar with an outline</i> ........................................................... 6.5.15</p>
<p>14.G.11</p>
<p>C</p>
<p>O</p>
<p>M</p>
<p>M</p>
<p>A</p>
<p>N</p>
<p>D</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Command Index</p>
<p>PACK <i>Picture Compactor Extension: pack screen data</i> ............................................................................... 6.2.06</p>
<p>PAINT <i>Instruction: fill a screen area with colour</i> ....................................................................................... 6.4.07</p>
<p>PALETTE <i>Instruction: set the current screen colours</i> ................................................................................ 6.4.06</p>
<p>PAPER <i>Instruction: set the colour of text background</i> ................................................................................ 5.6.02</p>
<p>PAPER$ <i>Function: give control index number to set background colour</i> .................................................... 5.6.03</p>
<p>PARALLEL ABORT <i>Instruction: stop a parallel operation</i> ..................................................................... 10.5.02</p>
<p>PARALLEL BASE <i>Function: get the base address of the Parallel Port</i> ..................................................... 10.5.03</p>
<p>PARALLEL CHECK <i>Function: report the availability of the Parallel port</i> .............................................. 10.5.02</p>
<p>PARALLEL CLOSE <i>Instruction: close the Parallel Port</i> ......................................................................... 10.5.01</p>
<p>PARALLEL ERROR <i>Function: check for an error in transmission via Parallel Port</i> ............................... 10.5.02</p>
<p>PARALLEL INPUT$ <i>Function: read a string from the Parallel Port</i> ...................................................... 10.5.02</p>
<p>PARALLEL OPEN <i>Instruction: open the Parallel Port for reading and writing</i> ..................................... 10.5.01</p>
<p>PARALLEL OUT <i>Instruction: send data from memory to the Parallel Port</i> ............................................ 10.5.02</p>
<p>PARALLEL SEND <i>Instruction: send a string of characters to the Parallel Port</i> ...................................... 10.5.01</p>
<p>PARALLEL STATUS <i>Function: report the current status of the Parallel Port</i> ........................................ 10.5.03</p>
<p>PARAM <i>Function: return a parameter from a procedure</i> ........................................................................... 5.5.08</p>
<p>PARAM# <i>Function: return a real number variable from a procedure</i> ......................................................... 5.5.08</p>
<p>PARAM$ <i>Function: return a string variable from a procedure</i> .................................................................. 5.5.08</p>
<p>PARENT <i>Instruction: negotiate a path through the current directory</i> ...................................................... 10.2.05</p>
<p>PASTE BOB <i>Instruction: draw an image from the Object bank</i> .................................................................. 7.2.08</p>
<p>PASTE ICON <i>Instruction: draw an Icon</i> ................................................................................................... 7.7.02</p>
<p>PAttern <i>Embedded Menu Command: set a pattern</i> ..................................................................................... 6.5.15</p>
<p>Pause <i>AMAL Instruction: pause an AMAL program</i> ................................................................................. 7.6.06</p>
<p>PEEK <i>Function: read a byte from an address</i> ........................................................................................... 14.A.03</p>
<p>PEEK$ <i>Function: read a string of characters from memory</i> ..................................................................... 14.A.05</p>
<p>PEN <i>Instruction: set the colour for text and drawing operations</i> ................................................................ 5.6.02</p>
<p>PEN$ <i>Function: give a control index number to set pen colour</i> .................................................................. 5.6.02</p>
<p>PHYBASE <i>Function: give address of the current screen</i> ............................................................................. 6.2.04</p>
<p>PHYSIC <i>Function: give the physical screen number</i> .................................................................................. 6.2.04</p>
<p>PI# <i>Function: give a constant</i> ................................................................................................................. PI 5.3.07</p>
<p>PICTURE <i>Function: give mask data of an IFF image</i> ................................................................................. 7.5.07</p>
<p>PLAY <i>Instruction: play a voice</i> ................................................................................................................... 8.1.04</p>
<p>PLAY OFF <i>Instruction: stop playing a voice</i> .............................................................................................. 8.1.04</p>
<p>PLay <i>AMAL Instruction: create a movement path</i> ..................................................................................... 7.6.07</p>
<p>PLOAD <i>Instruction: load machine code from memory</i> ............................................................................ 14.A.14</p>
<p>PLOT <i>Instruction: plot a single point</i> ......................................................................................................... 6.4.01</p>
<p>PO <i>Interface Instruction: print hollow outline text</i> ..................................................................................... 9.2.04</p>
<p>POF <i>Reserved Variable: hold the current position of the file pointer</i> .......................................................... 10.2.13</p>
<p>POINT <i>Function: give the colour of a point</i> ................................................................................................ 6.4.01</p>
<p>POKE <i>Instruction: change a byte at an address</i> ....................................................................................... 14.A.03</p>
<p>POKE$ <i>Instruction: poke a string of characters into memory</i> .................................................................. 14.A.04</p>
<p>POLYGON <i>Instruction: draw a filled polygon</i> ........................................................................................... 6.4.08</p>
<p>POLYLINE <i>Instruction: draw multiple lines</i> ............................................................................................  6.4.03</p>
<p>POP <i>Instruction: remove Return information</i> ............................................................................................. 5.4.02</p>
<p>14.G.12</p>
<p>C</p>
<p>O</p>
<p>M</p>
<p>M</p>
<p>A</p>
<p>N</p>
<p>D</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Command Index</p>
<p>POP PROC <i>Structure: leave a procedure immediately</i> ................................................................................ 5.5.03</p>
<p>PORT <i>Function: test the readiness of a device</i> ........................................................................................... 10.3.07</p>
<p>PR Interface <i>Instruction: print the contents of a variable to the screen</i> ...................................................... 9.1.04</p>
<p>PRG STATE <i>Function: return status of how current program was run</i> ................................................... 11.4.04</p>
<p>PRG UNDER <i>Function: report the availability of program under current program</i> ................................ 11.4.03</p>
<p>PRINT <i>Instruction: print items on screen</i> .................................................................................................. 5.6.01</p>
<p>PRINT# <i>Structure: print variables to a file or device</i> ................................................................................ 10.2.12</p>
<p>PRINTER ABORT <i>Instruction: stop a printer operation</i> ......................................................................... 10.3.05</p>
<p>PRINTER BASE <i>Function: get the address of printer base</i> ....................................................................... 10.3.06</p>
<p>PRINTER CHECK <i>Function: give status of printer</i> ................................................................................ 10.3.05</p>
<p>PRINTER CLOSE <i>Instruction: close printer port</i> .................................................................................... 10.3.01</p>
<p>PRINTER DUMP <i>Instruction: print the contents of a screen</i> .................................................................. 10.3.03</p>
<p>PRINTER ERROR <i>Function: check for an error in a printing operation</i> .................................................. 10.3.06</p>
<p>PRINTER ONLINE <i>Function: report if printer is on-line</i> ....................................................................... 10.3.06</p>
<p>PRINTER OPEN <i>Instruction: open printer device</i> ................................................................................... 10.3.01</p>
<p>PRINTER OUT <i>Instruction: print data from an address</i> .......................................................................... 10.3.05</p>
<p>PRINTER SEND <i>Instruction: send a string to the printer</i> ....................................................................... 10.3.01</p>
<p>PRIORITY OFF <i>Instruction: set Bob priority to default status</i> .................................................................. 7.2.05</p>
<p>PRIORITY ON <i>Instruction: set Bob priority to highest y-coordinate</i> ......................................................... 7.2.05</p>
<p>PRIORITY REVERSE OFF <i>Instruction: toggle off reverse priority of Bobs</i> ............................................... 7.2.05</p>
<p>PRIORITY REVERSE ON <i>Instruction: toggle on reverse priority of Bobs</i> ................................................ 7.2.05</p>
<p>PROC <i>Structure: call a procedure</i> ............................................................................................................... 5.5.02</p>
<p>PRoc <i>Embedded Menu Command: call a procedure</i> .................................................................................... 6.5.16</p>
<p>PROCEDURE <i>Structure: create a procedure</i> .............................................................................................. 5.5.01</p>
<p>PRUN <i>Instruction: run a program from memory</i> ..................................................................................... 11.4.02</p>
<p>PU <i>Interface Instruction: push image to an offset position in the Resource Bank</i> ........................................ 9.4.03</p>
<p>PUT <i>Instruction: output a record to a random access file</i> .......................................................................... 10.2.15</p>
<p>PUT BLOCK <i>Instruction: copy a block onto screen</i> .................................................................................... 7.7.03</p>
<p>PUT BOB <i>Instruction: put a fixed copy of Bob onto screen</i> ......................................................................... 7.2.08</p>
<p>PUT CBLOCK <i>Instruction: display a compacted block on screen</i> .............................................................. 7.7.05</p>
<p>PUT KEY <i>Instruction: load a string into the keyboard buffer</i> ................................................................... 10.1.05</p>
<p>RADIAN <i>Instruction: use radians</i> ............................................................................................................. 5.3.08</p>
<p>RAIN <i>Reserved Variable: change the colour of a rainbow line</i> ..................................................................... 6.3.05</p>
<p>RAINBOW <i>Instruction: display a rainbow</i> ................................................................................................ 6.3.05</p>
<p>RAINBOW DEL <i>Instruction: delete a rainbow</i> .......................................................................................... 6.3.05</p>
<p>RANDOMIZE <i>Instruction: set random number seed</i> ................................................................................ 5.3.10</p>
<p>RDIALOG <i>Function: read the status of a zone or a button</i> ........................................................................ 9.3.04</p>
<p>RDIALOG$ <i>Function: return text string entered into an edit zone</i> ........................................................... 9.3.04</p>
<p>READ <i>Structure: read data into a variable</i> ................................................................................................. 5.4.13</p>
<p>READ TEXT$ <i>Instruction: display a text window on screen</i> ..................................................................... 5.7.06</p>
<p>REM <i>Structure: insert a reminder message or comment into program listing</i> .............................................. 5.1.1</p>
<p>REMEMBER X <i>Instruction: restore the x-coordinate of the text cursor</i> ..................................................... 5.6.10</p>
<p>REMEMBER Y <i>Instruction: restore the y-coordinate of the text cursor</i> ..................................................... 5.6.10</p>
<p>14.G.13</p>
<p>C</p>
<p>O</p>
<p>M</p>
<p>M</p>
<p>A</p>
<p>N</p>
<p>D</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Command Index</p>
<p>RENAME <i>Instruction: rename a file</i> ........................................................................................................ 10.2.08</p>
<p>REPEAT <i>Structure: mark the start of a conditional loop</i> ............................................................................ 5.4.08</p>
<p>REPEAT$ <i>Function: repeat a string</i> ........................................................................................................... 5.2.04</p>
<p>REQUEST OFF <i>Instruction: cancel the requester</i> .................................................................................... 11.5.06</p>
<p>REQUEST ON <i>Instruction: use the AMOS Professional system requester</i> ............................................. 11.5.06</p>
<p>REQUEST WB <i>Instruction: use the Workbench system requester</i> ............................................................ 11.5.06</p>
<p>REserve <i>Embedded Menu Command: reserve data area for a procedure</i> ..................................................... 6.5.17</p>
<p>RESERVE AS CHIP DATA <i>Instruction: reserve a new chip data bank</i> ..................................................... 5.9.03</p>
<p>RESERVE AS CHIP WORK <i>Instruction: reserve a new chip work bank</i> .................................................. 5.9.03</p>
<p>RESERVE AS DATA <i>Instruction: reserve a new data bank</i> ....................................................................... 5.9.02</p>
<p>RESERVE AS WORK <i>Instruction: reserve a new work bank</i> ..................................................................... 5.9.02</p>
<p>RESERVE ZONE <i>Instruction: allocate memory for screen zone</i> ................................................................ 7.4.06</p>
<p>RESET ZONE <i>Instruction: erase screen zone</i> ............................................................................................. 7.4.07</p>
<p>RESOURCE$ <i>Function: read a message from the Resource Bank</i> ............................................................... 9.4.03</p>
<p>RESOURCE BANK <i>Instruction: select a bank to be used for resources</i> ..................................................... 9.4.03</p>
<p>RESOURCE SCREEN OPEN <i>Instruction: open a screen using resource settings</i> .................................... 9.4.04</p>
<p>RESOURCE UNPACK <i>Instruction: unpack an image from the Resource Bank</i> ........................................ 9.4.04</p>
<p>RESTORE <i>Structure: set the current Read pointer</i> ..................................................................................... 5.4.13</p>
<p>RESUME <i>Structure: resume program after error trapping</i> ....................................................................... 12.2.02</p>
<p>RESUME LABEL <i>Structure: jump to label after error trapping</i> ............................................................... 12.2.03</p>
<p>RESUME NEXT <i>Instruction: jump to the instruction following one that caused error</i> ........................... 12.2.02</p>
<p>RETURN <i>Instruction: return from a sub-routine</i> ....................................................................................... 5.4.02</p>
<p>REV <i>Function: double-flip an image vertically and horizontally</i> ................................................................ 7.2.12</p>
<p>RIGHT$ <i>Function: give the rightmost characters of a string</i> ...................................................................... 5.2.01</p>
<p>RND <i>Function: generate random number</i> .................................................................................................. 5.3.10</p>
<p>ROL.B <i>Instruction: rotate left the first 8 bits of a value</i> ........................................................................... 14.A.09</p>
<p>ROL.L <i>Instruction: rotate left the entire number</i> ..................................................................................... 14.A.09</p>
<p>ROL.W <i>Instruction: rotate left the bottom 16 bits of a value</i> ................................................................... 14.A.09</p>
<p>ROR.B <i>Instruction: rotate right the first 8 bits of a value</i> ........................................................................ 14.A.10</p>
<p>ROR.L <i>Instruction: rotate right the entire number</i> .................................................................................. 14.A.10</p>
<p>ROR.W <i>Instruction: rotate right the bottom 16 bits of a value</i> ................................................................ 14.A.10</p>
<p>RT <i>Interface Instruction: return from an Interface sub-routine</i> .................................................................. 9.2.07</p>
<p>RU <i>Interface Instruction: run until conditions are satisfied</i> ........................................................................ 9.1.08</p>
<p>RUN <i>Instruction: execute an AMOS Professional program</i> ..................................................................... 10.2.08</p>
<p>SA <i>Interface Instruction: save background under a dialogue box</i> ................................................................ 9.1.08</p>
<p>SAM BANK <i>Instruction: change the current sample bank</i> ......................................................................... 8.2.03</p>
<p>SAM LOOP OFF <i>Instruction: toggle off repetition loop of sample</i> ............................................................. 8.2.04</p>
<p>SAM LOOP ON <i>Instruction: toggle on repetition loop of a sample</i> ........................................................... 8.2.04</p>
<p>SAM PLAY <i>Instruction: play a sample from the sample bank</i> .................................................................... 8.2.01</p>
<p>SAM RAW <i>Instruction: play a raw sample from memory</i> .......................................................................... 8.2.03</p>
<p>SAM STOP <i>Instruction: stop one or more samples playing</i> ........................................................................ 8.2.02</p>
<p>SAM SWAP <i>Instruction: activate sample-switching system</i> ...................................................................... 8.2.06</p>
<p>SAM SWAPPED <i>Function: test for a successful sample swap</i> ................................................................... 8.2.06</p>
<p>14.G.14</p>
<p>C</p>
<p>O</p>
<p>M</p>
<p>M</p>
<p>A</p>
<p>N</p>
<p>D</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Command Index</p>
<p>SAMPLE <i>Instruction: assign a sample to the current wave</i> ........................................................................ 8.1.07</p>
<p>SAVE IFF <i>Instruction: save an IFF screen to disc</i> ....................................................................................... 6.1.11</p>
<p>SAVE <i>Instruction: save one or more memory banks to disc</i> ......................................................................... 5.9.03</p>
<p>SAY <i>Instruction: speak a phrase</i> ................................................................................................................ 11.2.01</p>
<p>SC AMAL <i>Function: check for Sprite collision</i> ........................................................................................... 7.6.09</p>
<p>SCAN$ <i>Function: return a scan-code for use with Key$ function</i> ............................................................ 10.1.06</p>
<p>SCANCODE <i>Function: give the scancode of a key</i> ................................................................................... 10.1.01</p>
<p>SCANSHIFT <i>Function: give shift status of key</i> ........................................................................................ 10.1.02</p>
<p>SCIN <i>Function: give screen number at hardware coordinates</i> ..................................................................... 6.1.11</p>
<p>SCREEN <i>Instruction: set the current screen</i> .............................................................................................. 6.1.09</p>
<p>SCREEN <i>Function: give the current screen number</i> ................................................................................... 6.1.10</p>
<p>SCREEN <i>BASE Function: get screen table</i> ................................................................................................. 5.9.11</p>
<p>SCREEN CLONE <i>Instruction: clone a screen</i> ............................................................................................ 6.1.06</p>
<p>SCREEN CLOSE <i>Instruction: erase a screen</i> ............................................................................................. 6.1.03</p>
<p>SCREEN COLOUR <i>Function: give maximum number of available screen colours</i> ................................... 6.1.10</p>
<p>SCREEN COPY <i>Instruction: copy an area of screen</i> .................................................................................. 6.2.01</p>
<p>SCREEN DISPLAY <i>Instruction: position a screen</i> ..................................................................................... 6.1.04</p>
<p>SCREEN HEIGHT <i>Function: give the current screen height</i> .................................................................... 6.1.10</p>
<p>SCREEN HIDE <i>Instruction: hide a screen</i> ................................................................................................. 6.1.08</p>
<p>SCREEN MODE <i>Function: return screen mode</i> ........................................................................................ 6.1.13</p>
<p>SCREEN OFFSET <i>Instruction: offset the screen at hardware coordinates</i> ................................................. 6.1.05</p>
<p>SCREEN OPEN <i>Instruction: open a new screen</i> ........................................................................................ 6.1.01</p>
<p>SCREEN SHOW <i>Instruction: show a screen</i> ............................................................................................. 6.1.08</p>
<p>SCREEN SWAP <i>Instruction: swap over the logical and physical screens</i> .................................................. 6.2.03</p>
<p>SCREEN TO BACK <i>Instruction: move screen to the back of the display</i> ................................................... 6.1.09</p>
<p>SCREEN TO FRONT <i>Instruction: move screen to the front of the display</i> ................................................ 6.1.08</p>
<p>SCREEN WIDTH <i>Function: give the current screen width</i> ....................................................................... 6.1.10</p>
<p>SCROLL <i>Instruction: scroll a screen zone</i> .................................................................................................. 6.2.02</p>
<p>SCROLL OFF <i>Instruction: toggle window scroll off</i> .................................................................................. 5.7.04</p>
<p>SCROLL ON <i>Instruction: toggle window scroll on</i> .................................................................................... 5.7.04</p>
<p>SERIAL ABORT <i>Instruction: stop current data transfer</i> ......................................................................... 10.4.06</p>
<p>SERIAL BASE <i>Function: get the address of the serial base</i> ....................................................................... 10.4.06</p>
<p>SERIAL BITS <i>Instruction: set the number of bits for transmission of characters</i> ..................................... 10.4.02</p>
<p>SERIAL BUF <i>Instruction: set the size of the serial buffer</i> ......................................................................... 10.4.04</p>
<p>SERIAL CHECK <i>Function: report current serial device activity</i> ............................................................. 10.4.05</p>
<p>SERIAL CLOSE <i>Instruction: close one or more serial channels</i> ............................................................... 10.4.02</p>
<p>SERIAL ERROR <i>Function: report success or failure of last data transfer</i> ................................................ 10.4.05</p>
<p>SERIAL FAST <i>Instruction: engage fast mode for data transfer</i> ................................................................ 10.4.04</p>
<p>SERIAL GET <i>Function: get a byte from a serial channel</i> .......................................................................... 10.4.03</p>
<p>SERIAL INPUT$ <i>Function: get a string from the serial port</i> ................................................................... 10.4.04</p>
<p>SERIAL OPEN <i>Instruction: open a channel for serial input/output</i> ........................................................ 10.4.01</p>
<p>SERIAL OUT <i>Instruction: output a block of raw data via a serial channel</i> .............................................. 10.4.03</p>
<p>SERIAL PARITY <i>Instruction: set parity checking for a serial channel</i> ..................................................... 10.4.02</p>
<p>SERIAL SEND <i>Instruction: output a string via a serial channel</i> ............................................................. 10.4.03</p>
<p>14.G.15</p>
<p>C</p>
<p>O</p>
<p>M</p>
<p>M</p>
<p>A</p>
<p>N</p>
<p>D</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Command Index</p>
<p>SERIAL SLOW <i>Instruction: re-set slow mode for data transfer</i> ............................................................... 10.4.04</p>
<p>SERIAL SPEED <i>Instruction: set the transfer rate for a serial channel</i> ..................................................... 10.4.02</p>
<p>SERIAL STATUS <i>Function: report the status of the Serial Port</i> ............................................................... 10.4.05</p>
<p>SERIAL X <i>Instruction: set handshaking system for serial channel</i> ........................................................... 10.4.03</p>
<p>SET ACCESSORY <i>Instruction: define an accessory program</i> .................................................................. 13.1.01</p>
<p>SET BOB <i>Instruction: set drawing mode for Bobs</i> ...................................................................................... 7.3.07</p>
<p>SET BUFFER <i>Instruction: set the size of the variable area</i> .......................................................................... 5.1.04</p>
<p>SET CURS <i>Instruction: set the shape of the text cursor</i> .............................................................................. 5.6.10</p>
<p>SET DIR <i>Instruction: set the directory style</i> ............................................................................................. 10.2.04</p>
<p>SET DOUBLE PRECISION <i>Instruction: engage double precision accuracy</i> ............................................. 5.3.06</p>
<p>SET ENVEL <i>Instruction: create a volume envelope</i> .................................................................................... 8.1.08</p>
<p>SET EQUATE BANK <i>Instruction: set up the automatic equate system</i> .................................................. 11.5.03</p>
<p>SET FONT <i>Instruction: select font for use by the Text command</i> ............................................................. 11.1.02</p>
<p>SET HARDCOL <i>Instruction: set hardware register for Sprite collision detection</i> ...................................... 7.4.05</p>
<p>SET INPUT <i>Instruction: set end-of-line characters</i> .................................................................................. 10.2.13</p>
<p>SET LINE <i>Instruction: set a line style</i> ........................................................................................................ 6.4.03</p>
<p>SET MENU <i>Instruction: move a menu item</i> ............................................................................................... 6.5.11</p>
<p>SET PAINT <i>Instruction: toggle outline mode</i> ............................................................................................. 6.4.10</p>
<p>SET PATTERN <i>Instruction: select a fill pattern</i> ......................................................................................... 6.4.08</p>
<p>SET RAINBOW <i>Instruction: define a rainbow</i> .......................................................................................... 6.3.04</p>
<p>SET SLIDER <i>Instruction: set a fill pattern for a slider bar</i> ......................................................................... 5.7.05</p>
<p>SET SPRITE BUFFER <i>Instruction: the the maximum height of Sprites</i> ..................................................... 7.1.08</p>
<p>SET STACK <i>Instruction: set stack space</i> .................................................................................................... 5.5.01</p>
<p>SET TAB <i>Instruction: change Tab setting</i> ................................................................................................... 5.6.08</p>
<p>SET TALK <i>Instruction: set the style of synthetic speech</i> ........................................................................... 11.2.01</p>
<p>SET TEMPRAS <i>Instruction: set temporary raster</i> ..................................................................................... 6.4.11</p>
<p>SET TEXT <i>Instruction: set the style of text font</i> ......................................................................................... 5.6.04</p>
<p>SET WAVE <i>Instruction: define a wave form</i> ............................................................................................... 8.1.05</p>
<p>SET ZONE <i>Instruction: set a screen zone for testing</i> ................................................................................. 7.4.06</p>
<p>SFont <i>Embedded Menu Command: set font</i> ................................................................................................ 6.5.14</p>
<p>SF <i>Interface Instruction: select font to be assigned to text</i> ........................................................................... 9.2.05</p>
<p>SGN <i>Function: give the sign of a number</i> ................................................................................................... 5.3.04</p>
<p>SH <i>Interface Function: read the height of the current screen</i> ....................................................................... 9.2.01</p>
<p>SHADE OFF <i>Instruction: toggle text shading off</i> ...................................................................................... 5.6.03</p>
<p>SHADE ON <i>Instruction: toggle text shading on</i> ........................................................................................ 5.6.03</p>
<p>SHARED <i>Structure: define a list of shared variables</i> .................................................................................. 5.5.05</p>
<p>SHIFT DOWN <i>Instruction: rotate colour values downwards</i> .................................................................... 6.3.03</p>
<p>SHIFT OFF <i>Instruction: turn off colour shifts for current screens</i> ............................................................. 6.3.04</p>
<p>SHIFT UP <i>Instruction: rotate colour values upwards</i> ................................................................................. 6.3.03</p>
<p>SHOOT <i>Instruction: generate percussion sound effect</i> ............................................................................... 8.1.01</p>
<p>SHOW <i>Instruction: reveal the mouse pointer back on screen</i> ..................................................................... 5.8.03</p>
<p>SHOW ON <i>Instruction: reveal the mouse pointer immediately</i> ................................................................. 5.8.03</p>
<p>SI Interface <i>Instruction: define the size of graphics to be saved</i> .................................................................. 9.1.07</p>
<p>SIN <i>Function: give the sine of an angle</i> ....................................................................................................... 5.3.08</p>
<p>14.G.16</p>
<p>C</p>
<p>O</p>
<p>M</p>
<p>M</p>
<p>A</p>
<p>N</p>
<p>D</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Command Index</p>
<p>SL <i>Interface Instruction: set the style of a line</i> ............................................................................................. 9.2.04</p>
<p>SLine <i>Embedded Menu Command: set line pattern</i> .................................................................................... 6.5.15</p>
<p>SLOAD <i>Instruction: load a section of a sample</i> .......................................................................................... 8.2.05</p>
<p>SM <i>Interface Instruction: move a screen linked to the mouse pointer</i> .......................................................... 9.3.17</p>
<p>SORT <i>Instruction: sort all elements in an array</i> ......................................................................................... 5.2.05</p>
<p>SP <i>Interface Instruction: set the fill pattern for a dialogue box</i> .................................................................... 9.2.03</p>
<p>SPACE$ <i>Function: space out a string</i> ......................................................................................................... 5.2.04</p>
<p>SPACK <i>Picture Compactor Extension: pack a screen</i> .................................................................................. 6.2.05</p>
<p>SPRITE <i>Instruction: display a Sprite on screen</i> .......................................................................................... 7.1.04</p>
<p>SPRITE BASE <i>Function: get Sprite table</i> ................................................................................................... 5.9.11</p>
<p>SPRITEBOB COL <i>Function: test for a collision between Sprite and Bobs</i> .................................................. 7.4.04</p>
<p>SPRITE COL <i>Function: test for a collision between Sprites</i> ....................................................................... 7.4.03</p>
<p>SPRITE OFF <i>Instruction: remove Sprites from the screen</i> .......................................................................... 7.1.08</p>
<p>SPRITE UPDATE <i>Instruction: control Sprite movements</i> ......................................................................... 7.1.08</p>
<p>SPRITE UPDATE OFF <i>Instruction: turn off automatic Sprite updating</i> .................................................. 7.1.08</p>
<p>SPRITE UPDATE ON <i>Instruction: turn on automatic Sprite updating</i> ................................................... 7.1.08</p>
<p>SSAVE <i>Instruction: save a data chunk anywhere into an existing file</i> ........................................................ 8.2.05</p>
<p>SQR <i>Function: calculate square root of a number</i> ....................................................................................... 5.3.06</p>
<p>SStyle <i>Embedded Menu Command: set font style</i> ....................................................................................... 6.5.15</p>
<p>START <i>Function: give the address of a memory bank</i> ................................................................................. 5.9.09</p>
<p>STEP <i>Structure: control the increment index in a loop</i> ............................................................................... 5.4.09</p>
<p>STOP <i>Instruction: interrupt the current program</i> ...................................................................................... 5.1.08</p>
<p>STR$ <i>Function: convert a number into a string</i> .......................................................................................... 5.2.03</p>
<p>STRUC <i>Reserved Variable: access internal data structure</i> ........................................................................ 11.5.04</p>
<p>STRUC$ <i>Function: read or write a string pointer to a structure</i> .............................................................. 11.5.05</p>
<p>STRING$ <i>Function: create a new string from an existing string</i> ............................................................... 5.2.04</p>
<p>SV <i>Interface Instruction: set an Interface variable</i> ...................................................................................... 9.1.03</p>
<p>SW <i>Interface Function: read the width of the current screen</i> ....................................................................... 9.2.01</p>
<p>SW <i>Interface Instruction :set the writing mode for text and graphics</i> ......................................................... 9.2.05</p>
<p>SWAP <i>Structure: swap over the contents of two variables</i> .......................................................................... 5.4.06</p>
<p>SX <i>Interface Function: get the width of a dialogue box</i> ................................................................................ 9.2.01</p>
<p>SY <i>Interface Function: get the height of a dialogue box</i> ............................................................................... 9.2.01</p>
<p>SYNCHRO <i>Instruction: execute an AMAL program directly</i> .................................................................... 7.6.13</p>
<p>SYNCHRO OFF <i>Instruction: turn off interrupts</i> ...................................................................................... 7.6.13</p>
<p>SYNCHRO ON <i>Instruction: turn on interrupts</i> ....................................................................................... 7.6.13</p>
<p>SYSTEM <i>Instruction: leave AMOS Professional and go to the Workbench</i> ................................................ 5.1.09</p>
<p>SZ <i>Interface Instruction: save a parameter for the next zone definition</i> ...................................................... 9.2.09</p>
<p>TAB$ <i>Function: move the text cursor to the next Tab position</i> .................................................................... 5.6.07</p>
<p>TALK MISC <i>Instruction: set narrator voice</i> ............................................................................................. 11.2.02</p>
<p>TALK STOP <i>Instruction: stop synthetic speech</i> ....................................................................................... 11.2.02</p>
<p>TAN <i>Function: give the tangent of an angle</i> ............................................................................................... 5.3.09</p>
<p>TEMPO <i>Instruction: change the speed of a piece of music</i> .......................................................................... 8.3.02</p>
<p>TEXT <i>Instruction: print graphic text</i> ........................................................................................................ 11.1.03</p>
<p>14.G.17</p>
<p>C</p>
<p>O</p>
<p>M</p>
<p>M</p>
<p>A</p>
<p>N</p>
<p>D</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Command Index</p>
<p>TEXT BASE <i>Function: give the text base of the current character set</i> ...................................................... 11.1.03</p>
<p>TEXT LENGTH <i>Function: give the length of a section of graphical text</i> ................................................. 11.1.03</p>
<p>TEXT STYLES <i>Function: give the current text styles</i> ................................................................................ 5.6.04</p>
<p>TH <i>Interface Function: return the height of the current font, in pixels</i> ....................................................... 9.2.05</p>
<p>THEN <i>Structure: determine action after If</i> ................................................................................................. 5.4.03</p>
<p>TIMER <i>Reserved Variable: count in intervals of 50ths of a second</i> .............................................................. 5.3.11</p>
<p>TITLE BOTTOM <i>Instruction: set a title at the bottom of the current window</i> ........................................... 5.7.02</p>
<p>TITLE TOP <i>Instruction: set a title at the top of the current window</i> .......................................................... 5.7.02</p>
<p>TL <i>Interface Function: return the number of characters in a string of text</i> ................................................. 9.2.05</p>
<p>TO <i>Structure: mark the end of a loop</i> .......................................................................................................... 5.4.09</p>
<p>To <i>AMAL Structure: mark end of a loop</i> ..................................................................................................... 7.6.05</p>
<p>TRACK LOAD <i>Instruction: load a Tracker music module</i> ......................................................................... 8.3.02</p>
<p>TRACK LOOP OFF <i>Instruction: turn off a Tracker module loop</i> .............................................................. 8.3.03</p>
<p>TRACK LOOP ON <i>Instruction: loop a Tracker module</i> ............................................................................ 8.3.03</p>
<p>TRACK PLAY <i>Instruction: play a Tracker module</i> .................................................................................... 8.3.02</p>
<p>TRACK STOP <i>Instruction: stop all Tracker music</i> ..................................................................................... 8.3.03</p>
<p>TRAP <i>Instruction: trap an error</i> ............................................................................................................... 12.2.04</p>
<p>TRUE <i>Function: holds the value of -1 if a condition is true</i> ........................................................................ 5.4.06</p>
<p>TW <i>Interface Function: return the width of current font text, in pixels</i> ...................................................... 9.2.05</p>
<p>UI <i>Interface Instruction: create a user-defined Interface command</i> ............................................................. 9.2.08</p>
<p>UN <i>Interface Instruction: unpack an image from the Resource Bank</i> .......................................................... 9.4.01</p>
<p>UNDER OFF <i>Instruction: toggle text underlining off</i> ............................................................................... 5.6.03</p>
<p>UNDER ON <i>Instruction: toggle text underlining on</i> ................................................................................. 5.6.03</p>
<p>UNFREEZE <i>Instruction: unfreeze the display</i> ........................................................................................... 7.5.07</p>
<p>UNPACK <i>Picture Compactor Extension: unpack a compacted screen</i> ........................................................ 6.2.06</p>
<p>UNTIL <i>Structure: mark the end of a conditional loop</i> ................................................................................. 5.4.08</p>
<p>UPDATE <i>Instruction: move all Objects at once</i> .......................................................................................... 7.3.04</p>
<p>UPDATE EVERY <i>Instruction: control update in</i> ....................................................................................... 7.6.12</p>
<p>UPDATE OFF <i>Instruction: turn off the automatic Object re-drawing system</i> ........................................... 7.3.04</p>
<p>UPDATE ON <i>Instruction: turn on the automatic Object re-drawing system</i> ............................................ 7.3.04</p>
<p>UPPER$ <i>Function: convert a string of text to upper case</i> ........................................................................... 5.2.03</p>
<p>USING <i>Instruction: format printed output</i> ................................................................................................ 5.6.13</p>
<p>VA <i>Interface Function: return value held by Interface item</i> ........................................................................ 9.1.03</p>
<p>VAL <i>Function: convert a string of digits into a number</i> ............................................................................. 5.2.03</p>
<p>VARPTR <i>Function: read the address of a variable</i> .................................................................................... 14.A.06</p>
<p>VDIALOG <i>Function: assign or read an Interface value</i> ............................................................................. 9.3.05</p>
<p>VDIALOG$ <i>Function: assign or read an Interface string</i> .......................................................................... 9.3.05</p>
<p>VIEW <i>Instruction: display the current view setting</i> ................................................................................... 6.1.04</p>
<p>VLine <i>Interface Instruction: draw a vertical line from packed image components</i> ...................................... 9.4.02</p>
<p>VOICE <i>Instruction: activate a voice</i> ........................................................................................................... 8.3.03</p>
<p>VOLUME <i>Instruction: control the volume of sound</i> .................................................................................. 8.3.03</p>
<p>VREV BLOCK <i>Instruction: flip a block vertically</i> ...................................................................................... 7.7.04</p>
<p>14.G.18</p>
<p>C</p>
<p>O</p>
<p>M</p>
<p>M</p>
<p>A</p>
<p>N</p>
<p>D</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Command Index</p>
<p>VREV <i>Function: flip an image vertically</i> .................................................................................................... 7.2.11</p>
<p>VS <i>Interface Instruction: create an animated vertical slider bar</i> .................................................................. 9.3.09</p>
<p>VSCROLL <i>Instruction: scroll text vertically</i> .............................................................................................. 5.6.12</p>
<p>VSLIDER <i>Instruction: draw a vertical slider bar</i> ........................................................................................ 5.7.05</p>
<p>VT <i>Interface Instruction: display vertical text</i> ............................................................................................ 9.2.06</p>
<p>VU <i>AMAL Function: give intensity of current voice</i> .................................................................................. 7.6.09</p>
<p>VUMETER <i>Function: test the volume of a voice</i> ........................................................................................ 8.1.09</p>
<p>WAIT <i>Instruction: wait before performing the next instruction</i> ................................................................. 7.6.16</p>
<p>WAIT KEY <i>Instruction: wait for a key-press</i> ............................................................................................ 10.1.04</p>
<p>WAIT VBL <i>Instruction: wait for the next vertical blank period</i> .................................................................. 6.2.05</p>
<p>Wait <i>AMAL Instruction: turn off main program and wait for Autotest</i> ..................................................... 7.6.07</p>
<p>WAVE <i>Instruction: assign a wave to a sound channel</i> ................................................................................ 8.1.06</p>
<p>WEND <i>Structure: mark the end of a conditional loop</i> ................................................................................. 5.4.08</p>
<p>WHILE <i>Structure: mark the start of a conditional loop</i> .............................................................................. 5.4.08</p>
<p>WIND CLOSE <i>Instruction: close the current window</i> ............................................................................... 5.7.03</p>
<p>WIND MOVE <i>Instruction: move the current window</i> ............................................................................... 5.7.03</p>
<p>WIND OPEN <i>Instruction: create a window</i> ............................................................................................... 5.7.01</p>
<p>WIND SAVE <i>Instruction: save the contents of the current window</i> .......................................................... 5.7.03</p>
<p>WIND SIZE <i>Instruction: change the size of the current window</i> ............................................................... 5.7.04</p>
<p>WINDON <i>Function: give the value of the current window</i> ........................................................................ 5.7.03</p>
<p>WINDOW <i>Instruction: change the current window</i> .................................................................................. 5.7.01</p>
<p>WRITING <i>Instruction: select text writing mode</i> ........................................................................................ 5.6.04</p>
<p>X BOB <i>Function: give the x-coordinate of a Bob</i> ......................................................................................... 7.2.03</p>
<p>X CURS <i>Function: give the x-coordinate of the text cursor</i> ........................................................................ 5.6.09</p>
<p>X GRAPHIC <i>Function: convert text x-coordinate to graphic x-coordinate</i> .............................................. 11.1.04</p>
<p>X HARD <i>Function: convert screen x-coordinate to hardware x-coordinate</i> ................................................ 7.1.10</p>
<p>X MENU <i>Function: give graphical x-coordinate of a menu item</i> ................................................................ 6.5.10</p>
<p>X MOUSE <i>Reserved Variable: give/set x-coordinate of mouse pointer</i> ........................................................ 5.8.04</p>
<p>X SCREEN <i>Function: convert hardware x-coordinate to screen x-coordinate</i> ............................................ 7.1.09</p>
<p>X SPRITE <i>Function: give x-coordinate of a Sprite</i> ...................................................................................... 7.1.09</p>
<p>X TEXT <i>Function: convert graphic x-coordinate to text x-coordinate</i> ....................................................... 11.1.04</p>
<p>XA <i>Interface Function: get the previous x-coordinate of the graphics cursor</i> .............................................. 9.2.02</p>
<p>XB <i>Interface Function: get the current x-coordinate of the graphics cursor</i> ................................................ 9.2.02</p>
<p>XGR <i>Function: give x-coordinate of the graphics cursor</i> ............................................................................. 6.4.02</p>
<p>XH <i>AMAL Function: convert screen x-coord to hardware x-coord</i> ............................................................. 7.6.10</p>
<p>XM <i>AMAL Function: give hardware x-coord of mouse cursor</i> .................................................................... 7.6.10</p>
<p>XS <i>AMAL Function: convert hardware x-coord to screen x-coord</i> .............................................................. 7.6.10</p>
<p>XY <i>Interface Instruction: set graphics variables</i> .......................................................................................... 9.2.08</p>
<p>Y BOB <i>Function: give the y-coordinate</i> ....................................................................................................... 7.2.03</p>
<p>Y CURS <i>Function: give the y-coordinate of the text cursor</i> ........................................................................ 5.6.09</p>
<p>Y GRAPHIC <i>Function: convert text y-coordinate to graphic y-coordinate</i> .............................................. 11.1.04</p>
<p>14.G.19</p>
<p>C</p>
<p>O</p>
<p>M</p>
<p>M</p>
<p>A</p>
<p>N</p>
<p>D</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>Command Index</p>
<p>Y HARD <i>Function: convert screen y-coordinate to hardware y-coordinate</i> ................................................ 7.1.10</p>
<p>Y MENU <i>Function: give graphical y-coordinate of a menu item</i> ................................................................ 6.5.10</p>
<p>Y MOUSE <i>Reserved Variable: give/set y-coordinate of mouse pointer</i> ........................................................ 5.8.04</p>
<p>Y SCREEN <i>Function: convert hardware y-coordinate to screen y-coordinate</i> ............................................. 7.1.09</p>
<p>Y SPRITE <i>Function: give the y-coordinate of a Sprite</i> ................................................................................ 7.1.09</p>
<p>Y TEXT <i>Function: convert graphic y-coordinate to text y-coordinate</i> ....................................................... 11.1.04</p>
<p>YA <i>Interface Function: get the previous y-coordinate of the graphics cursor</i> ............................................... 9.2.02</p>
<p>YB <i>Interface Function: get the current y-coordinate of the graphics cursor</i> ................................................ 9.2.02</p>
<p>YGR <i>Function: give the y-coordinate of the graphics cursor</i> ....................................................................... 6.4.02</p>
<p>YH <i>AMAL Function: convert screen y-coord to hardware y-coord</i> ............................................................. 7.6.10</p>
<p>YM <i>AMAL Function: give hardware y-coord of mouse cursor</i> .................................................................... 7.6.10</p>
<p>YS <i>AMAL Function: convert hardware y-coord to screen y-coord</i> .............................................................. 7.6.10</p>
<p>Z <i>AMAL Function: give random number</i> ................................................................................................... 7.6.10</p>
<p>ZC <i>Interface Instruction: change the status of a zone</i> .................................................................................. 9.3.12</p>
<p>ZN <i>Interface Function: return the number of a zone</i> ................................................................................... 9.3.14</p>
<p>ZONE <i>Function: give zone number under specified screen coordinates</i> ...................................................... 7.4.06</p>
<p>ZONE$ <i>Function: create a zone around text</i> .............................................................................................. 5.6.11</p>
<p>ZOOM <i>Instruction: change the size of a part of the screen</i> ......................................................................... 6.2.03</p>
<p>ZP <i>Interface Function: return the status of a zone</i> ...................................................................................... 9.3.12</p>
<p>ZV <i>Interface Function: read a zone variable from the internal buffer area</i> ................................................... 9.2.09</p>
<p>14.G.20</p>
<p>C</p>
<p>O</p>
<p>M</p>
<p>M</p>
<p>A</p>
<p>N</p>
<p>D</p>
<p>S</p>
<h1 style="page-break-before:always; "></h1>
<p>App. H: AMOS PD Library</p>
<p><b>Welcome</b> to the AMOS Public Domain Library, providing you with the widest range of programs to </p>
<p>help get the most from AMOS, Easy AMOS and AMOS Professional.</p>
<p>All the programs in the Library have been crafted by AMOS users who want to share the programs </p>
<p>they have written with you. This Library is a source of information and inspiration as to what can be  </p>
<p>achieved with this wonderful programming language. It is run by programmers for programmers, </p>
<p>and full technical support is available for anyone who needs it.</p>
<p>The Library is split into several sections. Some are for programmers only, others can be used by  </p>
<p>anyone, even those deprived people who don't own AMOS! There are demos for you to sit back and </p>
<p>enjoy, and by looking through the source code provided, you too can learn how to achieve such </p>
<p>spectacular effects.</p>
<p>Many   AMOS   users   have   contributed   utility   programs,   specially   written   to   help   make   your </p>
<p>programming   easier.   These   take   the   form   of   HELP   accessory   programs,   giving   easy   access   to </p>
<p>incredible graphics and sound samples from inside AMOS, as well as routines that create special </p>
<p>screen effects, procedures, and an endless list of routines that you can add to your own programs. The </p>
<p>only thing that these programmers ask for their work is the credit for doing it!</p>
<p>If you need music and sound effects for your programs, there are plenty of disks to choose from. </p>
<p>Other categories include slide-show discs, filled with pictures for your entertainment. You can also </p>
<p>select from discs of databases, art packages, music creators, enthusiasts' magazines and educational </p>
<p>programs.</p>
<p>There   are   dozens   of   discs   containing   source   code   programs,   ready   to   be   loaded   inside  AMOS  </p>
<p>Professional. Some are large, many are small, but they are all very interesting, showing just how </p>
<p>versatile AMOS can be.</p>
<p>Of course, no Library is complete without its Games Section, and the AMOS Public Domain Library is </p>
<p>no exception! These games have been written by programmers of all ages and abilities.</p>
<p>There are AMOS versions of all the classics, including your favourite arcade games, simulations, </p>
<p>puzzles, adventures and many more.</p>
<p>All AMOS Users are welcome to send in programs for assessment, as long as a few basic rules are </p>
<p>followed, in keeping with the high standards of the Library.</p>
<p>•</p>
<p>Programs  must  be written  in AMOS,   although  a mixture  of AMOS  and  machine  code  is </p>
<p>allowable.</p>
<p>•</p>
<p>Any programs that have been compiled should have the source code included on disc. This is </p>
<p>because the aim of the Library is to let everyone see how an effect is created. This source code </p>
<p>can take the form of an AMOS program or an ASCII file.</p>
<p>•</p>
<p>If the program is a demo of an AMOS Licenseware production, or a commercial release, the </p>
<p>source code need not be submitted. Please contact the Library for details.</p>
<p>•</p>
<p>Programs will be rejected if they are found to contain anything that could cause offence to </p>
<p>users or their families, including bad language or incitement to prejudice on the grounds of </p>
<p>race, sex or religion. Many children have access to Public Domain programs, and it is </p>
<p>not our Intention to upset anyone if it can be prevented.</p>
<p>14.H.01</p>
<p>P</p>
<p>D</p>
<h1 style="page-break-before:always; "></h1>
<p>AMOS PD Library</p>
<p>When you send in your program, please choose a disc from our Catalogue in exchange to b sent to </p>
<p>you if your program is accepted. Sometimes a program has to be sent back 'to the programmer, often </p>
<p>with suggestions to help improve it, or perhaps it contains bugs that nee~ fixing. All comments are </p>
<p>meant to be constructive, and they will hopefully make your program more popular.</p>
<p><b>AMOS PD Catalogue disc</b></p>
<p>A full catalogue of all the discs in the Library is updated monthly, and is available in disc format.</p>
<p>Prices of Catalogue Disc:</p>
<p>UK £1.00</p>
<p>Europe £1.25</p>
<p>Rest of the World £1.50</p>
<p><b>AMOS PD Library discs</b></p>
<p>Prices of AMOS PD Discs:</p>
<p>UK £2.00 per disc</p>
<p>Europe £2.00 per disc</p>
<p>Rest of the World £2.25 (airmail)</p>
<p><i>One extra PO disc FREE for every 10 discs ordered!</i></p>
<p>All AMOS Public Domain discs are supplied with Official APD labels to match your collection of </p>
<p>AMOS Discs.</p>
<p>The above prices are for single discs, two-disc programs are charged as two single discs.</p>
<p>Please add 50p (postage and packing) to the TOTAL order price. All UK prices include VAT @ 17.5%. </p>
<p>All overseas orders exclude VAT but include extra postage and packing costs.</p>
<p><b>AMOS Updater discs</b></p>
<p>The latest AMOS and AMOS Compiler Updater Discs are always available, at the following prices per </p>
<p>disc:</p>
<p>UK £2.00</p>
<p>Europe £2.00</p>
<p>Rest of the World £2.25 (airmail)</p>
<p>An exchange updating service is available for the following discs:</p>
<p>•</p>
<p>AMOS PD Library Catalogue Disc</p>
<p>•</p>
<p>AMOS Up dater Disc</p>
<p>•</p>
<p>AMOS Compiler Up dater Disc</p>
<p>Just send in your original APD disc, along with a minimum service charge fee, as follows:</p>
<p>UK 75p</p>
<p>Europe 75p</p>
<p>Rest of the World £1.00 (airmail)</p>
<p>Postage and packing are included in these Updater Disc prices.</p>
<p>14.H.02</p>
<p>P</p>
<p>D</p>
<h1 style="page-break-before:always; "></h1>
<p>AMOS PD Library</p>
<p><b>TOTALLY AMOS</b></p>
<p>The  <i>TOTALLY   AMOS</i>  bi-monthly   magazine   is   available   on   disc,   and   is   the   only   disc   magazine </p>
<p>approved by Europress Software for all AMOS enthusiasts. TA is crammed full of articles, tutorials, </p>
<p>AMOS product reviews, routines, artwork, sound samples, screen effects, letters, hints, tips, AMOS </p>
<p>for Beginners, readers' adverts ... and whatever YOU want to see! A Public Domain sample disc of </p>
<p><i>TOTALLY AMOS</i> is available as Catalogue number APD341.</p>
<p>Issue-1 was released in November 1991, with following issues released at two-month intervals.</p>
<p>Single Issues of TA are available at the following prices:</p>
<p>UK £2.50</p>
<p>Europe £2.75</p>
<p>Rest of the World £3.00</p>
<p>A six-issue subscription is available at these discount prices:</p>
<p>UK £15.00</p>
<p>Europe £16.50</p>
<p>Rest of the World £18.00</p>
<p>Please make cheques and money orders payable to “AMOS Public Domain Library”.</p>
<p>Overseas orders must be in British currency, drawn on a UK bank. Otherwise an extra £5.00 must be </p>
<p>sent to cover administration costs.</p>
<p>Please send an SAE or International Reply Coupon for more details on any of the above to:</p>
<p>AMOS Public Domain Library,</p>
<p>c/o Anne Tucker, 1 Penmynydd Road, Penlan, Swansea, West Glamorgan SA5 7EH, Wales</p>
<p>14.H.03</p>
<p>P</p>
<p>D</p>
<h1 style="page-break-before:always; "></h1>
<p>App. I: Future Support</p>
<p>Europress Software will continue to follow the needs of you, the user, and meet the demands of the </p>
<p>market-place.   We   welcome   your   comments   and   ideas,   and   we   will   seek   to   improve   AMOS </p>
<p>Professional on a regular basis, wherever possible.</p>
<p>Please refer to the Applications Supplement that accompanies this User Guide. It will help you to get </p>
<p>the   best   out   of   the   demonstration   programs   and   it   offers   some   useful   Golden   Rules   of   games </p>
<p>programming. If you think you have programmed something special, there is no need to be shy! Let </p>
<p>us see what you have achieved by sending a copy of your work on disc to the address below.</p>
<p>We are here to help out with any major problems you may encounter in your home-grown AMOS </p>
<p>Professional programs. To speed things along, you should send a copy of your work on disc, and  </p>
<p><b>highlight</b>  the routine that is causing problems. Please keep a copy of your work, as we cannot be </p>
<p>responsible for items going astray in the post, and provide as many comments and Rem statements in </p>
<p>your listings as possible. Send discs to:</p>
<p>AMOS Professional Help Desk</p>
<p>Europress Software</p>
<p>Europa House</p>
<p>Adlington Park</p>
<p>Macclesfield</p>
<p>Cheshire SK10 4NP</p>
<p>Updates of AMOS Professional are available from the AMOS Public Domain Library. Full details of </p>
<p>this and other services are available in Appendix H of this User Guide.</p>
<p><b>AMOS User Clubs World-wide</b></p>
<p>If you want to make contact with other AMOS Professional programmers, get help, offer services or </p>
<p>exchange   ideas,   there   are   several   User   Clubs  ready   to   welcome   you.   The   following   list   will   be </p>
<p>updated if new User Clubs send us full details of their existence and services.</p>
<p><b>United Kingdom</b></p>
<p>AMOS User Club UK</p>
<p>Aaron Fothergill</p>
<p>1 Lower Moor</p>
<p>Whiddon Valley</p>
<p>Barnstaple</p>
<p>North Devon</p>
<p>EX32 8NW</p>
<p>The AMOS User Club UK offers a Programming Helpline and bi-monthly Club Newsletter, for £12 </p>
<p>UK or £15 overseas annual membership.</p>
<p>14.I.01</p>
<p>F</p>
<p>U</p>
<p>T</p>
<p>U</p>
<p>R</p>
<p>E</p>
<h1 style="page-break-before:always; "></h1>
<p>Welcome</p>
<p><b>Australia</b></p>
<p>The Official Australian AMOS Club</p>
<p>PO Box 253</p>
<p>Rydalmere</p>
<p>New South Wales 2116</p>
<p>Australia</p>
<p><b>Belgium</b></p>
<p>Johan François</p>
<p>Wilgenpark 7</p>
<p>9900 Eeklo</p>
<p>Belgium</p>
<p><b>Germany</b></p>
<p>Asternweg 4</p>
<p>6229 Walluf</p>
<p>Germany</p>
<p><b>Holland</b></p>
<p>Jurgen Valks</p>
<p>AMOS Club Nederland</p>
<p>Kerkeind 8A</p>
<p>5293 AB Gemonde (NB)</p>
<p>The Netherlands</p>
<p><b>United States</b></p>
<p>AMOS NTSC Club</p>
<p>David Lazerek</p>
<p>516 E 11th Street</p>
<p>Michigan City</p>
<p>Indiana 46360</p>
<p>USA</p>
<p>E-Mail CPI BBS (219) 874-0367</p>
<p>14.I.02</p>
<p>F</p>
<p>U</p>
<p>T</p>
<p>U</p>
<p>R</p>
<p>E</p>
</body>
</html>